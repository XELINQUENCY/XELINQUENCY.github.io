[{"title":"ç¬¬ä¸€ç¯‡æ–‡ç« ","url":"/2025/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"Hello World!æˆ‘æ­£åœ¨æµ‹è¯•Hexoçš„åŠŸèƒ½ï¼Œçœ‹èµ·æ¥ä¼¼ä¹è¿˜æŒºç®€å•çš„ï¼Œå¸Œæœ›æˆ‘æœ‰æ—¶é—´å¤šå†™å†™ã€‚\n\nç®€å•åšä¸ªè‡ªæˆ‘ä»‹ç»ï¼Œå¹»å¤œå­é›¨ï¼Œæˆ–è€…Illunightï¼Œæ•¬ä¸Šã€‚\nIllunightæ¥æºäºillusion + nightï¼Œå³ä¸ºå¹»å¤œï¼Œå­é›¨æ˜¯åå­—ã€‚\næ™®æ™®é€šé€šCTFerï¼Œä¸»æ”»cryptoæ–¹å‘ï¼Œå…¶ä»–é¢†åŸŸå¶æœ‰æ¶‰çŒï¼Œå­¦è‰ºä¸ç²¾ã€‚\nè¶…çº§ç¦ç‘æ§ï¼Œå¦‚æœå»å…¶ä»–ç¤¾äº¤åª’ä½“æœâ€œå¹»å¤œå­é›¨â€ï¼Œä¼šæœåˆ°ç›¸å…³å†…å®¹ã€‚\nåˆ›ç«‹è¿™ä¸ªåšå®¢çš„ç†ç”±ç†ç”±å˜›â€¦â€¦å› ä¸ºæœ€è¿‘æš‘å‡æœŸé—´ï¼Œæ¯”è¾ƒæ— èŠï¼Œäºæ˜¯åˆ·å„ç§cryptoé¢˜ï¼Œå†™é¢˜è§£ã€‚ä½†æ˜¯å†™äº†è¿™ä¹ˆå¤šçš„é¢˜è§£åªç»™è‡ªå·±çœ‹ä¹Ÿå¤ªäºäº†ï¼Œäºæ˜¯å°±å‘ˆä¸Šæ¥ï¼Œæ³æ±‚æ‰¹è¯„ä¸æŒ‡å¯¼ã€‚\nï¼ˆä¸€å…±ä¹Ÿæ²¡å†™å‡ ä»½ï¼Œåšå®¢å€’æ˜¯åˆ›å¾—èµ·åŠ²ğŸ™„å­é›¨ä½ é€‚å¯è€Œæ­¢ï¼‰\næ€»ä¹‹å°±æ˜¯è¿™æ ·~è™½ç„¶æ¯”è¾ƒè½»ç‡åœ°å°±æ”¾ä¸Šæ¥äº†ï¼Œä¸è¿‡ä¹Ÿæ˜¯å¯¹è‡ªå·±çš„ä¸€ç§ç£ä¿ƒå§ï¼Œå¤šåšï¼Œå¤šè§è¯†ã€‚\né»‘å†å²â€¦â€¦ï¼Ÿæˆ‘å·²ç»åšå¥½è¿™äº›æ–‡ç« æˆä¸ºè‡ªå·±é»‘å†å²çš„é¢„æœŸäº†ï¼Œå¦‚æœæ²¡æœ‰å¯¹è¿‡å»çš„æ‰¹åˆ¤ï¼Œä¹Ÿå°±æ²¡æœ‰è¿›æ­¥äº†hhh\n","categories":["ç¬”è®°"],"tags":["\\#illunight"]},{"title":"Hello World","url":"/2025/07/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n"},{"title":"CryptoCTF é¢˜è§£","url":"/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/","content":"å‰è¨€æœ€è¿‘æ­£å€¼æš‘å‡ï¼Œé—²ç€ä¹Ÿæ˜¯é—²ç€ï¼Œäºæ˜¯æ¥ç©ç©å§ã€‚æˆ‘å‘ç°è‡ªå·±çœŸçš„å¾ˆå¼±å°ï¼Œè¿™äº›èµ›é¢˜çš„åˆ†å€¼ä¸è§£å‡ºçš„é˜Ÿä¼æ•°é‡æˆåæ¯”ï¼Œå°†æ‰€æœ‰çš„é¢˜ç›®æŒ‰ç…§æœ€ç»ˆåˆ†å€¼æ’åºï¼Œæˆ‘æ°å¥½å®Œæˆäº†åˆ†å€¼æœ€å°‘çš„å››é“ã€‚åŠ ä¸Šäº‹åè¡¥çš„ä¸¤é“ï¼Œå…±å®Œæˆäº†åˆ†å€¼æœ€å°‘çš„å…­é“ã€‚\nâ€”â€”å°±æ˜¯è¯´éš¾çš„ä¸€é“éƒ½ä¸ä¼šï¼ˆèººï¼‰\næ­£æ–‡æ—¢ç„¶éƒ½è¿™æ ·äº†ï¼Œé‚£å¹²è„†å°±æŒ‰ç…§æœ€ç»ˆé¢˜ç›®åˆ†æ•°å‡åºå†™é¢˜è§£å§ï¼ŒæŒ‰ç†æ¥è¯´ï¼Œè¶Šå‰é¢çš„è¶Šç®€å•ã€‚\n1.Vinadè§‚å¯Ÿä»£ç ï¼Œæˆ‘ä»¬å¾—åˆ°äº†pubkeyçš„ç¬¬1å’Œç¬¬2é¡¹ï¼Œå³Rå’Œp*qï¼Œå’ŒåŠ å¯†åçš„cã€‚è‹¥è¦è§£å‡ºåŸæ–‡ï¼Œéœ€è¦å¾—åˆ°pæˆ–è€…qï¼Œä»¥åŠeã€‚åœ¨genkey()å‡½æ•°ä¸­ï¼Œqæ˜¯éšæœºç”Ÿæˆçš„512ä½è´¨æ•°ï¼Œpå’Œeéƒ½ä¸å‡½æ•°vinad()æœ‰å…³ï¼Œæˆ‘ä»¬è‡ªç„¶æƒ³çŸ¥é“ï¼Œvinad()åœ¨åšä»€ä¹ˆã€‚å¯¹äºç»™å®šçš„åˆ—è¡¨Rï¼Œvinad()å–å‡ºæ¯ä¸€ä¸ªå…ƒç´ rï¼Œå°†å…¶ä¸xå¼‚æˆ–ï¼Œè¿”å›å¼‚æˆ–åçš„&#39;1&#39;çš„ä¸ªæ•°çš„å¥‡å¶ï¼Œå¥‡æ•°ä¸º1ï¼Œå¶æ•°ä¸º0ã€‚å°†æ‰€æœ‰çš„rå¦‚æ­¤æ“ä½œï¼Œç»“æœæ‹¼æˆçš„å­—ç¬¦ä¸²å°±æ˜¯è¿”å›å€¼çš„äºŒè¿›åˆ¶å½¢å¼ã€‚å‡è®¾å…¶ä¸­æŸä¸¤æ¬¡å–å‡ºçš„å…ƒç´ ä¸º$r_1$å’Œ$r_2$ï¼Œé‚£ä¹ˆï¼Œè®°$x \\oplus r_1 = k_1$ï¼Œ$x \\oplus r_2 = k_2$ï¼Œåˆ™$k_1 \\oplus k_2 = \\text{XOR}(x,r_1,x,r_2)$ã€‚è€Œ$x \\oplus x = 0$ï¼Œå¯¹ç»“æœæ²¡æœ‰å½±å“ï¼Œæ‰€ä»¥$k_1 \\oplus k_2 = r_1 \\oplus r_2$ã€‚å…¶ä¸­$\\oplus$ç¬¦å·å’Œ$\\text{XOR}$å‡è¡¨ç¤ºå¼‚æˆ–ã€‚è¿™æ ·ä¸€æ¥ï¼Œè™½ç„¶xæ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æœªçŸ¥æ•°ï¼Œä½†ä»»æ„ä¸¤ä¸ªç»“æœçš„å¼‚æˆ–å€¼éƒ½å·²ç»èƒ½ä»Rä¸­çŸ¥æ™“ï¼Œæ¢è¨€ä¹‹ï¼Œåªè¦çŸ¥é“äº†å…¶ä¸­ä¸€ä¸ªç»“æœ(0æˆ–è€…1)ï¼Œå°±çŸ¥é“äº†å…¨éƒ¨çš„ç»“æœã€‚xå®é™…ä¸Šå’Œåªèƒ½å–0/1æ²¡æœ‰åŒºåˆ«ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å–x=0ï¼Œå¾—åˆ°Q = int(&#39;&#39;.join(str(parinad(R[i])) for i in range(512)), 2)ï¼Œå¾—åˆ°pçš„ä¸€ä¸ªå€™é€‰å€¼ï¼›å¦‚æœn%Q!=0ï¼Œå³Qä¸æ­£ç¡®ï¼Œé‚£ä¹ˆï¼Œå°†æ¯ä¸€ä½å–åï¼Œå°±æ˜¯å¦ä¸€ä¸ªå€™é€‰å€¼Q_altã€‚ç»è¿‡éªŒè¯ï¼Œå¯ä»¥å¾—åˆ°på’Œqã€‚\nå¯¹äºeï¼Œæˆ‘ä»¬å·²ç»åˆ†æå¾—åˆ°vinad()å‡½æ•°åœ¨Rç»™å®šçš„æƒ…å†µä¸‹åªæœ‰ä¸¤ç§å¯èƒ½çš„ç»“æœï¼Œç”¨Qå’ŒQ_altè¯•ä¸¤æ¬¡å°±å¯ä»¥ã€‚\n#Crypto CTF https://cr.yp.toc.tf/ vinadé¢˜è§£from Crypto.Util.number import *R = [] #Rå¤ªå ç‰ˆé¢äº†ï¼Œå°±åˆ æ‰äº†ã€‚é¢˜ç›®é™„ä»¶é‡Œå·²ç»ç»™å‡ºn = 58113574203067314600162910771848744432179168354040678920098167335472534222998261639291145191568159464990603689062679467360303185717662426122140998218656632568172511390111887830539687208220100574329903748617343193392646019854280519859403817579746765861359633174218846216669659258251676438195667516224684805919c = 56754194307199340085459028397027924827853574000671575387226403396873568994756738512141122143372650573201079937375922460851170745485734799044781029943783218210457587599666501326645229924138230588050782907693019958930006807017898115655426823272342984109999519420817119999272583495848119171867835187241510764427def parinad(n):    return bin(n)[2:].count(&#x27;1&#x27;) % 2# 1. æ±‚å‡ºpå’ŒqQ = int(&#x27;&#x27;.join(str(parinad(R[i])) for i in range(512)), 2)Q_alt = (1&lt;&lt;512) - 1 - Qif n % Q == 0 and isPrime(Q):    p = Qelse:    p = Q_alt#print(p)assert isPrime(p) and n%p==0#print(sum(R))e = Q_altq = n//p# 2. è®¡ç®—æ¬§æ‹‰å‡½æ•° Ï†(n)phi_n = (q - 1)*(p - 1)#print(&quot;phi = &quot;,phi_n)# 3. è®¡ç®— d (e çš„æ¨¡ Ï†(n) çš„ä¹˜æ³•é€†å…ƒ)d = inverse(e, phi_n)#print(&quot;d = &quot;,d)# 4. è§£å¯†æ¶ˆæ¯ mm = pow(c, d, n)  # å¿«é€Ÿæ¨¡å¹‚è¿ç®—print(&quot;è§£å¯†åçš„æ¶ˆæ¯ m ä¸º:&quot;, long_to_bytes(m - sum(R)))#CCTF&#123;s0lV1n9_4_Syst3m_0f_L1n3Ar_3qUaTi0n5_0vEr_7H3_F!3lD_F(2)!&#125;#æœ¬é¢˜ç”±ChatGPTæä¾›æ€è·¯ä¸ä»£ç \n2.Interpolè§‚å¯Ÿä»£ç ï¼Œrandpos()å‡½æ•°åœ¨0å’Œ1ä¹‹é—´é€‰ä¸€ä¸ªæ•°ã€‚å¦‚æœé€‰1ï¼Œè¿”å›Trueå’Œä¸€ä¸ªæœ‰ä¸¤ä¸ªæ•°çš„å…ƒç»„ï¼Œè¿™ä¸¤ä¸ªæ•°å’Œflagç›¸å…³ï¼›å¦‚æœé€‰0ï¼Œè¿”å›Falseå’Œå¦å¤–ä¸€ä¸ªå…ƒç»„ï¼Œè¿™ä¸ªå…ƒç»„çš„ä¸¤ä¸ªæ•°æ˜¯ä¸€ä¸ªéšæœºæ•´æ•°å’Œä¸€ä¸ªéšæœºçš„æœ‰ç†æ•°ã€‚æ¥ä¸‹æ¥æ˜¯while(True)éƒ¨åˆ†ï¼šå…ˆå¾—åˆ°ä¸€ä¸ªrandpos()çš„ç»“æœï¼Œå¦‚æœè¿”å›Trueï¼Œé‚£ä¹ˆnè‡ªå¢1ï¼Œå¦åˆ™nä¸å¢åŠ ã€‚ä½†æ— è®ºå¦‚ä½•ï¼ŒDATAéƒ½ä¼šå°†æ–°ç”Ÿæˆçš„å…ƒç»„åŠ å…¥ï¼Œä¾‹å¤–æƒ…å†µæ˜¯_d[0][0]åœ¨Hä¸­ï¼Œå³å…ƒç»„çš„ç¬¬ä¸€ä¸ªæ•°åœ¨Hä¸­ã€‚æ¥ä¸‹æ¥ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥æ’å€¼ï¼Œå°†ä»¥ä¸Šå…ƒç»„è¡¨ç¤ºçš„ç‚¹å˜ä¸ºä¸€ä¸ªæœ‰ç†æ•°åŸŸçš„å‡½æ•°ï¼Œæˆ‘ä»¬æœ€åå¾—åˆ°äº†è¿™ä¸ªå‡½æ•°ã€‚å› æ­¤ï¼Œå‡½æ•°ä¸Šçš„ç‚¹å°±åŒ…å«äº†flagä¸Šçš„ç‚¹ï¼Œæ ¹æ®randpos()å‡½æ•°æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œç”±flagå¾—åˆ°çš„ç‚¹ï¼Œå…¶æ¨ªåæ ‡ä¸€å®šæ˜¯è´Ÿæ•°ï¼Œçºµåæ ‡ä¸€å®šæ˜¯æ•´æ•°ï¼Œè€Œéšæœºç‚¹çš„æ¨ªåæ ‡å¤§äºç­‰äº0ï¼Œçºµåæ ‡ä¹Ÿæ˜¯ä¸¤ä¸ªè´¨æ•°ä¹‹æ¯”ï¼Œä¸ä¼šæ˜¯æ•´æ•°ã€‚æˆ‘ä»¬æ®æ­¤å¾—åˆ°æ‰€æœ‰æ»¡è¶³x&lt;0çš„æ•´ç‚¹ï¼Œå°±æ˜¯ç”±flagå¾—åˆ°çš„ç‚¹ã€‚å¯¹äºç‚¹(-x,y)ï¼Œæˆ‘ä»¬æœ‰x = 1 + (19*n - 14) % len(flag)ï¼Œy = ord(flag[(63 * n - 40) % len(flag)])ã€‚ï¼ˆn&lt;len(flag)ï¼‰å³ï¼š$n = (x + 13)  \\text{inverse}(19)\\space mod\\space \\text{len(flag)}$ï¼Œ$\\text{chr}(y) = \\text{flag}[(63  n - 40)\\space mod\\space \\text{len(flag)}]$ã€‚äºæ˜¯å¯ä»¥æ ¹æ®æ¯ä¸ªxå¾—åˆ°å¯¹åº”çš„nï¼Œè¿›è€Œå¾—åˆ°flagä¸­æ¯ä¸ªå­—ç¬¦çš„ä½ç½®ã€‚è¿™é‡Œå‡è®¾len(flag)å’Œ19ï¼Œå’Œ63å‡äº’è´¨ï¼Œå¦åˆ™ï¼Œflagä¸å”¯ä¸€ã€‚\n#Crypto CTF https://cr.yp.toc.tf/ Interpolé¢˜è§£#!/usr/bin/env sage# ä» output.raw åŠ è½½åºåˆ—åŒ–å¤šé¡¹å¼with open(&#x27;output.raw&#x27;, &#x27;rb&#x27;) as f:    poly_str = f.read()# ååºåˆ—åŒ–å¤šé¡¹å¼P = loads(poly_str)# å®šä¹‰å¤šé¡¹å¼å‡½æ•° p(x)p = P# æ­¥éª¤1: æ”¶é›†å€™é€‰çœŸç‚¹ (x, y)ï¼Œå…¶ä¸­ x ä¸ºè´Ÿæ•´æ•°ï¼Œp(x) ä¸ºæ•´æ•°points = []x_val = -1consecutive_non_integer = 0threshold = 20  # è¿ç»­éæ•´æ•°é˜ˆå€¼ï¼Œç”¨äºåœæ­¢è¿­ä»£while consecutive_non_integer &lt; threshold:    try:        y_val = p(x_val)  # è®¡ç®— p(x)        # æ£€æŸ¥æ˜¯å¦ä¸ºæ•´æ•°ï¼ˆæœ‰ç†æ•°ä¸”åˆ†æ¯ä¸º1ï¼‰        if y_val in ZZ or (y_val in QQ and y_val.denominator() == 1):            points.append((x_val, ZZ(y_val)))  # è®°å½•ç‚¹            consecutive_non_integer = 0  # é‡ç½®è®¡æ•°å™¨        else:            consecutive_non_integer += 1    except Exception as e:  # å¤„ç†å¯èƒ½çš„æ±‚å€¼é”™è¯¯ï¼ˆå¦‚ x è¿‡å¤§ï¼‰        consecutive_non_integer += 1    x_val -= 1  # ç§»è‡³ä¸‹ä¸€ä¸ªè´Ÿæ•´æ•°if not points:    raise ValueError(&quot;æœªæ‰¾åˆ°å€™é€‰ç‚¹ã€‚æ£€æŸ¥æ–‡ä»¶è·¯å¾„æˆ–å¤šé¡¹å¼ã€‚&quot;)# æŒ‰ x æ’åºï¼ˆé™åºï¼š-1, -2, -3, ...ï¼‰points.sort(key=lambda pt: pt[0], reverse=True)# æ­¥éª¤2: æ¨å¯¼ L = len(flag)min_x = min(x for x, y in points)  # æœ€å° xï¼ˆæœ€è´Ÿï¼‰L_candidate = -min_x  # L = -min_xnum_points = len(points)# éªŒè¯ç‚¹æ•°æ˜¯å¦åˆç†ï¼ˆåº”æ¥è¿‘ L_candidateï¼‰if num_points &lt; L_candidate:    print(f&quot;è­¦å‘Š: åªæ‰¾åˆ° &#123;num_points&#125; ä¸ªç‚¹ï¼Œä½† L_candidate = &#123;L_candidate&#125;ã€‚å¯èƒ½æœ‰é—æ¼ã€‚&quot;)elif num_points &gt; L_candidate:    print(f&quot;è­¦å‘Š: æ‰¾åˆ° &#123;num_points&#125; ä¸ªç‚¹ï¼Œä½† L_candidate = &#123;L_candidate&#125;ã€‚å¯èƒ½æœ‰è¯¯æŠ¥ã€‚&quot;)    # æˆªæ–­è‡³å‰ L_candidate ä¸ªç‚¹ï¼ˆå‡è®¾ x æœ€å°çš„ç‚¹å¯èƒ½ä¸ºè¯¯æŠ¥ï¼‰    points = points[:L_candidate]L = L_candidate  # ä½¿ç”¨ L_candidate ä½œä¸º flag é•¿åº¦# æ­¥éª¤3: è®¡ç®— 19 æ¨¡ L çš„é€†å…ƒï¼ˆç”¨äºç´¢å¼•æ˜ å°„ï¼‰try:    inv19 = inverse_mod(19, L)  # 19 åœ¨æ¨¡ L ä¸‹çš„é€†å…ƒexcept Exception as e:    raise ValueError(f&quot;19 å’Œ L=&#123;L&#125; ä¸äº’è´¨ï¼Œæ— æ³•è®¡ç®—é€†å…ƒã€‚é”™è¯¯: &#123;e&#125;&quot;)# æ­¥éª¤4: æ˜ å°„æ¯ä¸ªç‚¹åˆ° flag å­—ç¬¦flag_array = [None] * L  # åˆå§‹åŒ– flag æ•°ç»„for x, y in points:    # è®¡ç®— a = (19n - 14) % Lï¼ˆæ¥è‡ªçœŸç‚¹ x å…¬å¼ï¼‰    a = -1 - x  # å› ä¸º x = -(1 + a)    if a &lt; 0 or a &gt;= L:        print(f&quot;è­¦å‘Š: x=&#123;x&#125; çš„ a=&#123;a&#125; è¶…å‡º [0, L-1]ã€‚è·³è¿‡ã€‚&quot;)        continue        # è®¡ç®— nï¼ˆçœŸç‚¹ç´¢å¼•ï¼‰    c = a + 14  # æ¥è‡ª a = (19n - 14) % L    n_val = (c * inv19) % L  # n = (c * inv19) mod L        # è®¡ç®— bï¼ˆflag å­—ç¬¦ä½ç½®ï¼‰    b_val = (63 * n_val - 40) % L  # b = (63n - 40) % L        # æ£€æŸ¥ y æ˜¯å¦ä¸ºå¯æ‰“å° ASCII    if y &lt; 32 or y &gt; 126:        print(f&quot;è­¦å‘Š: x=&#123;x&#125; çš„ y=&#123;y&#125; ä¸æ˜¯å¯æ‰“å° ASCIIã€‚è·³è¿‡ã€‚&quot;)        continue        # å­˜å‚¨å­—ç¬¦ï¼ˆä½ç½® b_valï¼‰    flag_array[b_val] = chr(y)# æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä½ç½®éƒ½å·²å¡«å……if None in flag_array:    missing = [i for i, char in enumerate(flag_array) if char is None]    print(f&quot;è­¦å‘Š: ä½ç½® &#123;missing&#125; æœªå¡«å……ã€‚å°è¯•è°ƒæ•´ç‚¹é›†åˆæˆ– Lã€‚&quot;)else:    print(&quot;æ‰€æœ‰ä½ç½®å¡«å……æˆåŠŸã€‚&quot;)# æ„å»º flag å­—ç¬¦ä¸²flag_str = &#x27;&#x27;.join(flag_array)print(f&quot;æ¢å¤çš„ flag: &#123;flag_str&#125;&quot;)#CCTF&#123;7h3_!nTeRn4t10naL_Cr!Min41_pOlIc3_0r9An!Zati0n!&#125;#æœ¬é¢˜ç”±ChatGPTå’ŒDeepseekæä¾›æ€è·¯ï¼ŒDeepseekæä¾›ä»£ç \n3.Mechanicä»£ç å¾ˆçŸ­ï¼Œä½†æ˜¯é‡è§äº†ä¸è®¤è¯†çš„åº“ï¼Œå¤šåŠæ˜¯åœ¨è°ƒç”¨åº“å‡½æ•°åŠ å¯†äº†ï¼Œä¸Šç½‘æ‰¾æ‰¾å¦‚ä½•è§£å¯†ã€‚æœç´¢KryptonKEMæ‰¾åˆ°äº†https://github-wiki-see.page/m/aabmets/quantcrypt/wiki/Code-Examplesï¼Œçœ‹åˆ°â€œKryptonKEM for Asymmetric File Encryptionâ€ä¸€èŠ‚ï¼Œæ‰¾åˆ°äº†ç›¸å…³çš„ç¤ºä¾‹ä»£ç ã€‚åŠ å¯†çš„æµç¨‹æ˜¯ï¼Œè¯»å–flag.pngï¼Œç”Ÿæˆ40ä½éšæœºæ•°ï¼Œæ ¹æ®è¯¥éšæœºæ•°çš„æ¯”ç‰¹ï¼Œå†³å®šæ˜¯å¯¹æ˜æ–‡/ä¸Šä¸€è½®å¯†æ–‡è¿›è¡Œä¸€æ¬¡åŠ å¯†ï¼Œå¹¶å°†skey(secret_key)å†™å…¥æ–‡ä»¶ä¸­ï¼Œè¿˜æ˜¯ä¼ªé€ ä¸€ç»„skeyå†™å…¥æ–‡ä»¶ä¸­ã€‚å› æ­¤ï¼Œä¸€å…±ç”Ÿæˆäº†40æ¬¡å¯†é’¥ï¼Œå…¶ä¸­æœ‰éƒ¨åˆ†æ˜¯çœŸçš„ï¼Œä¹Ÿæœ‰ä¸€äº›æ˜¯å‡çš„ã€‚æ ¹æ®æœ€åçš„æ–‡ä»¶åflag_22.encï¼Œä¸€å…±è¿›è¡Œäº†23è½®åŠ å¯†ã€‚åŒæ—¶æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå…ˆåŠ å¯†çš„å¯†é’¥ä¸€å®šåœ¨ååŠ å¯†çš„å¯†é’¥ä¹‹å‰ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥ä»æœ€åä¸€ä¸ªå¯†é’¥å¼€å§‹ï¼Œä¸æ–­å‘å‰è¯•æ¢ï¼Œå¾—åˆ°æœ€åˆçš„æ–‡ä»¶ã€‚å¦‚æœé‡åˆ°å‡ç§é’¥ï¼Œè§£å¯†ä¼šæŠ¥é”™ï¼Œæ ¹æ®èƒ½å¦è§£å¯†åˆ¤æ–­æ˜¯å¦ä¸ºçœŸçš„ç§é’¥ã€‚ä¸ºäº†é˜²æ­¢è§£å¯†ä¸­é—´æ–‡ä»¶è¢«å ç”¨è€Œæ— æ³•å†™å…¥ï¼Œæ¯ä¸€ä¸ªæ–‡ä»¶éƒ½ä½¿ç”¨ä¸åŒçš„æ–‡ä»¶åã€‚è¿è¡Œä¸€éç¨‹åºï¼Œå°±å¯ä»¥å¾—åˆ°æœ€åˆçš„flag.pngä»¥åŠï¼Œkem.param_sizes.sk_size = 3168ï¼ˆè‡ªå·±å·å·è£…è¿™ä¸ªåº“ï¼Œåœ¨pythonè·‘ä¸€éå°±çŸ¥é“äº†ï¼‰\n#Crypto CTF https://cr.yp.toc.tf/ mechanicé¢˜è§£#!/usr/bin/env python3from quantcrypt.kem import MLKEM_1024from quantcrypt.cipher import KryptonKEMfrom pathlib import Pathkem = MLKEM_1024()kry = KryptonKEM(MLKEM_1024)SK_SIZE = 3168TOTAL_LAYERS = 23# --- 1. è¯»å–å¹¶åˆ‡åˆ† output.raw ---raw = Path(&#x27;output.raw&#x27;).read_bytes()assert len(raw) % SK_SIZE == 0, &quot;output.raw é•¿åº¦å¿…é¡»æ˜¯ SK_SIZE çš„æ•´æ•°å€&quot;chunks = [ raw[i:i+SK_SIZE]           for i in range(0, len(raw), SK_SIZE) ]# --- 2. å‡†å¤‡åˆå§‹å¯†æ–‡è·¯å¾„ ---current_ct = Path(&#x27;flag_22.enc&#x27;)found_sks = []# ä»åå¾€å‰éå†æ¯ä¸€æ®µç§é’¥for idx, sk in enumerate(reversed(chunks)):    if len(found_sks) &gt;= TOTAL_LAYERS:        break    # ç”Ÿæˆå”¯ä¸€çš„ä¸´æ—¶è¾“å‡ºæ–‡ä»¶å    tmp_path = Path(f&#x27;tmp_&#123;len(found_sks)&#125;.out&#x27;)    try:        # è§£å¯†åˆ°å”¯ä¸€æ–‡ä»¶        kry.decrypt_to_file(sk, current_ct, tmp_path)        # è§£å¯†æˆåŠŸï¼Œè®°å½•ç§é’¥ï¼Œå¹¶æ›´æ–° current_ct        found_sks.append(sk)        current_ct = tmp_path        print(f&quot;âœ” ç”¨ chunks[&#123;len(chunks)-1-idx&#125;] è§£å‡ºäº†ç¬¬ &#123;len(found_sks)&#125; å±‚ â†’ &#123;tmp_path.name&#125;&quot;)    except Exception as e:        print(&quot;ERROR: &quot;,e)        continueassert len(found_sks) == TOTAL_LAYERS, &quot;æ²¡æ‰¾åˆ°æ‰€æœ‰ç§é’¥æ®µï¼&quot;# æœ€ç»ˆæŠŠ current_ct é‡å‘½åä¸º flag.pngcurrent_ct.rename(&#x27;flag.png&#x27;)print(&quot;ğŸ‰ å·²æˆåŠŸè¿˜åŸå‡º flag.png&quot;)#CCTF&#123;k3y_3NcAp5uL4t!0n_M3cH4n1Sms!&#125;#æœ¬é¢˜ç”±ChatGPTæä¾›æ€è·¯å’Œä»£ç ï¼Œç•¥åšä¿®æ­£\n4.Mancityæ°”æ€¥è´¥åçš„å…¸å‹ç¤ºä¾‹â€”â€”ä¸è¿‡è¿˜æ˜¯å…ˆåˆ†æä¸€ä¸‹ä»£ç å§keygen()ç”Ÿæˆäº†ä¸¤ä¸ªè´¨æ•°ï¼Œè¿™ä¸¤ä¸ªè´¨æ•°éƒ½ç”±åŒä¸€ä¸ª256bitçš„è´¨æ•°på˜åŒ–è€Œæ¥ï¼Œè´¨æ•°råœ¨pçš„æ¯ä¸€ä¸ªbitåéƒ½å¢åŠ ä¸€ä¸ª&#39;1&#39;ï¼Œè´¨æ•°qåœ¨påé¢å¢åŠ 256ä¸ª&#39;1&#39;ï¼Œè¿™æ ·qå’Œréƒ½æ˜¯512ä½è´¨æ•°ï¼Œä¸”å…¶ä¸­ä¸€åŠçš„ä½æˆ‘ä»¬å·²ç»çŸ¥é“äº†å‡è®¾bin(p)=10010â€¦01ï¼Œåˆ™r = 1101011101â€¦0111ï¼Œq = 10010â€¦011111â€¦11ï¼Œåˆ™qçš„ä½256ä½å·²çŸ¥ã€‚æˆ‘ä»¬å°†qå’Œråˆ’åˆ†ä¸ºhighå’Œlowï¼Œå…¶ä¸­é«˜256ä½ä¸ºhighï¼Œä½256ä½ä¸ºlowï¼Œåˆ™$q_{low} = 2^{256}-1$ã€‚å¯¹$n = q*r$ä¸¤è¾¹åŒæ—¶æ¨¡$2^{256}$ï¼Œåˆ™å¯çŸ¥$n$çš„ä½256ä½å®Œå…¨ç”±$q_{low}$å’Œ$r_{low}$å†³å®šï¼Œäºæ˜¯å¯ä»¥æ±‚$q_{low}$çš„é€†å…ƒï¼Œä¹˜ä¸Š$n$çš„ä½256ä½ï¼Œå†æ¨¡$2^{256}$ï¼Œå¾—åˆ°$r_{low}$ã€‚$r_{low}$çš„äºŒè¿›åˆ¶å½¢å¼é‡Œï¼Œæœ‰ä¸€åŠæ˜¯&#39;1â€˜ï¼Œå¦ä¸€åŠæ˜¯pçš„ä½128ä½ã€‚ç”±æ­¤æˆ‘ä»¬å¾—åˆ°äº†pçš„ä½128ä½ï¼Œä¹Ÿå°±æ˜¯qçš„256-383ä½ï¼Œäºæ˜¯å¯ä»¥é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œæ¯æ¬¡åªéœ€è¦è°ƒæ•´æ¨¡æ•°ï¼Œå°±å¯ä»¥ä¸æ–­å‘pçš„é«˜ä½æ¨è¿›ã€‚ç†è®ºä¸Šè¿™ä¸ªæ–¹æ³•å¯ä»¥æ¨è¿›åˆ°åªå‰©æœ€å1ä½æœªçŸ¥ï¼Œå®é™…ä¸Šè¿è¡Œåˆ°240ä½çš„æ—¶å€™å°±æŠ¥é”™äº†ï¼Œä¸è¿‡å‰©ä¸‹16ä½å¹¶ä¸ç®—å¤šï¼Œæš´åŠ›ç ´è§£ä¸€è½®å³å¯ã€‚å¾—åˆ°påæ¨å‡ºqå’Œrï¼Œè¿›è€Œè¿˜åŸæ¶ˆæ¯mã€‚\näº‹åå‘ç°ï¼Œå¦‚æœ$r_{low}$è§£å‡ºæ¥çš„æœ€é«˜ä½æ˜¯0ï¼Œé‚£ä¹ˆå¡«å……1çš„ä½ç½®ä¸ä¼šè¢«æ­£ç¡®æ£€æµ‹åˆ°ï¼Œå› è€Œä¸èƒ½å¾—åˆ°æ­£ç¡®çš„pã€‚æˆ‘å¢åŠ äº†å¯¹äº$r_{low}$æ¯”ç‰¹é•¿åº¦çš„æ£€æµ‹ï¼Œå¦‚æœæ˜¯å¥‡æ•°ï¼Œå°±è¡¥ä¸Šæœ€å‰é¢çš„&#39;0&#39;ï¼Œè¿™æ ·å°±å¯ä»¥ç»§ç»­è§£ç äº†ã€‚æ‰æˆ‘æ°”æ€¥è´¥åï¼Œç”šè‡³å†™äº†5ä¸ªåŒæ ·çš„å‡½æ•°å»åšåŒä¸€ä»¶äº‹â€¦â€¦è¿˜æ˜¯ä¸å¤Ÿè€ç»ƒåªéœ€è¦ä½¿ç”¨æœ€åçš„recover()å‡½æ•°ï¼Œå¾ªç¯ä»£å…¥æ¯ä¸€è½®çš„pï¼ŒåŠ ä¸Šæœ€å256ä¸ª&#39;1&#39;ä½œä¸º$q_{low}$ï¼Œå³å¯è§£å‡ºã€‚\n#Crypto CTF https://cr.yp.toc.tf/ Mancityé¢˜è§£def decode(p_man:str):    orig_bits = &#x27;&#x27;    for i in range(0, len(p_man), 2):        two_bits = p_man[i:i + 2]        if two_bits == &#x27;01&#x27;:            orig_bits += &#x27;0&#x27;        elif two_bits == &#x27;11&#x27;:            orig_bits += &#x27;1&#x27;        else:            raise ValueError(f&quot;Invalid bit pair: &#123;two_bits&#125;&quot;)    return orig_bitsdef recover_256(n:int):    q = 2**256-1    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_128(n:int):    q = int(&#x27;11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_64(n:int):    q = int(&#x27;111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_32(n:int):    q = int(&#x27;11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover_16(n:int):    q = int(&#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;+&#x27;1&#x27;*256,2)    modulus = 2 ** (32 + 64 + 128 + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return pdef recover(n:int,q_bit:str):    q = int(q_bit+&#x27;1&#x27;*256, 2)    modulus = 2 ** (len(q_bit) + 256)    inv = pow(q, -1, modulus)    p = bin((n % modulus) * inv % modulus)[2:]    if len(p) % 2:        p = &#x27;0&#x27; + p    assert all(p[i] == &#x27;1&#x27; for i in range(1, len(p), 2))    return p# ç»™å®šå‚æ•°n = 147170819334030469053514652921356515888015711942553338463409772437981228515273287953989706666936875524451626901247038180594875568558137526484665015890594045767912340169965961750130156341999306808017498374501001042628249176543370525803456692022546235595791111819909503496986338431136130272043196908119165239297# æ¢å¤å› å­#p = recover_256(n)#print(decode(p))#ç¬¬ä¸€è½®çš„p:11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#è¿™æ˜¯æœ€ä½çš„128ä½#p2 = recover_128(n)#print(decode(p2))#ç¬¬äºŒè½®çš„p:111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#è¿™æ˜¯128+64=192ä½#p3 = recover_64(n)#print(decode(p3))#ç¬¬ä¸‰è½®çš„pï¼š11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#128+64+32=224ä½#p4 = recover_32(n)#print(decode(p4))#110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111#...+16=240ä½for i in range(10000,2**18):    s = bin(i)[2:] + &#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27; + &#x27;1&#x27;*256    q = int(s, 2)    if not (n%q):        print(q)        break#b&#x27;CCTF&#123;M4nch3sReR_c0D!ng_wI7H_RSA&#125;&#x27;#æœ¬é¢˜ç”±è‡ªå·±æä¾›æ€è·¯å’Œä»£ç \n5.Vainratè¿™é¢˜â€¦â€¦æˆ‘éƒ½æƒ³åŸå°ä¸åŠ¨æ”¾åˆ°æˆ‘ä»¬å­¦æ ¡çš„æ ¡èµ›æˆ–è€…ç±»ä¼¼çš„æ¯”èµ›ä¸Šäº†ï¼Œå¦‚æœæˆ‘æœ‰æœºä¼šçš„è¯ã€‚å¤ªé˜´äº†ï¼Œé˜´å¾—æ²¡è¾¹ã€‚æœåŠ¡å™¨åˆ›å»ºç²¾åº¦ä¸º440ä½çš„å®æ•°åŸŸï¼Œæ¯æ¬¡äº¤äº’æ—¶ï¼Œè¾“å…¥cè·å–æœ€æ–°çš„yå€¼ï¼Œè¾“å…¥qé€€å‡ºã€‚ä½†æ˜¯ï¼Œåªæœ‰å°è¯•çš„æ¬¡æ•°è¶³å¤Ÿå¤šï¼Œæ‰èƒ½æŠ“åˆ°è€é¼ ï¼Œå¾—åˆ°ä½ç½®ï¼Œè‡³å°‘éœ€è¦20æ¬¡å°è¯•ä»¥åï¼Œæ‰èƒ½ç¨³å®šè·å¾—yã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å¾—åˆ°x0ï¼Œä¹Ÿå°±æ˜¯flagè½¬ä¸ºæ•´æ•°åå‰é¢åŠ å°æ•°ç‚¹ã€‚ç”±äºæ¯æ¬¡æ±‚å¹³å‡æ•°å’Œå¼€æ–¹éƒ½ä¼šæœ‰ç²¾åº¦æŸå¤±ï¼Œæœ€åå¯èƒ½ä¸èƒ½ä¸€æ¬¡è§£å‡ºå®Œæ•´çš„flagï¼Œéœ€è¦ä¿®æ­£ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦ä»å¯ä»¥å¾—åˆ°çš„yiä¸­ï¼Œè·å¾—ä¸Šä¸€æ­¥çš„ä¿¡æ¯ï¼Œç›´åˆ°æœ€ç»ˆçš„x0ã€‚ç ”ç©¶ä¸€ä¸‹rat()å‡½æ•°ï¼šç¬¬ä¸€è¡Œå°†xå’Œyæ±‚å¹³å‡æ•°ï¼Œç¬¬äºŒè¡Œå°†ä¸Šä¸€æ­¥çš„xå’Œyæ±‚å‡ ä½•å¹³å‡æ•°ï¼Œæœ€åè¿”å›æ–°çš„xå’Œæ–°çš„yã€‚å¦‚æœç›´æ¥æŠŠä»£ç ä¸¢ç»™AIï¼ŒAIä»¬å¾ˆå®¹æ˜“è¯¯ä»¥ä¸ºè¿™æ®µä»£ç æ˜¯æ±‚xå’Œyçš„ç®—æ•°å¹³å‡æ•°(AM)å’Œå‡ ä½•å¹³å‡æ•°(GM)ï¼Œå¹¶å°†AMèµ‹ç»™xï¼ŒGMèµ‹ç»™yã€‚å› ä¸ºè¢«AIé˜´äº†å¯¼è‡´æ²¡åšå‡ºæ¥ï¼Œå…¶å®ä¸éš¾çš„ã€‚ä»¥åŠï¼Œå¤šæ¬¡è¯•éªŒä¼šå‘ç°ï¼Œyä¼šè¶Šæ¥è¶Šå°ã€‚å¦‚æœå½“æˆAMGMï¼Œé‚£æ¯ä¸ªyéƒ½åº”è¯¥å°äºå¯¹åº”çš„xï¼Œè¿™æ ·yåº”è¯¥è¶Šæ¥è¶Šå¤§ã€‚æˆ‘å…ˆå¾—åˆ°ä¸¤ç»„è¿ç»­çš„yã€‚è¿™é‡Œè¿æ°”ä¸é”™å¾—åˆ°äº†$y_{19}$å’Œ$y_{20}$ï¼Œå¦‚æœæ²¡å¾—åˆ°$y_{19}$ï¼Œæ‹¿$y_{21}$ä¹Ÿä¸€æ ·ã€‚æˆ‘ä»¬æœ‰å…¬å¼$x_i = \\frac{(x_{i-1} + y_{i-1})}{2}$ï¼Œ$y_i = \\sqrt{x_i y_{i-1}}$ã€‚å› æ­¤ï¼Œæ ¹æ®è¿ç»­çš„$y_i$ï¼Œ$y_{i-1}$ï¼Œå¯ä»¥å¾—åˆ°$x_i = \\frac{y_i^2}{y_{i-1}}$ã€‚è¿™æ ·æˆ‘ä»¬å°±æœ‰äº†ä¸€ç»„$x_i$å’Œ$y_i$ã€‚æœ‰äº†$x_i$å’Œ$y_i$ï¼Œå°±æœ‰$y_{i-1} = \\frac{y_i^2}{x_i}$ï¼Œ$x_{i-1} = 2x_i - y_{i-1} = 2x_i - \\frac{y_i^2}{x_i}$ï¼Œå†™å‡ºå‡½æ•°ã€‚å› ä¸ºæ‡’å¾—æ‰“ç†å˜é‡æ‰€ä»¥å³ä½¿xå›åˆ°$x_0$äº†å˜é‡åè¿˜æ˜¯x19ï¼ˆï¼‰æ€»ä¹‹è¿™æ ·å°±èƒ½å¾—åˆ°x0äº†ã€‚ä½†æ˜¯æˆ‘ä»¬ä¸çŸ¥é“flagæœ‰å¤šå°‘ä½ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä½ä¸€ä½å°è¯•ï¼Œè½¬æˆæ¯”ç‰¹åå…¨éƒ½æ˜¯å¯æ‰“å°å­—ç¬¦çš„/ä»¥CCTFå¼€å¤´çš„å°±æ˜¯å¯èƒ½çš„è§£ã€‚\n#Crypto CTF https://cr.yp.toc.tf/ vainraté¢˜è§£from decimal import *from Crypto.Util.number import long_to_bytes&#x27;&#x27;&#x27;def rat(x, y):\tx = R(x + y) * R(0.5)\ty = R((x * y) ** 0.5) #è¿™ä¸ªxæ˜¯ä¸Šä¸€æ­¥çš„x!ä¹Ÿå°±æ˜¯ç®—æ•°å¹³å‡æ•°ï¼Œè€Œä¸æ˜¯å‚æ•°x\treturn x, y&#x27;&#x27;&#x27;getcontext().prec = 460def return_previous(x:Decimal,y:Decimal)-&gt;(Decimal, Decimal):    return (Decimal(2)*x - (y**2/x),y**2/x)def is_bytes_printable(data):    &quot;&quot;&quot;    åˆ¤æ–­byteså¯¹è±¡æ˜¯å¦å¯æ‰“å°ã€‚    Args:        data: byteså¯¹è±¡ã€‚    Returns:        å¦‚æœbyteså¯¹è±¡å¯æ‰“å°ï¼Œè¿”å›Trueï¼Œå¦åˆ™è¿”å›Falseã€‚    &quot;&quot;&quot;    for byte in data:        if not (32 &lt;= byte &lt;= 126):  # æ£€æŸ¥æ˜¯å¦åœ¨ASCIIå¯æ‰“å°å­—ç¬¦èŒƒå›´            return False    return Truey20 = Decimal(&#x27;0.850721739388853613891153549431010808552676731821999538996176033215422247824841783375972792896987047341958120004524577777036176502090&#x27;)y19 = Decimal(&#x27;0.850721739389079303159246072119468136821544049380443888847082554769733382902933214834218375079868150945588972107307455168793172804985&#x27;)y0 = Decimal(&#x27;0.939435784300590373652615235586222521209371224933347916892430414723880727978737194445756901098227178356345123621981413057062575844130&#x27;)x19 = Decimal(2)*y20**Decimal(2)/y19 - y19for i in range(19):    x19,y19 = return_previous(x19,y19)print(&quot;x = &quot;, x19, &quot;y = &quot;, y19)assert abs(y0 - y19) &lt;Decimal(&quot;0.0000000000000000000000000000000000000000000000000000001&quot;)for i in range(1,461):    res = int(x19*(10**i))    if(is_bytes_printable(long_to_bytes(res))): print(long_to_bytes(res))#CCTF&#123;h3Ur1s7!c5_anD_iNv4rIanTs_iN_CryptoCTF_2025!&#125;#æœ¬é¢˜ç”±ChatGPTå’ŒDeepseekæä¾›é”™è¯¯æ€è·¯ï¼Œè‡ªè¡Œè°ƒè¯•å¾—åˆ°æ€è·¯å’Œä»£ç \n6.Matemithflagåˆ†æˆäº†é•¿ä¸º14çš„æ®µï¼Œä½†æ˜¯ä¸çŸ¥é“æœ‰å¤šå°‘æ®µï¼Œç”±äºåé¢ä½¿ç”¨äº†M[0]åˆ°M[5]ï¼Œæˆ‘ä»¬å°±å‡è®¾å®ƒæœ‰6æ®µå§ã€‚fåˆ°kå…±6ä¸ªå‡½æ•°ï¼Œæ¬¡æ•°éƒ½æ˜¯2~3æ¬¡ï¼Œå˜é‡ä¹Ÿå¾ˆå¤šï¼Œæ‰€æœ‰çš„ç³»æ•°éƒ½æ˜¯å°äºæŸä¸ª313ä½è´¨æ•°pçš„éšæœºæ•°ã€‚ç„¶åï¼Œå°†æ¯ä¸ªå‡½æ•°è½¬æ¢åˆ°æœ‰ç†æ•°åŸŸRä¸Šï¼Œä»£å…¥uåˆ°zä¸ºM[0]åˆ°M[5]ï¼Œè®¡ç®—å‡ºç»“æœå­˜å…¥CNSTã€‚ä¾‹ï¼šf(M[0], M[1], M[2], M[3], M[4], M[5]) = COEFS[0] * M[0] * M[1] + COEFS[1] * M[0] + COEFS[2] * M[1]ä¹‹åå¯¹äºæ¯ä¸€ä¸ªå‡½æ•°éƒ½åŠ ä¸Šä¸€ä¸ªå¸¸æ•°é¡¹ï¼Œå¸¸æ•°é¡¹æ˜¯på‡å»ä¸Šé¢çš„è®¡ç®—ç»“æœï¼Œå†æ¨¡pï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ¨¡pçš„æ„ä¹‰ä¸‹ï¼Œæ¯ä¸ªå‡½æ•°éƒ½æ»¡è¶³function(M[0], M[1], M[2], M[3], M[4], M[5])-CNST[function] â‰¡ 0 (mod p)å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ±‚å‡ºæ»¡è¶³å…­ä¸ªåŒä½™æ–¹ç¨‹çš„è§£ï¼Œå¹¶é€‰å‡ºé•¿åº¦å‡ä¸º14å­—èŠ‚çš„æ•´æ•°ç»“æœã€‚ç”±äºæ–¹ç¨‹è¾ƒå¤šï¼Œå˜é‡è¾ƒå¤šï¼Œæ¬¡æ•°ä¹Ÿè¾ƒé«˜ï¼Œå¯ä»¥åˆ†æ‰¹æ±‚è§£ã€‚è§‚å¯Ÿå‘ç°ï¼Œå‡½æ•°f, h, jåªæœ‰u,v,wä¸‰ä¸ªå˜é‡ï¼Œå¯ä»¥è§£å‡ºå®ƒä»¬ã€‚åˆ©ç”¨Sagemathçš„æ±‚è§£å™¨è¿›è¡Œæ±‚è§£ï¼Œæœ‰ä¸€ä¸ªæ˜æ˜¾çŸ­çš„ç»“æœï¼Œå†ç”¨u,v,wä»£å…¥å¦å¤–ä¸‰ä¸ªæ–¹ç¨‹ï¼Œè¿™æ ·å°±åªå‰©ä¸‰ä¸ªå˜é‡ï¼ŒåŒæ ·å¯ä»¥è§£å‡ºã€‚\n#Crypto CTF https://cr.yp.toc.tf/ matemithé¢˜è§£from Crypto.Util.number import *# å®šä¹‰æ¨¡æ•° pp = 9892984422801315119260311427714389408772405421306235794826917610128461644036928139298330716261F = GF(p)  # åˆ›å»ºæœ‰é™åŸŸ# å°†ç³»æ•°è½¬æ¢ä¸ºæœ‰é™åŸŸå…ƒç´ a1 = F(8593371583346286129538282168765198524220954884352992069219549555526097253129502925759872761483)b1 = F(8192555264287905175212103898575474256555217842060435386769432116145712989123062847161390929397)c1 = F(9598573789403814092125115160545174167539204328557118715540593719644188998531033259685435430387)d1 = F(5738603225260621554442220996093767502015758942320213371600986432070445300427944977409453429117)a2 = F(6107224904478508858527197508483774405356161856691777460732363192128980355274418091837270668258)b2 = F(3584245173493717638976874408629921683995390608944250077841702023698807664457252845973088744491)c2 = F(5646173287331462026544218972062953582608380797148923127395811758145598594972832047259631339566)d2 = F(1994681139685786114971936867358158466232859433926848067961874687630342141141862187589124089741)a3 = F(1912186465211454827473018892315659311053527670028135595953520151335825509122313783795561869379)b3 = F(6246883466276200389231653597272295993565421216541002743075041326054203024921176043191679609212)c3 = F(4002308425802254921531592700910138281674785127934610897914017993007060136199147207365547047048)d3 = F(973159800079995512996976852328990077106942094656694887771601292254542762394381629810393447820)# å£°æ˜å¤šé¡¹å¼ç¯å’Œå˜é‡R.&lt;u,v,w&gt; = PolynomialRing(F)# å®šä¹‰æ–¹ç¨‹f = a1*u*v + b1*u + c1*v + d1h = a2*u*w + b2*u + c2*w + d2j = a3*v*w + b3*v + c3*w + d3# åˆ›å»ºç†æƒ³I = R.ideal([f, h, j])# è®¡ç®—è§£é›†solutions = I.variety()# è¾“å‡ºç»“æœif solutions:    print(f&quot;æ‰¾åˆ° &#123;len(solutions)&#125; ä¸ªè§£:&quot;)    for i, sol in enumerate(solutions, 1):        # éªŒè¯è§£        f_val = f.subs(sol)        h_val = h.subs(sol)        j_val = j.subs(sol)        print(f&quot;\\néªŒè¯: f=&#123;f_val&#125;, h=&#123;h_val&#125;, j=&#123;j_val&#125;&quot;)        print(f&quot;è§£ &#123;i&#125;:&quot;)        print(f&quot;u = &#123;sol[u]&#125;, &#123;long_to_bytes(int(sol[u]))&#125;&quot;)        print(f&quot;v = &#123;sol[v]&#125;,  &#123;long_to_bytes(int(sol[v]))&#125;&quot;)        print(f&quot;w = &#123;sol[w]&#125;,  &#123;long_to_bytes(int(sol[w]))&#125;&quot;)        else:    print(&quot;æœªæ‰¾åˆ°è§£&quot;)# å·²çŸ¥çš„ u, v, w å€¼u = F(1078804227986401794161149736863793)v = F(2033644392583863279506423899386719)w = F(1631639702310041336611888741434165)# å°†ç³»æ•°è½¬æ¢ä¸ºæœ‰é™åŸŸå…ƒç´ # g çš„ç³»æ•°a1 = F(7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641)a2 = F(6282097687310252658473848438985225466620614743750918909885172321224925965646628839166491648752)a3 = F(7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641)a4 = F(3354788147890488743832873565215769634619909759459203496980671578348799162553954862104978291860)a5 = F(2560270290674636359252235177920929027441112715609783111306743340637878970846852799006820932563)# i çš„ç³»æ•°b1 = F(7622670835797214156123791992548663880284352234566921286637648219243086701251627093499322050472)b2 = F(6026769215097777844835562389865313764490318485655789123763637718591748620654875700763740623760)b3 = F(8145050175261359549200629067766090532616263522561328878195831921153188650784907223634130346224)b4 = F(3622105614070476540808786980829452605696331317022729645355376801209444137548670550164418237117)b5 = F(4800360746061605999597274870855047707130861888252519642520437605796496240599924899885487900040)# k çš„ç³»æ•°c1 = F(1423338294606985951732736428034353751447528399559929388138157330118213387990891693204997290038)c2 = F(784018806462384388182217012266169299116410899849461442885543245867941419322406775218178098109)c3 = F(7684681843989505989596042520590550892565982707534588920361260899638313817214040416765327284778)c4 = F(4982848574842913858489870338816729222210785430242027484672099513487039514577513464674726403409)c5 = F(7781690757622738625626304200561818137843970209349935834539461705684625161407233281360563620790)# å®šä¹‰å¤šé¡¹å¼ç¯R.&lt;x, y, z&gt; = PolynomialRing(F)# ä»£å…¥å·²çŸ¥çš„ u, v, w åï¼Œg, i, k æˆä¸ºå…³äº x, y, z çš„æ–¹ç¨‹g = a1 * u * x * y + a2 * v + a3 * x + a4 * y + a5i = b1 * v * y * z + b2 * w + b3 * y + b4 * z + b5k = c1 * w * x * z + c2 * u + c3 * x + c4 * z + c5# åˆ›å»ºç†æƒ³I = R.ideal([g, i, k])# æ±‚è§£æ–¹ç¨‹ç»„solutions = I.variety()# è¾“å‡ºç»“æœif solutions:    print(f&quot;æ‰¾åˆ° &#123;len(solutions)&#125; ä¸ªè§£:&quot;)    for idx, sol in enumerate(solutions):        print(f&quot;\\nè§£ &#123;idx + 1&#125;:&quot;)        print(f&quot;x = &#123;sol[x]&#125;&quot;)        print(f&quot;y = &#123;sol[y]&#125;&quot;)        print(f&quot;z = &#123;sol[z]&#125;&quot;)                # éªŒè¯è§£        g_val = g.subs(sol)        i_val = i.subs(sol)        k_val = k.subs(sol)        print(f&quot;éªŒè¯: g=&#123;g_val&#125;, i=&#123;i_val&#125;, k=&#123;k_val&#125;&quot;)else:    print(&quot;æœªæ‰¾åˆ°è§£&quot;)#CCTF&#123;50lv!n6_7H3_H1dD3n__num8Ers_Pr08l3m_f0r_C51dH_4nd_C5uRf_v14_4uT0m473d_C0pp3r5m17h!!?&#125;#æœ¬é¢˜ç”±Deepseekæä¾›ä»£ç \nåè®°è¦å­¦çš„ä¸œè¥¿å¥½å¤šå‘¢â€¦â€¦è™½ç„¶é AIèƒ½è¾…åŠ©ä¸€éƒ¨åˆ†åˆ†æå’Œä»£ç å·¥ä½œï¼Œä¸è¿‡æ›´å¤šçš„è¿˜æ˜¯å¾—é è‡ªå·±&gt;_&lt;\nä¸€å¹´æ¥éƒ½åœ¨æµ…æ°´åŒºé—²é€›ï¼Œæ ¼ç›¸å…³çš„ä¸œè¥¿å‡ ä¹éƒ½ä¸äº†è§£ï¼Œè™½ç„¶ä¹Ÿç»å¸¸å‚è€ƒåˆ«çš„å¸ˆå‚…çš„é¢˜è§£å§ï¼Œä¸è¿‡å¤§å¤šéƒ½çœ‹ä¸å¤ªæ‡‚ï¼Œäºæ˜¯æˆ‘å°±å¸Œæœ›å†™ç»†è‡´ä¸€ç‚¹ï¼Œæ¥è®¿çš„æœ‹å‹èƒ½çœ‹å¾—å®¹æ˜“äº›ã€‚æ­£å¥½ä¹Ÿå°è¯•ä¸€ä¸‹Hexoçš„å…¬å¼ï¼Œä¸ºäº†æ­£å¸¸æ˜¾ç¤ºå®ƒä»¬ä¹Ÿæ˜¯è´¹äº†ä¸€ç•ªå¿ƒæ€hhh\n"},{"title":"2025 idekCTFé¢˜è§£","url":"/2025/08/05/2025%20idekCTF%E9%A2%98%E8%A7%A3/","content":"å‰è¨€æ­¤å‰å››å¤„æœåˆ®é¢˜ç›®åšçš„æ—¶å€™æƒ³æ‰¾Decidophobiaçš„é¢˜è§£ï¼Œæ‰¾åˆ°äº†Mapleå¸ˆå‚…çš„writeupsï¼Œäºæ˜¯å¯¹idekCTFæœ‰äº†ç‚¹å°è±¡ã€‚æ²¡è¿‡å¤šä¹…ï¼Œè‡ªå·±ä¹Ÿæ˜¯å‚ä¸ä¸Šäº†ï¼Œä¸è¿‡ä¹Ÿåšä¸å‡ºå‡ é“é¢˜ï¼Œå‡‘ä¸ªçƒ­é—¹ã€‚\næ­£æ–‡ç¬¬ä¸€å¤©ä¸€é“é¢˜éƒ½ä¸ä¼šï¼Œé¢‡æœ‰äº›ç ´é˜²â€”â€”ç„¶åæ¯ç¡ä¸€è§‰å°±è§£å‡ºä¸€é“ï¼Œåªæ¨æ¯”èµ›åªæœ‰ä¸¤å¤©ã€‚\nCryptoCatché¢˜ç›®å¦‚ä¸‹ã€‚\nfrom Crypto.Random.random import randint, choiceimport os# In a realm where curiosity roams free, our fearless cat sets out on an epic journey.# Even the cleverest feline must respect the boundaries of its worldâ€”this magical limit holds all wonders within.limit = 0xe5db6a6d765b1ba6e727aa7a87a792c49bb9ddeb2bad999f5ea04f047255d5a72e193a7d58aa8ef619b0262de6d25651085842fd9c385fa4f1032c305f44b8a4f92b16c8115d0595cebfccc1c655ca20db597ff1f01e0db70b9073fbaa1ae5e489484c7a45c215ea02db3c77f1865e1e8597cb0b0af3241cd8214bd5b5c1491f# Through cryptic patterns, our cat deciphers its next move.def walking(x, y, part):    # Each step is guided by a fragment of the cat&#x27;s own secret mind.    epart = [int.from_bytes(part[i:i+2], &quot;big&quot;) for i in range(0, len(part), 2)]    xx = epart[0] * x + epart[1] * y    yy = epart[2] * x + epart[3] * y    return xx, yy# Enter the Cat: curious wanderer and keeper of hidden paths.class Cat:    def __init__(self):        # The cat&#x27;s starting position is born of pure randomness.        self.x = randint(0, 2**256)        self.y = randint(0, 2**256)        # Deep within, its mind holds a thousand mysterious fragments.        while True:            self.mind = os.urandom(1000)            self.step = [self.mind[i:i+8] for i in range(0, 1000, 8)]            if len(set(self.step)) == len(self.step):                break    # The epic chase begins: the cat ponders and strides toward the horizon.    def moving(self):        for _ in range(30):            # A moment of reflection: choose a thought from the cat&#x27;s endless mind.            part = choice(self.step)            self.step.remove(part)            # With each heartbeat, the cat takes a cryptic step.            xx, yy = walking(self.x, self.y, part)            self.x, self.y = xx, yy            # When the wild spirit reaches the edge, it respects the boundary and pauses.            if self.x &gt; limit or self.y &gt; limit:                self.x %= limit                self.y %= limit                break    # When the cosmos beckons, the cat reveals its secret coordinates.    def position(self):        return (self.x, self.y)# Adventurer, your quest: find and connect with 20 elusive cats.for round in range(20):    try:        print(f&quot;ğŸ‘‰ Hunt &#123;round+1&#125;/20 begins!&quot;)        cat = Cat()        # At the start, you and the cat share the same starlit square.        human_pos = cat.position()        print(f&quot;ğŸ±âœ¨ Co-location: &#123;human_pos&#125;&quot;)        print(f&quot;ğŸ”® Cat&#x27;s hidden mind: &#123;cat.mind.hex()&#125;&quot;)        # But the cat, ever playful, dashes into the unknown...        cat.moving()        print(&quot;ğŸ˜¸ The chase is on!&quot;)        print(f&quot;ğŸ—ºï¸ Cat now at: &#123;cat.position()&#125;&quot;)        # Your turn: recall the cat&#x27;s secret path fragments to catch up.        mind = bytes.fromhex(input(&quot;ğŸ¤” Path to recall (hex): &quot;))        # Step by step, follow the trail the cat has laid.        for i in range(0, len(mind), 8):            part = mind[i:i+8]            if part not in cat.mind:                print(&quot;âŒ Lost in the labyrinth of thoughts.&quot;)                exit()            human_pos = walking(human_pos[0], human_pos[1], part)        # At last, if destiny aligns...        if human_pos == cat.position():            print(&quot;ğŸ‰ Reunion! You have found your feline friend! ğŸ¾&quot;)        else:            print(&quot;ğŸ˜¿ The path eludes you... Your heart aches.&quot;)            exit()    except Exception:        print(&quot;ğŸ™€ A puzzle too tangled for tonight. Rest well.&quot;)        exit()# Triumph at last: the final cat yields the secret prize.print(f&quot;ğŸ† Victory! The treasure lies within: &#123;open(&#x27;flag.txt&#x27;).read()&#125;&quot;)\né¢˜ç›®å¾ˆæœ‰è¯—æ„hhä½†æ˜¯æœ‰ç‚¹åƒæ²¡å¼€thinkingçš„ChatGPTå†™çš„ï¼Œæäº†åŠå¤©æ˜¯GPTå¯¹æŠ—GPTï¼ˆÃ—ï¼‰é¢˜ç›®ç”Ÿæˆä¸€åªçŒ«ï¼Œç»™å®šå®ƒçš„åˆå§‹åæ ‡å’Œæ‰€æœ‰â€œæ€è€ƒâ€å—ï¼Œç»è¿‡ä¸€äº›ç§»åŠ¨åç»™å‡ºæœ€ç»ˆåæ ‡ï¼Œæˆ‘ä»¬éœ€è¦ä»æœ€ç»ˆåæ ‡ä¸­å¾—åˆ°ç§»åŠ¨æ—¶ä½¿ç”¨çš„æ€è€ƒå—ï¼Œé‡å¤20æ¬¡å°±èƒ½æŠ“åˆ°çŒ«ï¼Œè·å¾—flagã€‚å—åˆ°å¥½å¤šé˜´é—´é¢˜ç›®çš„â€œå¯å‘â€ï¼Œæˆ‘ç¬¬ä¸€æƒ³åˆ°çš„å·²ç»ä¸æ˜¯å¦‚ä½•ç ´è§£è¿™ä¸ªé—®é¢˜ï¼Œè€Œæ˜¯ä»£ç ä¸­æœ‰æ²¡æœ‰æ¼æ´ã€‚è™½ç„¶é¢˜ç›®çš„è¦æ±‚å¾ˆæ¸…æ™°ï¼Œä½†æ˜¯ä»ç¬¬71è¡Œçš„if part not in cat.mind:æˆ‘çœ‹å‡ºäº†ä¸¤ç‚¹â€”â€”1.mindæ²¡æœ‰å˜è¿‡ï¼Œå§‹ç»ˆæ˜¯æœ€åˆçš„1000ä¸ªbyteï¼Œå…¶ä¸­æ¯ä¸ª8byteséƒ½ä¸é‡å¤ï¼Œå› æ­¤ï¼Œè™½ç„¶çŒ«çš„ç§»åŠ¨ä½¿ç”¨çš„stepä¸å…è®¸é‡å¤ï¼Œä½†æ˜¯ç”¨æˆ·ä¸å½±å“ï¼Œç”¨æˆ·çš„è¾“å…¥æ˜¯å¯ä»¥é‡å¤çš„ã€‚2.mindæ˜¯ä¸€è¿ä¸²bytesï¼Œå› æ­¤ï¼Œå³ä½¿è¾“å…¥çš„mindåˆ†å‰²æˆpartåï¼ŒæŸä¸ªpartä¸æ˜¯stepçš„ä¸€å‘˜ï¼Œåªè¦å®ƒæ˜¯mindçš„è¿ç»­8bytesï¼Œå°±å¯ä»¥é€šè¿‡ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å…¶å®æœ‰1000-8+1=993ä¸ªpartå¯ç”¨ï¼Œè€ŒéçŒ«ç§»åŠ¨æ—¶çš„125ä¸ªã€‚è™½ç„¶å…¶å®è¿™ä¸¤ç‚¹éƒ½æ²¡ç”¨åˆ°ï¼Œä½†æ˜¯æˆ‘è§‰å¾—æŠ“æ¼æ´ä¹Ÿæ˜¯æˆ‘ä»¬éœ€è¦åšçš„â€¦â€¦è¯´ä¸å®šå“ªæ¬¡å°±æœ‰ç”¨å‘¢ï¼ŒAIä¸å¤ªä¼šåšè¿™ç§â€œè¿è§„â€çš„äº‹ï¼Œåªèƒ½é äººè‡ªå·±æ¥ã€‚é¢˜ç›®è¿˜ç»™å‡ºäº†ä¸€ä¸ªlimitï¼Œå®ƒæ˜¯ä¸€ä¸ª1024ä½çš„å¤§è´¨æ•°ã€‚è€ƒè™‘æ¯ä¸€æ¬¡walkingï¼Œpartæ˜¯8ä¸ªbyteï¼Œåˆ†æˆ4ä¸ª2*8=16bitçš„æ•°ï¼Œè¿™æ ·ï¼Œæ–°çš„xxå’Œyyé•¿åº¦æœ€å¤šæ˜¯åŸæ¥çš„xå’ŒyåŠ 16ä½ï¼Œ30æ¬¡å°±æ˜¯480ä½ã€‚è¿™æ ·çš„è¯ï¼ŒçŒ«æœ€ç»ˆçš„åæ ‡ä¹Ÿåªæœ‰256+480=736ä½ï¼Œè¿˜æ˜¯è¿œå°äºlimitï¼Œè€ŒçŒ«çš„movingè¿‡ç¨‹ä¸€å®šä¼šèµ°æ»¡30è½®ã€‚è¿™ä¸ªå¦‚æ­¤å¤§çš„limitæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿå°†èµ·ç‚¹å’Œç»ˆç‚¹ä½œä¸ºå‘é‡ï¼Œåˆ™epartä¸­çš„å››ä¸ªæ•°å¯ä»¥ç»„æˆä¸€ä¸ª2*2çŸ©é˜µ$\\begin{bmatrix} e_0 &amp; e_1 \\ e_2 &amp; e_3 \\end{bmatrix}$ã€‚å¯¹äº1000ä¸ªéšæœºbyteï¼Œåˆ’åˆ†ä¸º2byteä¸€ç»„ï¼Œä¸€å…±500ç»„ã€‚å…¶ä¸­å‡ºç°æ•°å­—0çš„æœŸæœ›ä¸º$\\frac{500}{2^{16}}$ï¼Œå› æ­¤epartçŸ©é˜µä¸­å‡ºç°0æ˜¯ä¸å¤ªå¯èƒ½çš„ï¼Œå‡ºç°è¿ç»­ä¸¤ä¸ª0ä½¿å¾—xxæˆ–yy = 0 * x + 0 * y = 0å°±æ›´ä¸å¯èƒ½äº†ï¼Œåœ¨20æ¬¡æŒ‘æˆ˜ä¸­å‡ ä¹å¯ä»¥æ’é™¤ï¼Œå› æ­¤æˆ‘ä»¬è®¤ä¸ºæ¯ä¸€æ¬¡walkingåï¼Œxxå¤§äºxï¼Œyyå¤§äºyã€‚æ­£ç€æ‰¾è¿‡å»ï¼Œä¸ç®¡é€‰å“ªä¸ªçŸ©é˜µéƒ½æ»¡è¶³$\\begin{bmatrix} x_i &amp; y_i \\end{bmatrix}\\begin{bmatrix} e_0 &amp; e_1 \\ e_2 &amp; e_3 \\end{bmatrix} = \\begin{bmatrix} x_{i+1} &amp; y_{i+1} \\end{bmatrix}$ä¸­çš„$x_{i+1} &gt; x_i,\\; y_{i+1} &gt; y_i$ã€‚å¯¹äºç­›é€‰éœ€è¦çš„çŸ©é˜µæ²¡æœ‰å¸®åŠ©ï¼Œé€†ç€æ‰¾è¿‡æ¥ï¼Œ$\\begin{bmatrix} e_0 &amp; e_1 \\ e_2 &amp; e_3 \\end{bmatrix}$çš„é€†çŸ©é˜µå¤šåŠå«æœ‰åˆ†æ•°ï¼Œå­˜å‚¨è¿˜æ˜¯è®¡ç®—éƒ½ä¸æ–¹ä¾¿ï¼Œæ— è®ºå“ªä¸ªæ–¹å‘éƒ½ä¸è¡Œã€‚â€¦â€¦çœŸçš„å—ï¼Ÿæˆ‘ä»¬å¯ä»¥åœ¨$\\mathbb{F}_p$ä¸­æ‰¾é€†çŸ©é˜µã€‚å¯¹äºéšæœºé€‰å–çš„$[0,\\,2^{16}]$ä¸­çš„æ•°ï¼Œç¬¬ä¸€è¡Œå…¨0æ¦‚ç‡çº¦ä¸º$\\frac{1}{2^{32}}$ï¼Œç¬¬äºŒè¡Œä¸ç¬¬ä¸€è¡Œæˆæ¯”ä¾‹åœ¨$\\mathbb{F}_p \\times \\mathbb{F}_p$ä¸­å…±æœ‰ $p$ ç§å¯èƒ½ï¼Œè€Œåœ¨$[0,2^{16}) \\times [0,2^{16})$çš„æ¦‚ç‡ä¸º$\\frac{2^{32}}{p^2} * p = \\frac{2^{32}}{p}$ï¼Œç”±äºè¿™é‡Œçš„$p = \\text{limit}$çº¦æœ‰1024bitï¼Œä¸¤ç§æƒ…å†µçš„æ¦‚ç‡å‡è¿œå°äº1ï¼Œåœ¨20æ¬¡å†…å¯è®¤ä¸ºéƒ½ä¸ä¼šå‘ç”Ÿï¼Œå³æ‰€æœ‰çŸ©é˜µéƒ½å¯é€†ã€‚ç”±äº $p$ æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„è´¨æ•°ï¼Œå¯¹äºå°äº $p$ çš„ä»»ä½•æ­£æ•´æ•° $a$ ï¼Œéƒ½æœ‰$\\text{gcd}(a,p) = 1$ï¼Œå› æ­¤ä¸€å®šæœ‰é€†å…ƒ $a^{-1}$ å­˜åœ¨ã€‚ä¸”å› ä¸ºè¿™é‡ŒçŸ©é˜µçš„æ¯ä¸ªæ•°éƒ½æ˜¯1~65535ï¼ˆ0ä¸è€ƒè™‘ï¼‰ï¼Œæ‰€ä»¥é™¤äº†1ä»¥å¤–ï¼Œå…¶ä»–æ•°çš„é€†å…ƒå¯ä»¥è¡¨ç¤ºä¸º$\\frac{kp+1}{a}$ï¼Œå®ƒå¤§äº1024-16=1008ä½ï¼Œ1çš„é€†å…ƒå½“ç„¶æ˜¯1ã€‚åœ¨åŒæ ·ä¸è€ƒè™‘1å‡ºç°åœ¨epartä¸­åï¼ŒåŸå§‹çŸ©é˜µçš„é€†çŸ©é˜µä¸­æ¯ä¸ªæ•°éƒ½å¾ˆå¤§ã€‚è¿™æ ·ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ $x_{30}&gt;x_{29}ï¼Œy_{30}&gt;y_{29}$ ï¼Œæˆ‘ä»¬åªéœ€æ‰¾å‡ºåˆé€‚çš„çŸ©é˜µï¼Œæ¨¡ä¹˜é€†çŸ©é˜µåå¾—åˆ°çš„$(x_{29},y_{29})$æ»¡è¶³ä¸Šå¼å³å¯ã€‚ç”±äºæœ€åˆcaté€‰æ‹©çš„ç¬¬30ä¸ªçŸ©é˜µä¸€å®šæ»¡è¶³ï¼Œæ‰€ä»¥è‡³å°‘æœ‰ä¸€ä¸ªè§£ã€‚æœ€åæˆ‘ä»¬åˆ†æå‡ºç°å¤šä¸ªè§£çš„æ¦‚ç‡ã€‚ç”±ä¸Šå¯çŸ¥ï¼Œé€†çŸ©é˜µä¸­æ¯ä¸ªå…ƒç´ éƒ½å¾ˆå¤§ï¼Œå› æ­¤å®ƒä»¬ä¹‹é—´é—´éš”ä¹Ÿå¾ˆå¤§ï¼Œå¯ä»¥çœ‹ä½œæ˜¯éšæœºé€‰æ‹©çš„çŸ©é˜µã€‚ç”±äºæœ€ç»ˆç»“æœçº¦736ä½ï¼Œæ•…æœŸæœ›çš„å€’æ•°ç¬¬äºŒæ­¥ç»“æœå°äº736ä½ã€‚ç»™å®šæœ€ç»ˆçš„ $(x_{30},y_{30})$ï¼Œ$(x_{29},y_{29})$ æ»¡è¶³æ¡ä»¶çš„æ¦‚ç‡ä¸º$(\\frac{2^{736}}{2^{1024}})^2$ï¼Œå› æ­¤ï¼Œé™¤äº†å†…å®šçš„ä¸€ä¸ªè§£ï¼Œåœ¨125ä¸ªçŸ©é˜µä¸­å‡ºç°å…¶ä»–è§£çš„æ¦‚ç‡åŒæ ·æå°ã€‚è¿™æ ·ï¼Œåªè¦éå†125ä¸ªçŸ©é˜µçš„é€†çŸ©é˜µï¼Œæ¯æ¬¡éƒ½å¯»æ‰¾ä¸€ä¸ªï¼Œä½¿å¾—å€’æ¨çš„å‘é‡ä¸­ï¼Œæ¯ä¸€ä¸ªåˆ†é‡éƒ½å°äºå‰ä¸€æ­¥å‘é‡çš„åˆ†é‡ï¼Œæ‰¾åˆ°30æ¬¡å›åˆ°åŸç‚¹ï¼Œå°±å¾—åˆ°äº†partçš„é€†åºï¼Œå€’åºå‘é€å³å¯ã€‚\nfrom ast import literal_evalfrom typing import List, Tuplefrom Crypto.Util.number import getPrimedef find_candidate_prev_points(        mind: bytes,        endpoint: Tuple[int, int],        limit: int) -&gt; List[Tuple[int, int, int]]:    &quot;&quot;&quot;    For each 8-byte part in &#x27;mind&#x27;, treat it as a 2x2 matrix over F_p (p=limit),    compute its inverse, apply it to &#x27;endpoint&#x27;, and collect those previous points    whose coordinates are both strictly less than the corresponding coordinates of endpoint.    Returns a list of tuples: (index, prev_x, prev_y).    &quot;&quot;&quot;    x_n, y_n = endpoint    candidates = []    for i in range(125):        part = mind[i * 8:(i + 1) * 8]        e0 = int.from_bytes(part[0:2], &quot;big&quot;) % limit        e1 = int.from_bytes(part[2:4], &quot;big&quot;) % limit        e2 = int.from_bytes(part[4:6], &quot;big&quot;) % limit        e3 = int.from_bytes(part[6:8], &quot;big&quot;) % limit        det = (e0 * e3 - e1 * e2) % limit        if det == 0:            continue        det_inv = pow(det, -1, limit)        inv_a = (e3 * det_inv) % limit        inv_b = (-e1 * det_inv) % limit        inv_c = (-e2 * det_inv) % limit        inv_d = (e0 * det_inv) % limit        prev_x = (inv_a * x_n + inv_b * y_n) % limit        prev_y = (inv_c * x_n + inv_d * y_n) % limit        if prev_x &lt; x_n and prev_y &lt; y_n:            candidates.append((i, prev_x, prev_y))    return candidatesdef recover_mind_sequence(        mind: bytes,        start: Tuple[int, int],        end: Tuple[int, int],        limit: int,        steps: int = 30) -&gt; List[bytes]:    &quot;&quot;&quot;    Reverse-engineer the sequence of &#x27;parts&#x27; used by the cat to move from &#x27;start&#x27; to &#x27;end&#x27;.    Returns the list of 8-byte parts in forward order.    &quot;&quot;&quot;    current = end    seq_indices = []    seq_coords = []    for step in range(steps):        candidates = find_candidate_prev_points(mind, current, limit)        if len(candidates) != 1:            raise ValueError(f&quot;Step &#123;step + 1&#125;: expected 1 candidate, found &#123;len(candidates)&#125;&quot;)        idx, prev_x, prev_y = candidates[0]        seq_indices.append(idx)        seq_coords.append((prev_x, prev_y))        current = (prev_x, prev_y)    # Verify we reached the start coordinate    if current != start:        raise ValueError(f&quot;After reverse (&#123;steps&#125; steps), reached &#123;current&#125;, expected start &#123;start&#125;&quot;)    # Reverse indices to forward order and extract parts    seq_indices.reverse()    recovered_parts = [mind[i * 8:(i + 1) * 8] for i in seq_indices]    return recovered_partsdef simulate_walking_sequence(        start: Tuple[int, int],        parts: List[bytes]) -&gt; Tuple[int, int]:    &quot;&quot;&quot;    Simulate the cat&#x27;s walking forward using the recovered parts to verify correctness.    &quot;&quot;&quot;    x, y = start    for part in parts:        # parse matrix        e0 = int.from_bytes(part[0:2], &quot;big&quot;)        e1 = int.from_bytes(part[2:4], &quot;big&quot;)        e2 = int.from_bytes(part[4:6], &quot;big&quot;)        e3 = int.from_bytes(part[6:8], &quot;big&quot;)        xx = e0 * x + e1 * y        yy = e2 * x + e3 * y        x, y = xx, yy    return (x, y)if __name__ == &quot;__main__&quot;:    import os    from pwn import *    conn = remote(&#x27;catch.chal.idek.team&#x27;, 1337)    for iter in range(20):        conn.recvuntil(b&#x27;Co-location: &#x27;)        x0, y0 = literal_eval(conn.recvline().decode())        #print(x0, y0)        conn.recvuntil(b&#x27;Cat\\&#x27;s hidden mind: &#x27;)        mind_hex = conn.recvline().decode()        mind = bytes.fromhex(mind_hex)        conn.recvuntil(b&#x27;Cat now at: &#x27;)        xn, yn = literal_eval(conn.recvline().decode())        limit = 0xe5db6a6d765b1ba6e727aa7a87a792c49bb9ddeb2bad999f5ea04f047255d5a72e193a7d58aa8ef619b0262de6d25651085842fd9c385fa4f1032c305f44b8a4f92b16c8115d0595cebfccc1c655ca20db597ff1f01e0db70b9073fbaa1ae5e489484c7a45c215ea02db3c77f1865e1e8597cb0b0af3241cd8214bd5b5c1491f        conn.recvuntil(b&#x27;Path to recall (hex):&#x27;)        parts = recover_mind_sequence(mind, (x0, y0), (xn, yn), limit)        print(&quot;Recovered sequence of indices and parts:&quot;)        sendpart = &#x27;&#x27;.join(part.hex() for part in parts)        print(sendpart)        # Verify forward simulation        simulated_end = simulate_walking_sequence((x0, y0), parts)        #print(&quot;Simulated end:&quot;, simulated_end)        #print(&quot;Original end: &quot;, (xn, yn))        if simulated_end == (xn, yn):            print(&quot;Verification passed!&quot;)        else:            print(&quot;Verification failed.&quot;)        conn.sendline(sendpart.encode())    conn.interactive()#idek&#123;Catch_and_cat_sound_really_similar_haha&#125;#By the way, è¿™ä¸ªlimitæ¢æˆå…¶ä»–çš„å¤§è´¨æ•°ä¹Ÿå¯ä»¥è¿‡å…³ï¼Œåªè¦æ¯”x_30å’Œy_30å¤§å°±å¯ä»¥äº†ã€‚\ndiamond ticketé¢˜ç›®å¦‚ä¸‹ã€‚\nfrom Crypto.Util.number import *#Some magic from Willy Wonkap = 170829625398370252501980763763988409583a = 164164878498114882034745803752027154293b = 125172356708896457197207880391835698381def chocolate_generator(m:int) -&gt; int:    return (pow(a, m, p) + pow(b, m, p)) % p#The diamond ticket is hiding inside chocolatediamond_ticket = open(&quot;flag.txt&quot;, &quot;rb&quot;).read()assert len(diamond_ticket) == 26assert diamond_ticket[:5] == b&quot;idek&#123;&quot;assert diamond_ticket[-1:] == b&quot;&#125;&quot;diamond_ticket = bytes_to_long(diamond_ticket[5:-1])flag_chocolate = chocolate_generator(diamond_ticket)chocolate_bag = []#Willy Wonka are making chocolatesfor i in range(1337):    chocolate_bag.append(getRandomRange(1, p))#And he put the golden ticket at the endchocolate_bag.append(flag_chocolate)#Augustus ate lots of chocolates, but he can&#x27;t eat all cuz he is full now :Dremain = chocolate_bag[-5:]#Compress all remain chocolates into oneremain_bytes = b&quot;&quot;.join([c.to_bytes(p.bit_length()//8, &quot;big&quot;) for c in remain])#The last chocolate is too important, so Willy Wonka did magic againP = getPrime(512)Q = getPrime(512)N = P * Qe = bytes_to_long(b&quot;idek&#123;this_is_a_fake_flag_lolol&#125;&quot;)d = pow(e, -1, (P - 1) * (Q - 1))c1 = pow(bytes_to_long(remain_bytes), e, N)c2 = pow(bytes_to_long(remain_bytes), 2, N) # A small gift#How can you get it ?print(f&quot;&#123;N = &#125;&quot;)print(f&quot;&#123;c1 = &#125;&quot;)print(f&quot;&#123;c2 = &#125;&quot;) &quot;&quot;&quot;N = 85494791395295332945307239533692379607357839212287019473638934253301452108522067416218735796494842928689545564411909493378925446256067741352255455231566967041733698260315140928382934156213563527493360928094724419798812564716724034316384416100417243844799045176599197680353109658153148874265234750977838548867c1 = 27062074196834458670191422120857456217979308440332928563784961101978948466368298802765973020349433121726736536899260504828388992133435359919764627760887966221328744451867771955587357887373143789000307996739905387064272569624412963289163997701702446706106089751532607059085577031825157942847678226256408018301c2 = 30493926769307279620402715377825804330944677680927170388776891152831425786788516825687413453427866619728035923364764078434617853754697076732657422609080720944160407383110441379382589644898380399280520469116924641442283645426172683945640914810778133226061767682464112690072473051344933447823488551784450844649&quot;&quot;&quot;\nä¸€é“å……æ»¡ç€â€œç‰¹åˆ«â€çš„é¢˜ç›®ï¼Œæ¯ä¸€ä¸ªæ•°æ®éƒ½æ˜¯ç²¾å¿ƒç»™å‡ºçš„ã€‚æ‹¿åˆ°é¢˜ç›®ï¼Œå…ˆè¯»ä¸€ä¸‹å·§å…‹åŠ›å·¥å‚çš„æ•…äº‹ï¼Œflagå¼€å¤´å’Œç»“å°¾å…±6 byteså·²ç»™å‡ºï¼Œä¸­é—´20 bytesæœªçŸ¥ã€‚åˆ—è¡¨chocolate_bagåŠ å…¥äº†1337ä¸ª1~pçš„éšæœºæ•°ï¼ŒåˆåŠ å…¥äº† $(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p$ çš„å€¼â€”â€”çœ‹èµ·æ¥åˆæ˜¯ä¸€ä¸ªç¦»æ•£å¯¹æ•°ï¼Œè€Œä¸”ä¸æ˜¯æ™®é€šçš„ç¦»æ•£å¯¹æ•°ã€‚ç”Ÿæˆç»“æŸåï¼Œremainä»…åŒ…å«æœ€å5ä¸ªæ•°ï¼Œæ‰€å¹¸åŒ…å«flagä¿¡æ¯çš„é¡¹æ˜¯æœ€åä¸€é¡¹ï¼Œå®ƒä¿ç•™äº†ä¸‹æ¥ã€‚å°†è¿™5é¡¹è½¬åŒ–ä¸º16*5=80 bytesçš„å­—èŠ‚ä¸²å¹¶æ‹¼æ¥ï¼Œæœ€åæ˜¯ä¸€ä¸ªRSAåŠ å¯†ã€‚å› æ­¤ï¼Œå¦‚æœæ²¡æœ‰æ„å¤–ï¼Œæˆ‘ä»¬çš„å¤§è‡´é€»è¾‘åº”è¯¥æ˜¯ è§£å¯†RSA -&gt; æå–flag_chocolate -&gt; è¿˜åŸdiamond_ticket ã€‚è¿™æ ·åšä¹Ÿç¡®å®èƒ½å¤Ÿå¾—åˆ°ç­”æ¡ˆã€‚\nç¬¬1æ­¥ï¼šè§£å¯†RSAå·²çŸ¥$m^e\\ \\text{mod}\\ N$å’Œ$m^2\\ \\text{mod}\\ N$ï¼Œä¸” $m$ æ˜¯ä¸€ä¸ª80*8=640bitçš„æ•°ï¼Œ $m^2$ ä¹Ÿæœ‰1280ä½ï¼Œçˆ†ç ´é«˜256ä½ä¸ç°å®ã€‚ç”±äºeæ˜¯ä¸€ä¸ª247ä½çš„å¥‡æ•°ï¼Œgcd(e,2) = 1ï¼Œæˆ‘ä»¬ç”¨ $m^2$ å’Œ $m^e$ å‡‘å‡º $m^1$ ã€‚å¯ä»¥æ„é€  $m^1 = m^{1e-\\frac{e-1}{2}2} = m^e * (m^2)^{-\\frac{e-1}{2}}$ ï¼Œæ¨¡ $N$ ä¸‹è¿ç®—å¾—åˆ° $m$ ã€‚\nç¬¬2æ­¥ï¼šæå–flag_chocolateæˆ‘ä»¬åªè¦æœ€åä¸€é¡¹ï¼Œæ•…æå–æœ€å16ä¸ªbyteï¼Œå’±å›¾çœäº‹å°±å…¨éƒ¨ä¸€èµ·æå–äº†ï¼Œå¹¶è¾“å‡ºchunksçš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚\nç¬¬3æ­¥ï¼šè¿˜åŸdiamond_ticketæ­¤æ—¶æˆ‘ä»¬æ‹¥æœ‰ç­‰å¼$(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p = c$ ï¼Œå·²çŸ¥a, b, c, pï¼Œæ±‚flagã€‚åœ¨å’¨è¯¢äº†Deepseekç­‰AIå¹¶é€šè¿‡ä»£ç éªŒè¯åï¼Œæˆ‘ä»¬å‘ç°äº†ç»™å®šçš„a, b, pæœ‰ä¸€äº›æœ‰è¶£çš„æ€§è´¨â€”â€”$p$ æ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œä½† $p-1 = 2 Ã— 40841 Ã— 50119 Ã— 51193 Ã— 55823 Ã— 57809 Ã— 61991 Ã— 63097 Ã— 64577$ ï¼Œæ˜¯å¾ˆå¤šå°ç´ æ•°ä¹‹ç§¯ï¼ˆ $p-1$ æ˜¯å…‰æ»‘æ•°ï¼‰ã€‚$a$ å’Œ $b$ çš„é˜¶å‡ä¸º $\\frac{p-1}{2}$ ï¼Œä¸” $b = a^{73331}\\ \\text{mod}\\ p$å› æ­¤ï¼Œå¯¹äºé—®é¢˜$(a^\\text{flag}+b^\\text{flag})\\text{mod}\\ p = c$ï¼Œå°†å…¶è½¬åŒ–ä¸º$((a^\\text{flag}+(a^\\text{flag})^{73331}) - c )\\ \\text{mod}\\ p = 0$ï¼Œå³å¯»æ‰¾$f(x) = x^{73331}+x-c$ çš„ä¸€ä¸ªæ ¹$x_0$ã€‚ä¸€æ—¦æ‰¾åˆ°è¿™ä¸ªæ ¹ï¼Œå®ƒå°±æ˜¯ $a^\\text{flag}$ ï¼Œè½¬åŒ–ä¸ºæ™®é€šçš„ç¦»æ•£å¯¹æ•°ï¼Œå†åˆ©ç”¨Pohlig-Hellmanç®—æ³•ï¼Œæ±‚å¾—é˜¶ä¸ºå…‰æ»‘æ•°çš„ç¦»æ•£å¯¹æ•°ã€‚ä½¿ç”¨cypariåº“å¯¹è¯¥å‡½æ•°è¿›è¡Œæ±‚æ ¹ï¼Œç›¸æ¯”sageçš„roots()å‡½æ•°ï¼Œå®ƒå¿«å¾—å¤šï¼Œåªéœ€è¦åå¤šç§’å°±èƒ½å¾—åˆ°ç­”æ¡ˆã€‚å†åˆ©ç”¨sageè‡ªå¸¦çš„discrete_log()å‡½æ•°æ±‚è§£å³å¯å¾—åˆ°flagã€‚\nâ€¦â€¦çœŸçš„å—ï¼Ÿå°†æ±‚å‡ºçš„ x = 4807895356063327854843653048517090061 è½¬æ¢æˆbytesåä¸éƒ½æ˜¯å¯æ‰“å°å­—ç¬¦ï¼Œè¯´æ˜æˆ‘ä»¬è¿˜æœ‰è·¯æ²¡èµ°å®Œï¼Œä½†æ˜¯ assert chocolate_generator(x) == c ä¹Ÿé€šè¿‡äº†ï¼Œè¯´æ˜æˆ‘ä»¬ç¡®å®æ‰¾åˆ°äº†æ­£ç¡®çš„ä¸€ä¸ªxã€‚æ±‚ä¸€ä¸‹xçš„ä½æ•°ï¼Œå®ƒæœ‰122ä½ï¼Œè€Œdiamond_ticketæœ‰20*8=160ä½ã€‚ç”±äº $a$, $b$ çš„é˜¶ç›¸ç­‰ï¼Œæ•…$a^\\frac{p-1}{2}\\ \\text{mod}\\ p = b^\\frac{p-1}{2}\\ \\text{mod}\\ p = 1$ï¼Œå› æ­¤é™¤äº† $x$ ä»¥å¤–ï¼Œæ‰€æœ‰ $x+k\\frac{p-1}{2}$ ä¹Ÿéƒ½æ˜¯å¯èƒ½çš„diamond_ticketï¼Œ$k$ ä¸ºæ­£æ•´æ•°ã€‚å¯¹äºè¯¥å–ä»€ä¹ˆ $k$ æ²¡æœ‰å¥½çš„åŠæ³•ï¼Œä¸€å…±20 bytesï¼ˆ160ä½ï¼‰ï¼Œæœ€é«˜ä½çš„byteæœ€å¤šæ˜¯0x7E(01111110)ï¼Œæ•…diamond_ticketæœ€å¤šæœ‰159ä½ï¼›æœ€å°‘æ˜¯0x20(00100000)ï¼Œdiamond_ticketæœ€å°‘ä¹Ÿæœ‰158ä½ã€‚æ ¹æ® $\\text{diamond_ticket} = x+k\\frac{p-1}{2}$ å¯çŸ¥ $k$ è‡³å°‘ä¸º31ä½ï¼Œæœ€å¤šä¸º32ä½ï¼Œæˆ‘ä»¬éå†k in range(2**31, 2**33)å³å¯ã€‚ç”±äºæ•°æ®è¿‡å¤§ï¼Œé‡‡ç”¨å¤šçº¿ç¨‹å¹¶è¡ŒåŠ é€Ÿï¼Œå®æµ‹æœ¬æœº32çº¿ç¨‹çº¦20åˆ†é’Ÿã€‚ä»¥åŠï¼Œæˆ‘çš„å¤šçº¿ç¨‹å†™å¾—ä¸€å›¢ç³Ÿï¼ŒæŠŠèµ·ç‚¹ä¿®æ”¹ä¸º $2^{31}$ å°±ç»™ä¸å‡ºç»“æœï¼Œæ‰€ä»¥ä»£ç æ˜¯ä» $0$ éå†åˆ° $2^{33}$ ï¼Œå¤šèŠ±äº†çº¦$\\frac{1}{4}$çš„æ—¶é—´ã€‚\n######################################################pythonfrom Crypto.Util.number import *N = 85494791395295332945307239533692379607357839212287019473638934253301452108522067416218735796494842928689545564411909493378925446256067741352255455231566967041733698260315140928382934156213563527493360928094724419798812564716724034316384416100417243844799045176599197680353109658153148874265234750977838548867c1 = 27062074196834458670191422120857456217979308440332928563784961101978948466368298802765973020349433121726736536899260504828388992133435359919764627760887966221328744451867771955587357887373143789000307996739905387064272569624412963289163997701702446706106089751532607059085577031825157942847678226256408018301c2 = 30493926769307279620402715377825804330944677680927170388776891152831425786788516825687413453427866619728035923364764078434617853754697076732657422609080720944160407383110441379382589644898380399280520469116924641442283645426172683945640914810778133226061767682464112690072473051344933447823488551784450844649e = 186211850710224327090212578283834164039515361235211653610924153794366237821# å·²çŸ¥é‡ï¼šN, e, c1, c2# è®¡ç®— temp = (e-1)//2temp = (e - 1) // 2# å…ˆç®— t = c2^temp mod Nt = pow(c2, temp, N)# å†ç®— t çš„æ¨¡åå…ƒç´  inv_t = t^&#123;-1&#125; mod Ninv_t = inverse(t, N)# æœ€å m = c1 * inv_t mod Nm = (c1 * inv_t) % Nassert pow(m,e,N) == c1assert pow(m,2,N) == c2# å°†æ•´æ•° m è½¬æˆå­—èŠ‚ä¸²remain_bytes = long_to_bytes(m)print(remain_bytes)#b&#x27;&#123;\\xd1\\xdf\\xeb|F\\xce\\xbc\\x11\\xd8nZ\\x8b\\xfc\\xaebN\\xf4\\x8a&#123;0,\\x01\\xb7\\xf9\\xe7\\xb5q\\xc93%\\xba\\x0b\\x15\\x94g\\x0b|\\xd8 \\xf38\\xf2\\xe2#\\t\\x0ci^\\x10\\x86\\x94\\x12\\xcb\\xe7b/\\xefj\\xb5\\x05\\xfb\\xc8\\xf9J\\xebU|z\\x10\\xd3|\\xa7\\xec\\xd1\\x9d\\x17\\\\P\\xb3&#x27;#å…¶ä¸­\\\\è¡¨ç¤ºä¸€ä¸ªåæ–œæ ï¼Œç®—ä¸€ä¸ªbyte#Some magic from Willy Wonkap = 170829625398370252501980763763988409583a = 164164878498114882034745803752027154293b = 125172356708896457197207880391835698381L = p.bit_length() // 8   # =128//8 =16chunks = [remain_bytes[i*L:(i+1)*L] for i in range(5)]print(bytes_to_long(chunks[-1]))#99584795316725433978492646071734128819######################################################sagedef chocolate_generator(m:int) -&gt; int:    return (pow(a, m, p) + pow(b, m, p)) % pc = 99584795316725433978492646071734128819import cypari2pari = cypari2.Pari()def roots_mod_p_via_pari(k, c, p):    y = pari(&#x27;y&#x27;)    f = y**k + y - c    return list(map(int, pari(f).polrootsmod(p)))k = 73331roots = roots_mod_p_via_pari(k, c, p)print(&quot;roots:&quot;, roots)#[126961729658296101306560858021273501485]a = 164164878498114882034745803752027154293for y in roots:    # æŠŠ a, y è§†ä¸º GF(p) ä¸­çš„å…ƒç´     F = GF(p)    A = F(a)    Y = F(y)    # è°ƒç”¨ discrete_log    x = discrete_log(Y, A)    assert chocolate_generator(x) == c    print(&quot;è§£å¾— x =&quot;, x)#4807895356063327854843653048517090061######################################################pythondef is_all_printable(bs: bytes) -&gt; bool:    return all(0x20 &lt;= b &lt;= 0x7E for b in bs)import multiprocessing# ä¸Šä¸€éƒ¨åˆ†ç»“æœBASE = 4807895356063327854843653048517090061from tqdm import tqdmimport os# å­ä»»åŠ¡ï¼šåœ¨ç»™å®šåŒºé—´å†…æŸ¥æ‰¾æ»¡è¶³æ¡ä»¶çš„ jdef worker(start: int, end: int, queue):    results = []    for j in range(start, end):        val = BASE + (p-1)//2 * j        text = long_to_bytes(val)        if is_all_printable(text):            results.append((j, text))        if j % 10000 == 0:            queue.put(10000)    return resultsif __name__ == &#x27;__main__&#x27;:    multiprocessing.set_start_method(&#x27;spawn&#x27;)  # For compatibility, especially on Windows    cpu_count = multiprocessing.cpu_count()    total = 2**33    chunk = total // cpu_count    # ä½¿ç”¨ Manager å’Œ Queue è·Ÿè¸ªè¿›åº¦    with multiprocessing.Manager() as manager:        queue = manager.Queue()        pool = multiprocessing.Pool(processes=cpu_count)        # ç”¨ tqdm æ˜¾ç¤ºæ€»è¿›åº¦        with tqdm(total=total, desc=&quot;Brute-forcing&quot;, unit=&quot;j&quot;) as pbar:            results = []            tasks = []            for i in range(cpu_count):                start = i * chunk                end = start + chunk if i &lt; cpu_count - 1 else total                tasks.append(pool.apply_async(worker, (start, end, queue)))            # å®æ—¶æ›´æ–°è¿›åº¦æ¡            finished = 0            while finished &lt; total:                inc = queue.get()                pbar.update(inc)                finished += inc            # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆå¹¶æ”¶é›†ç»“æœ            pool.close()            pool.join()            for task in tasks:                for j, text in task.get():                    print(f&quot;Found j=&#123;j&#125;: &#123;text&#125;&quot;)                    #Found j=7781310273: b&#x27;tks_f0r_ur_t1ck3t_xD&#x27;#idek&#123;tks_f0r_ur_t1ck3t_xD&#125;\nREconstructioné™„ä»¶æ˜¯ä¸€ä¸ªelfç¨‹åºï¼Œè¯•éªŒå¾—çŸ¥ï¼Œå½“æ²¡æœ‰å‚æ•°æ—¶ï¼Œè¾“å‡ºğŸ‘€ï¼Œæœ‰å‚æ•°æ—¶ï¼Œè¾“å‡ºWrong! ï¼Œæœç´¢å­—ç¬¦ä¸²å‘ç°ï¼š\n.rodata:0000000000403013 aCorrect        db &#x27;Correct!&#x27;,0         ; DATA XREF: sub_401050:loc_401159â†‘o.rodata:000000000040301C aWrong          db &#x27;Wrong!&#x27;,0           ; DATA XREF: sub_401050+CEâ†‘o\næ¨æµ‹ä¸»å‡½æ•°æ˜¯sub_401050ï¼Œæ‰¾åˆ°è¯¥å‡½æ•°ï¼š\nunsigned __int64 __fastcall sub_401050(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)&#123;  __int64 v6; // rcx  unsigned __int64 i; // rax  int v8; // edx  __int64 v9; // rdx  int v10; // eax  unsigned int v11; // ebp  signed __int64 v12; // r12  unsigned __int8 *v13; // rax  unsigned __int64 result; // rax  char v15[24]; // [rsp+0h] [rbp-1038h] BYREF  unsigned __int64 v16; // [rsp+1008h] [rbp-30h]  LODWORD(v6) = 0;  v16 = __readfsqword(0x28u);  for ( i = 0; i != 42; ++i )  &#123;    v8 = v6 ^ (unsigned __int8)::a3[i];    v6 += 31;    v9 = (i &gt;&gt; 1) ^ v8 ^ 0x5A;    byte_405140[i] = v9;  &#125;  byte_40516A = 0;  v10 = sub_401670((__int64)&quot;/proc/self/cmdline&quot;, 0, v9, v6, a5, a6, v15[0]);  v11 = v10;  if ( v10 &gt;= 0 )  &#123;    v12 = sub_401A10((unsigned int)v10, v15, 4095);    sub_4019C0(v11);    if ( v12 &gt; 0 )    &#123;      v15[v12] = 0;      v13 = sub_401830(v15, 0, v12);      if ( v13 )      &#123;        if ( v13 + 1 &lt; (unsigned __int8 *)&amp;v15[v12] )        &#123;          if ( (unsigned int)sub_401910(v13 + 1, byte_405140) )            sub_401770(&quot;Wrong!&quot;);          else            sub_401770(&quot;Correct!&quot;);          sub_401010(0);        &#125;      &#125;    &#125;  &#125;  result = v16 - __readfsqword(0x28u);  if ( result )    sub_401610();  return result;&#125;\nå› æ­¤ï¼Œæ­£ç¡®ç­”æ¡ˆçš„ç”Ÿæˆè¿‡ç¨‹æ˜¯\nLODWORD(v6) = 0;for ( i = 0; i != 42; ++i )&#123;  v8 = v6 ^ (unsigned __int8)::a3[i];  v6 += 31;  v9 = (i &gt;&gt; 1) ^ v8 ^ 0x5A;  byte_405140[i] = v9;&#125;\nåˆ†æå®ƒå¤ªéº»çƒ¦äº†ï¼Œç›´æ¥åŠ¨æ€è°ƒè¯•åˆ°è¿™ä¸ªä½ç½®ï¼Œæå–byte_405140å¦‚ä¸‹ã€‚\n.bss:0000000000405140 ; _BYTE byte_405140[42].bss:0000000000405140 byte_405140 db 69h, 64h, 65h, 6Bh, 7Bh, 68h, 65h, 34h, 72h, 64h, 5Fh, 30h, 66h, 5Fh.bss:0000000000405140                                         ; DATA XREF: sub_401050+1Câ†‘o.bss:000000000040514E db 63h, 6Fh, 6Eh, 73h, 74h, 72h, 75h, 63h, 74h, 6Fh, 72h, 73h, 3Fh, 5Fh.bss:000000000040515C db 6Eh, 6Fh, 77h, 5Fh, 79h, 6Fh, 75h, 5Fh, 64h, 31h, 64h, 21h, 21h, 7Dh.bss:000000000040516A byte_40516A db 0                        ; DATA XREF: sub_401050+6Câ†‘w\nç»­ä¸Šåé¢çš„byte_40516A = 0;ï¼Œç›´æ¥å¯ä»¥åœ¨IDAä¸­æ•´åˆæˆå­—ç¬¦ä¸²ï¼š\n.bss:0000000000405140 aIdekHe4rd0fCon db &#x27;idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;&#x27;,0.bss:0000000000405140                                         ; DATA XREF: sub_401050+1Câ†‘o\näºæ˜¯æˆ‘ä»¬å·²ç»æ‰¾åˆ°äº†â€”â€”idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;\nä½†æ˜¯è¿™å¤ªå¿«äº†ï¼Œäºæ˜¯æ°´ä¸€ä¸‹wpï¼ˆÃ—ï¼‰\nå¯¹è¾“å…¥çš„åˆ¤å®šè¿‡ç¨‹æ˜¯\nif ( (unsigned int)sub_401910(v13 + 1, byte_405140) )  sub_401770(&quot;Wrong!&quot;);else  sub_401770(&quot;Correct!&quot;);\nä¸­é—´å°±æ˜¯æˆªå–è¾“å…¥çš„è¿‡ç¨‹\nv10 = sub_401670((__int64)&quot;/proc/self/cmdline&quot;, 0, v9, v6, a5, a6, v15[0]);v11 = v10;if ( v10 &gt;= 0 )&#123;  v12 = sub_401A10((unsigned int)v10, v15, 4095);  sub_4019C0(v11);  if ( v12 &gt; 0 )  &#123;    v15[v12] = 0;    v13 = sub_401830(v15, 0, v12);    ...\nåˆ¤å®šè¾“å…¥çš„å‡½æ•° sub_401910 æ˜¯\n__int64 __fastcall sub_401910(unsigned __int8 *a1, unsigned __int8 *a2)&#123;  unsigned __int8 v2; // dl  int v3; // ecx  __int64 v4; // rax  v2 = *a1;  v3 = *a2;  v4 = 1;  if ( *a1 != (_BYTE)v3 )    return (unsigned int)v2 - v3;  while ( v2 )  &#123;    v2 = a1[v4++];    v3 = a2[v4 - 1];    if ( v2 != (_BYTE)v3 )      return (unsigned int)v2 - v3;  &#125;  return (unsigned int)-v3;&#125;\nå…¶è¦æ±‚ *a1 å’Œ *a2 æ¯ä¸€ä½éƒ½è¦ç›¸ç­‰ï¼Œå¦‚æœæœ‰ä¸ç­‰çš„ä½ï¼Œåˆ™è¿”å›ä»–ä»¬çš„å·®å€¼ï¼›å¦‚æœv3æ›´é•¿ï¼Œåˆ™è¿”å›v2ç»“æŸåçš„ç¬¬ä¸€ä¸ªv3çš„ä½ã€‚ç”±äºæˆ‘ä»¬å·²çŸ¥ä½œä¸ºå­—ç¬¦ä¸²æœ«å°¾çš„byte_40516Aæ˜¯0ï¼Œå› æ­¤å”¯ä¸€èƒ½è®©è¿™ä¸ªåˆ¤å®šè¿”å›0çš„æ–¹æ³•æ˜¯ï¼Œè¾“å…¥çš„é•¿åº¦ä¸v13ç›¸ç­‰ï¼Œä¸”æ¯ä¸€ä½éƒ½ä¸€æ ·ï¼Œè¿™æ ·è¿”å›çš„å°±æ˜¯å­—ç¬¦ä¸²æœ«å°¾çš„0ã€‚\nå› æ­¤ï¼Œæ ¹æ®å‰é¢çš„æå–æ•°æ®è¿‡ç¨‹ï¼Œæœ€ååº”è¯¥è¾“å…¥idek&#123;he4rd_0f_constructors?_now_you_d1d!!&#125;ï¼Œè¿™å°±æ˜¯flagã€‚\nMiscGacha gateé¢˜ç›®å¦‚ä¸‹ã€‚\n#!/usr/bin/env python3import contextlibimport osimport randomimport reimport signalimport sysfrom z3 import ArithRef, BitVec, BitVecRef, BitVecVal, Solver, simplify, unsatWIDTH = 32OPS = [&#x27;~&#x27;, &#x27;&amp;&#x27;, &#x27;^&#x27;, &#x27;|&#x27;]MAX_DEPTH = 10FLAG = os.getenv(&#x27;FLAG&#x27;, &#x27;idek&#123;fake_flag&#125;&#x27;)VARS = set(&#x27;iIl&#x27;)def rnd_const() -&gt; tuple[str, BitVecRef]:    v = random.getrandbits(WIDTH)    return str(v), BitVecVal(v, WIDTH)def rnd_var() -&gt; tuple[str, BitVecRef]:    name = &#x27;&#x27;.join(random.choices(tuple(VARS), k=10))    return name, BitVec(name, WIDTH)def combine(    op: str,    left: tuple[str, BitVecRef],    right: tuple[str, BitVecRef] | None = None,) -&gt; tuple[str, ArithRef]:    if op == &#x27;~&#x27;:        s_left, z_left = left        return f&#x27;(~&#123;s_left&#125;)&#x27;, ~z_left    s_l, z_l = left    s_r, z_r = right    return f&#x27;(&#123;s_l&#125; &#123;op&#125; &#123;s_r&#125;)&#x27;, &#123;        &#x27;&amp;&#x27;: z_l &amp; z_r,        &#x27;^&#x27;: z_l ^ z_r,        &#x27;|&#x27;: z_l | z_r,    &#125;[op]def random_expr(depth: int = 0) -&gt; tuple[str, ArithRef]:    if depth &gt;= MAX_DEPTH or random.random() &lt; 0.1:        return random.choice((rnd_var, rnd_const))()    op = random.choice(OPS)    if op == &#x27;~&#x27;:        return combine(op, random_expr(depth + 1))    return combine(op, random_expr(depth + 1), random_expr(depth + 1))TOKEN_RE = re.compile(r&#x27;[0-9]+|[iIl]+|[~&amp;^|]&#x27;)def parse_rpn(s: str) -&gt; ArithRef:    tokens = TOKEN_RE.findall(s)    if not tokens:        raise ValueError(&#x27;empty input&#x27;)    var_cache: dict[str, BitVecRef] = &#123;&#125;    stack: list[BitVecRef] = []    for t in tokens:        if t.isdigit():            stack.append(BitVecVal(int(t), WIDTH))        elif re.fullmatch(r&#x27;[iIl]+&#x27;, t):            if t not in var_cache:                var_cache[t] = BitVec(t, WIDTH)            stack.append(var_cache[t])        elif t in OPS:            if t == &#x27;~&#x27;:                if len(stack) &lt; 1:                    raise ValueError(&#x27;stack underflow&#x27;)                a = stack.pop()                stack.append(~a)            else:                if len(stack) &lt; 2:                    raise ValueError(&#x27;stack underflow&#x27;)                b = stack.pop()                a = stack.pop()                stack.append(&#123;&#x27;&amp;&#x27;: a &amp; b, &#x27;^&#x27;: a ^ b, &#x27;|&#x27;: a | b&#125;[t])        else:            raise ValueError(f&#x27;bad token &#123;t&#125;&#x27;)    if len(stack) != 1:        raise ValueError(&#x27;malformed expression&#x27;)    return stack[0]def equivalent(e1: ArithRef, e2: ArithRef) -&gt; tuple[bool, Solver]:    s = Solver()    s.set(timeout=5000)    s.add(simplify(e1) != simplify(e2))    return s.check() == unsat, sdef _timeout_handler(_: int, __) -&gt; None:    raise TimeoutErrordef main() -&gt; None:    signal.signal(signal.SIGALRM, _timeout_handler)    print(&#x27;lets play a game!&#x27;)    for _ in range(50):        random.seed()        expr_str, expr_z3 = random_expr()        print(expr_str, flush=True)        signal.alarm(5)        try:            line = sys.stdin.readline()            signal.alarm(0)        except TimeoutError:            print(&#x27;too slow!&#x27;)            return        try:            rpn_z3 = parse_rpn(line.strip())        except Exception as e:            print(&#x27;invalid input:&#x27;, e)            return        print(&#x27;let me see..&#x27;)        is_eq, s = equivalent(expr_z3, rpn_z3)        if not is_eq:            print(&#x27;wrong!&#x27;)            with contextlib.suppress(BaseException):                print(&#x27;counter example:&#x27;, s.model())            return    print(FLAG)if __name__ == &#x27;__main__&#x27;:    main()\nå’±å€’æ˜¯æ²¡æƒ³åˆ°ä¸€ä¸ªmiscé¢˜å±…ç„¶è¿™ä¹ˆå¥½å¿ƒï¼Œå®Œæˆäº†ä»»åŠ¡å°±çœŸçš„ç»™ä½ flagã€‚\nè¿™é¢˜ç›®åƒæ˜¯ç»™å¤§å­¦ç”Ÿå‡†å¤‡çš„ï¼ˆç¬‘ï¼‰é¢˜ç›®ç»™å‡ºä¸€ä¸ªä¸­ç¼€è¡¨è¾¾å¼ï¼Œè¦æ±‚ç»™å‡ºå®ƒå¯¹åº”çš„åç¼€è¡¨è¾¾å¼ï¼Œå¹¶æ£€éªŒæ˜¯å¦ç­‰æ•ˆï¼Œè§„å®šæ—¶é—´å†…é€šè¿‡50æ¬¡æ£€éªŒå°±èƒ½å¾—åˆ°flagã€‚ä¸­ç¼€è½¬åç¼€ï¼Œåªè¦å­¦è¿‡æ•°æ®ç»“æ„æˆ–è€…ç®—æ³•çš„éƒ½åº”è¯¥èƒ½å†™å‡ºæ¥ï¼Œå†ä¸æµè®©ChatGPTå†™ï¼Œå®ƒå¾ˆæ“…é•¿åšè¿™ç§å¤§å­¦è¯¾åä¹ é¢˜å¯¹äºä¸€ä¸ªè¡¨è¾¾å¼ &#39;((~((~1925064568) ^ (~(~(348138675 &amp; IIiIlIillI))))) &amp; (~(~(((iIllIIIIII &amp; 648807684) | (4074926542 | iIilIIIiiI)) | (iiiiIIliIl ^ (203353170 ^ 3427631998))))))&#39;ï¼Œè½¬æˆåç¼€è¡¨è¾¾å¼(RPN)éœ€è¦å…ˆåˆ’è¯ä¸º&#39;(&#39;, &#39;~&#39;, &#39;1925064568&#39;ç­‰tokenï¼Œå€ŸåŠ©ä¸€ä¸ªæ ˆï¼Œå°†ç¬¦å·æŒ‰ç…§ä¼˜å…ˆçº§ç§»åˆ°æ“ä½œæ•°çš„åé¢ï¼Œç”±äºæœ¬é¢˜ç”Ÿæˆçš„è¡¨è¾¾å¼å‡æœ‰æ‹¬å·åŒ…è£¹ï¼Œå¯ä»¥é¿å…^&amp;|~è¿™å››ç§ç¬¦å·çš„ä¼˜å…ˆçº§é—®é¢˜ã€‚å¯¹äºæ‹¬å·ï¼Œæ¯å½“é‡åˆ°&#39;)&#39;æ—¶ï¼Œå°±ä»æ ˆå†…å¼¹å‡ºç¬¦å·ç›´åˆ°åŒ¹é…&#39;(&#39;ï¼Œè¿™ä¸¤è€…ä¸­é—´çš„è¡¨è¾¾å¼å°±å¯ä»¥ç›´æ¥ç§»åŠ¨ç¬¦å·ã€‚ä¸Šè¿°è¡¨è¾¾å¼è½¬æ¢åä¸º &#39;1925064568 ~ 348138675 IIiIlIillI &amp; ~ ~ ^ ~ iIllIIIIII 648807684 &amp; 4074926542 iIilIIIiiI | | iiiiIIliIl 203353170 3427631998 ^ ^ | ~ ~ &amp;&#39; ã€‚signal.alarm(5)è¡¨ç¤º5ç§’åè¿›å…¥è¶…æ—¶å¤„ç†éƒ¨åˆ†ï¼Œæœ¬é¢˜åªæ˜¯ç®€å•æŠ›å‡ºTimeoutErrorï¼Œç»ç”±mainå‡½æ•°æ•è·åå‘ŠçŸ¥&#39;too slow!&#39;ï¼Œæ‰‹åŠ¨è®¡ç®—å¹¶å¤åˆ¶åˆ°å‘½ä»¤è¡Œä¸æ˜“ä¸”å®¹æ˜“å‡ºé”™ï¼Œäº¤ç”±pwntoolåº“è‡ªåŠ¨äº¤äº’å®Œæˆã€‚ä½¿ç”¨recvline()æ¥æ”¶ä¸€è¡Œï¼Œrecvuntil()æ¥æ”¶ç›´åˆ°æŒ‡å®šçš„å­—èŠ‚ä¸²ï¼Œsendline()å‘é€ä¸€è¡Œå­—èŠ‚ä¸²ã€‚æ³¨æ„æ‰€æœ‰å‘é€å’Œæ¥æ”¶åˆ°çš„éƒ½æ˜¯å­—èŠ‚ï¼Œå¯ä»¥ä½¿ç”¨decode()æ–¹æ³•å˜ä¸ºå­—ç¬¦ä¸²ã€‚äº¤äº’ä¸éš¾ï¼ä½¿ç”¨åˆé€‚çš„æ–¹æ³•ï¼Œè·å–å…³é”®ä¿¡æ¯ï¼ŒåŠ ä»¥å¤„ç†ï¼Œå†ä¼ å›å»~\nfrom pwn import *import re# ç”¨äºå°†è¾“å…¥å­—ç¬¦ä¸²åˆ‡åˆ†æˆ tokenTOKEN_RE = re.compile(r&#x27;([0-9]+|[iIl]+|[~&amp;^|]|\\(|\\))&#x27;)def tokenize(expr: str) -&gt; list[str]:    &quot;&quot;&quot;    å°†ä¸­ç¼€è¡¨è¾¾å¼å­—ç¬¦ä¸²æ‹†åˆ†æˆ token åˆ—è¡¨ã€‚    æ”¯æŒï¼š      - åè¿›åˆ¶æ•´æ•°ï¼Œå¦‚ 1234      - ç”± i, I, l æ„æˆçš„å˜é‡åï¼Œå¦‚ iiIIlI      - å•å­—ç¬¦è¿ç®—ç¬¦ ~ &amp; ^ |      - æ‹¬å· ( )    &quot;&quot;&quot;    tokens = TOKEN_RE.findall(expr)    if &#x27;&#x27;.join(tokens) != expr.strip().replace(&#x27; &#x27;, &#x27;&#x27;):        raise ValueError(&quot;éæ³•å­—ç¬¦æˆ–æ ¼å¼é”™è¯¯&quot;)    return tokensdef infix_to_rpn(expr: str) -&gt; str:    &quot;&quot;&quot;    å°†ä¸­ç¼€è¡¨è¾¾å¼ expr è½¬æˆé€†æ³¢å…°è¡¨è¾¾å¼ï¼Œ    è¿”å›ä¸€ä¸ªä»¥ç©ºæ ¼åˆ†éš”çš„ RPN å­—ç¬¦ä¸²ã€‚    &quot;&quot;&quot;    tokens = tokenize(expr)    # è¿ç®—ç¬¦ä¼˜å…ˆçº§    prec = &#123;&#x27;~&#x27;: 4, &#x27;&amp;&#x27;: 3, &#x27;^&#x27;: 2, &#x27;|&#x27;: 1&#125;    # ä¸€å…ƒè¿ç®—ç¬¦ ~ å³ç»“åˆï¼ŒäºŒå…ƒè¿ç®—ç¬¦å·¦ç»“åˆ    right_assoc = &#123;&#x27;~&#x27;&#125;    output: list[str] = []    ops: list[str] = []    for t in tokens:        if re.fullmatch(r&#x27;\\d+|[iIl]+&#x27;, t):            # æ•°å­—æˆ–å˜é‡            output.append(t)        elif t in prec:            # è¿ç®—ç¬¦            while ops and ops[-1] in prec:                top = ops[-1]                if (prec[top] &gt; prec[t] or                        (prec[top] == prec[t] and t not in right_assoc)):                    output.append(ops.pop())                else:                    break            ops.append(t)        elif t == &#x27;(&#x27;:            ops.append(t)        elif t == &#x27;)&#x27;:            # å¼¹å‡ºç›´åˆ°å·¦æ‹¬å·            while ops and ops[-1] != &#x27;(&#x27;:                output.append(ops.pop())            if not ops or ops[-1] != &#x27;(&#x27;:                raise ValueError(&quot;æ‹¬å·ä¸åŒ¹é…&quot;)            ops.pop()  # ä¸¢å¼ƒ &#x27;(&#x27;        else:            raise ValueError(f&quot;æœªçŸ¥ token: &#123;t&#125;&quot;)    # æœ€åæŠŠå‰©ä½™è¿ç®—ç¬¦éƒ½å¼¹å‡º    while ops:        if ops[-1] in (&#x27;(&#x27;, &#x27;)&#x27;):            raise ValueError(&quot;æ‹¬å·ä¸åŒ¹é…&quot;)        output.append(ops.pop())    return &#x27; &#x27;.join(output)conn = remote(&#x27;gacha-gate.chal.idek.team&#x27;, 1337)context.log_level = &#x27;debug&#x27;conn.recvuntil(b&#x27;lets play a game!\\n&#x27;)for i in range(50):    expression = conn.recvline().decode()    #print(f&#x27;expression: &#123;expression&#125;&#x27;)    ans = infix_to_rpn(expression)    conn.sendline(ans.encode())    conn.recvuntil(b&#x27;let me see..\\n&#x27;)conn.interactive()\nåè®°å¤ªå¼±å•¦å¤ªå¼±å•¦ï¼cryptoå’ŒreåŒä¿®çš„æˆ‘æ ¹æœ¬åšä¸å‡ºæ¥å‡ é“å‘¢ï¼Œæˆ‘å¾ˆæƒ³çœ‹çœ‹é‚£å‡ é“æ¤­åœ†æ›²çº¿çš„é¢˜ç›®æ˜¯å¦‚ä½•è§£çš„ï¼Œä¸€ç‚¹æ€è·¯éƒ½æ²¡æœ‰ï¼Œä»¥åŠé‚£ä¸ª5ç¾å…ƒå¤–åŒ…çš„vmï¼Œè™½ç„¶å·²ç»æœ‰ä¸€äº›è¿›å±•äº†ï¼ˆæŒ‡çœ‹åˆ°äº†è¾“å…¥ i å¯ä»¥è°ƒå‡ºå¯„å­˜å™¨ï¼‰ï¼Œä½†æ˜¯åé¢çš„å·¥ç¨‹ä¼¼ä¹è¿˜å¾ˆå¤§ï¼ŒçŒªè„‘è¿‡è½½äº†å–µ&gt;_&lt;\nç­‰å¤§æ‰‹å­å¸ˆå‚…çš„wpï¼ˆèºº\n"}]