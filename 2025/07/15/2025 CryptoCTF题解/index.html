<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CryptoCTF 题解 | Illunight的收藏品</title><meta name="author" content="Illunight"><meta name="copyright" content="Illunight"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言最近正值暑假，闲着也是闲着，于是来玩玩吧。我发现自己真的很弱小，这些赛题的分值与解出的队伍数量成反比，将所有的题目按照最终分值排序，我恰好完成了分值最少的四道。加上事后补的两道，共完成了分值最少的六道。 ——就是说难的一道都不会（躺） 正文既然都这样了，那干脆就按照最终题目分数升序写题解吧，按理来说，越前面的越简单。 1.Vinad观察代码，我们得到了pubkey的第1和第2项，即R和p*q，">
<meta property="og:type" content="article">
<meta property="og:title" content="CryptoCTF 题解">
<meta property="og:url" content="https://xelinquency.github.io/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Illunight的收藏品">
<meta property="og:description" content="前言最近正值暑假，闲着也是闲着，于是来玩玩吧。我发现自己真的很弱小，这些赛题的分值与解出的队伍数量成反比，将所有的题目按照最终分值排序，我恰好完成了分值最少的四道。加上事后补的两道，共完成了分值最少的六道。 ——就是说难的一道都不会（躺） 正文既然都这样了，那干脆就按照最终题目分数升序写题解吧，按理来说，越前面的越简单。 1.Vinad观察代码，我们得到了pubkey的第1和第2项，即R和p*q，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xelinquency.github.io/img/404.jpg">
<meta property="article:published_time" content="2025-07-15T14:24:21.000Z">
<meta property="article:modified_time" content="2025-10-10T14:21:36.572Z">
<meta property="article:author" content="Illunight">
<meta property="article:tag" content="Writeup">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="CryptoCTF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xelinquency.github.io/img/404.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CryptoCTF 题解",
  "url": "https://xelinquency.github.io/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/",
  "image": "https://xelinquency.github.io/img/404.jpg",
  "datePublished": "2025-07-15T14:24:21.000Z",
  "dateModified": "2025-10-10T14:21:36.572Z",
  "author": [
    {
      "@type": "Person",
      "name": "Illunight",
      "url": "https://xelinquency.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://xelinquency.github.io/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="DBE1_SX4G9tMN1JolnkxhQxmkqC7KxJHBS654vVGjaE"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CryptoCTF 题解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-pen-nib"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/friends"><i class="fa-fw fas fa-users-line"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-paw"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/special/"><i class="fa-fw fas fa-clipboard-question"></i><span> ???</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/404.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.ico" alt="Logo"><span class="site-name">Illunight的收藏品</span></a><a class="nav-page-title" href="/"><span class="site-name">CryptoCTF 题解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-pen-nib"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/friends"><i class="fa-fw fas fa-users-line"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-paw"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/special/"><i class="fa-fw fas fa-clipboard-question"></i><span> ???</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CryptoCTF 题解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-15T14:24:21.000Z" title="发表于 2025-07-15 22:24:21">2025-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-10T14:21:36.572Z" title="更新于 2025-10-10 22:21:36">2025-10-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正值暑假，闲着也是闲着，于是来玩玩吧。我发现自己真的很弱小，这些赛题的分值与解出的队伍数量成反比，将所有的题目按照最终分值排序，我恰好完成了分值最少的四道。加上事后补的两道，共完成了分值最少的六道。</p>
<p>——就是说难的一道都不会（躺）</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>既然都这样了，那干脆就按照最终题目分数升序写题解吧，按理来说，越前面的越简单。</p>
<h3 id="1-Vinad"><a href="#1-Vinad" class="headerlink" title="1.Vinad"></a>1.Vinad</h3><p>观察代码，我们得到了<code>pubkey</code>的第1和第2项，即<code>R</code>和<code>p*q</code>，和加密后的<code>c</code>。<br>若要解出原文，需要得到<code>p</code>或者<code>q</code>，以及<code>e</code>。在<code>genkey()</code>函数中，<code>q</code>是随机生成的512位质数，<code>p</code>和<code>e</code>都与函数<code>vinad()</code>有关，我们自然想知道，<code>vinad()</code>在做什么。<br>对于给定的列表<code>R</code>，<code>vinad()</code>取出每一个元素<code>r</code>，将其与<code>x</code>异或，返回异或后的<code>&#39;1&#39;</code>的个数的奇偶，奇数为1，偶数为0。将所有的<code>r</code>如此操作，结果拼成的字符串就是返回值的二进制形式。<br>假设其中某两次取出的元素为$r_1$和$r_2$，那么，记$x \oplus r_1 = k_1$，$x \oplus r_2 = k_2$，则$k_1 \oplus k_2 = \text{XOR}(x,r_1,x,r_2)$。而$x \oplus x = 0$，对结果没有影响，所以$k_1 \oplus k_2 = r_1 \oplus r_2$。其中$\oplus$符号和$\text{XOR}$均表示异或。<br>这样一来，虽然<code>x</code>是一个很大的未知数，但任意两个结果的异或值都已经能从<code>R</code>中知晓，换言之，只要知道了其中一个结果(0或者1)，就知道了全部的结果。<code>x</code>实际上和只能取0/1没有区别。<br>所以，我们取<code>x=0</code>，得到<code>Q = int(&#39;&#39;.join(str(parinad(R[i])) for i in range(512)), 2)</code>，得到<code>p</code>的一个候选值；如果<code>n%Q!=0</code>，即<code>Q</code>不正确，那么，将每一位取反，就是另一个候选值<code>Q_alt</code>。<br>经过验证，可以得到<code>p</code>和<code>q</code>。</p>
<p>对于<code>e</code>，我们已经分析得到<code>vinad()</code>函数在<code>R</code>给定的情况下只有两种可能的结果，用<code>Q</code>和<code>Q_alt</code>试两次就可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Crypto CTF https://cr.yp.toc.tf/ vinad题解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">R = [] <span class="comment">#R太占版面了，就删掉了。题目附件里已经给出</span></span><br><span class="line">n = <span class="number">58113574203067314600162910771848744432179168354040678920098167335472534222998261639291145191568159464990603689062679467360303185717662426122140998218656632568172511390111887830539687208220100574329903748617343193392646019854280519859403817579746765861359633174218846216669659258251676438195667516224684805919</span></span><br><span class="line">c = <span class="number">56754194307199340085459028397027924827853574000671575387226403396873568994756738512141122143372650573201079937375922460851170745485734799044781029943783218210457587599666501326645229924138230588050782907693019958930006807017898115655426823272342984109999519420817119999272583495848119171867835187241510764427</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parinad</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(n)[<span class="number">2</span>:].count(<span class="string">&#x27;1&#x27;</span>) % <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 求出p和q</span></span><br><span class="line">Q = <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(parinad(R[i])) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">512</span>)), <span class="number">2</span>)</span><br><span class="line">Q_alt = (<span class="number">1</span>&lt;&lt;<span class="number">512</span>) - <span class="number">1</span> - Q</span><br><span class="line"><span class="keyword">if</span> n % Q == <span class="number">0</span> <span class="keyword">and</span> isPrime(Q):</span><br><span class="line">    p = Q</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = Q_alt</span><br><span class="line"><span class="comment">#print(p)</span></span><br><span class="line"><span class="keyword">assert</span> isPrime(p) <span class="keyword">and</span> n%p==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(sum(R))</span></span><br><span class="line"></span><br><span class="line">e = Q_alt</span><br><span class="line">q = n//p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 计算欧拉函数 φ(n)</span></span><br><span class="line">phi_n = (q - <span class="number">1</span>)*(p - <span class="number">1</span>)</span><br><span class="line"><span class="comment">#print(&quot;phi = &quot;,phi_n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 计算 d (e 的模 φ(n) 的乘法逆元)</span></span><br><span class="line">d = inverse(e, phi_n)</span><br><span class="line"><span class="comment">#print(&quot;d = &quot;,d)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 解密消息 m</span></span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)  <span class="comment"># 快速模幂运算</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的消息 m 为:&quot;</span>, long_to_bytes(m - <span class="built_in">sum</span>(R)))</span><br><span class="line"><span class="comment">#CCTF&#123;s0lV1n9_4_Syst3m_0f_L1n3Ar_3qUaTi0n5_0vEr_7H3_F!3lD_F(2)!&#125;</span></span><br><span class="line"><span class="comment">#本题由ChatGPT提供思路与代码</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Interpol"><a href="#2-Interpol" class="headerlink" title="2.Interpol"></a>2.Interpol</h3><p>观察代码，<code>randpos()</code>函数在0和1之间选一个数。如果选1，返回<code>True</code>和一个有两个数的元组，这两个数和<code>flag</code>相关；如果选0，返回<code>False</code>和另外一个元组，这个元组的两个数是一个随机整数和一个随机的有理数。<br>接下来是<code>while(True)</code>部分：先得到一个<code>randpos()</code>的结果，如果返回<code>True</code>，那么<code>n</code>自增1，否则<code>n</code>不增加。但无论如何，<code>DATA</code>都会将新生成的元组加入，例外情况是<code>_d[0][0]</code>在<code>H</code>中，即元组的第一个数在<code>H</code>中。<br>接下来使用拉格朗日插值，将以上元组表示的点变为一个有理数域的函数，我们最后得到了这个函数。<br>因此，函数上的点就包含了<code>flag</code>上的点，根据<code>randpos()</code>函数我们可以发现，由<code>flag</code>得到的点，其横坐标一定是负数，纵坐标一定是整数，而随机点的横坐标大于等于0，纵坐标也是两个质数之比，不会是整数。我们据此得到所有满足<code>x&lt;0</code>的整点，就是由<code>flag</code>得到的点。<br>对于点<code>(-x,y)</code>，我们有<code>x = 1 + (19*n - 14) % len(flag)</code>，<code>y = ord(flag[(63 * n - 40) % len(flag)])</code>。（<code>n&lt;len(flag)</code>）即：<br>$n = (x + 13) \times \text{inverse}(19)\space \bmod \text{len(flag)}$，$\text{chr}(y) = \text{flag}[(63 \times n - 40)\space \bmod \text{len(flag)}]$。于是可以根据每个<code>x</code>得到对应的<code>n</code>，进而得到<code>flag</code>中每个字符的位置。这里假设<code>len(flag)</code>和19，和63均互质，否则，<code>flag</code>不唯一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Crypto CTF https://cr.yp.toc.tf/ Interpol题解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 output.raw 加载序列化多项式</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.raw&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    poly_str = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化多项式</span></span><br><span class="line">P = loads(poly_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多项式函数 p(x)</span></span><br><span class="line">p = P</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤1: 收集候选真点 (x, y)，其中 x 为负整数，p(x) 为整数</span></span><br><span class="line">points = []</span><br><span class="line">x_val = -<span class="number">1</span></span><br><span class="line">consecutive_non_integer = <span class="number">0</span></span><br><span class="line">threshold = <span class="number">20</span>  <span class="comment"># 连续非整数阈值，用于停止迭代</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> consecutive_non_integer &lt; threshold:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        y_val = p(x_val)  <span class="comment"># 计算 p(x)</span></span><br><span class="line">        <span class="comment"># 检查是否为整数（有理数且分母为1）</span></span><br><span class="line">        <span class="keyword">if</span> y_val <span class="keyword">in</span> ZZ <span class="keyword">or</span> (y_val <span class="keyword">in</span> QQ <span class="keyword">and</span> y_val.denominator() == <span class="number">1</span>):</span><br><span class="line">            points.append((x_val, ZZ(y_val)))  <span class="comment"># 记录点</span></span><br><span class="line">            consecutive_non_integer = <span class="number">0</span>  <span class="comment"># 重置计数器</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            consecutive_non_integer += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># 处理可能的求值错误（如 x 过大）</span></span><br><span class="line">        consecutive_non_integer += <span class="number">1</span></span><br><span class="line">    x_val -= <span class="number">1</span>  <span class="comment"># 移至下一个负整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;未找到候选点。检查文件路径或多项式。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按 x 排序（降序：-1, -2, -3, ...）</span></span><br><span class="line">points.sort(key=<span class="keyword">lambda</span> pt: pt[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2: 推导 L = len(flag)</span></span><br><span class="line">min_x = <span class="built_in">min</span>(x <span class="keyword">for</span> x, y <span class="keyword">in</span> points)  <span class="comment"># 最小 x（最负）</span></span><br><span class="line">L_candidate = -min_x  <span class="comment"># L = -min_x</span></span><br><span class="line">num_points = <span class="built_in">len</span>(points)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证点数是否合理（应接近 L_candidate）</span></span><br><span class="line"><span class="keyword">if</span> num_points &lt; L_candidate:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;警告: 只找到 <span class="subst">&#123;num_points&#125;</span> 个点，但 L_candidate = <span class="subst">&#123;L_candidate&#125;</span>。可能有遗漏。&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num_points &gt; L_candidate:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;警告: 找到 <span class="subst">&#123;num_points&#125;</span> 个点，但 L_candidate = <span class="subst">&#123;L_candidate&#125;</span>。可能有误报。&quot;</span>)</span><br><span class="line">    <span class="comment"># 截断至前 L_candidate 个点（假设 x 最小的点可能为误报）</span></span><br><span class="line">    points = points[:L_candidate]</span><br><span class="line"></span><br><span class="line">L = L_candidate  <span class="comment"># 使用 L_candidate 作为 flag 长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3: 计算 19 模 L 的逆元（用于索引映射）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    inv19 = inverse_mod(<span class="number">19</span>, L)  <span class="comment"># 19 在模 L 下的逆元</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">f&quot;19 和 L=<span class="subst">&#123;L&#125;</span> 不互质，无法计算逆元。错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4: 映射每个点到 flag 字符</span></span><br><span class="line">flag_array = [<span class="literal">None</span>] * L  <span class="comment"># 初始化 flag 数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> points:</span><br><span class="line">    <span class="comment"># 计算 a = (19n - 14) % L（来自真点 x 公式）</span></span><br><span class="line">    a = -<span class="number">1</span> - x  <span class="comment"># 因为 x = -(1 + a)</span></span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">or</span> a &gt;= L:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;警告: x=<span class="subst">&#123;x&#125;</span> 的 a=<span class="subst">&#123;a&#125;</span> 超出 [0, L-1]。跳过。&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算 n（真点索引）</span></span><br><span class="line">    c = a + <span class="number">14</span>  <span class="comment"># 来自 a = (19n - 14) % L</span></span><br><span class="line">    n_val = (c * inv19) % L  <span class="comment"># n = (c * inv19) mod L</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算 b（flag 字符位置）</span></span><br><span class="line">    b_val = (<span class="number">63</span> * n_val - <span class="number">40</span>) % L  <span class="comment"># b = (63n - 40) % L</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查 y 是否为可打印 ASCII</span></span><br><span class="line">    <span class="keyword">if</span> y &lt; <span class="number">32</span> <span class="keyword">or</span> y &gt; <span class="number">126</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;警告: x=<span class="subst">&#123;x&#125;</span> 的 y=<span class="subst">&#123;y&#125;</span> 不是可打印 ASCII。跳过。&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 存储字符（位置 b_val）</span></span><br><span class="line">    flag_array[b_val] = <span class="built_in">chr</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否所有位置都已填充</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">None</span> <span class="keyword">in</span> flag_array:</span><br><span class="line">    missing = [i <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag_array) <span class="keyword">if</span> char <span class="keyword">is</span> <span class="literal">None</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;警告: 位置 <span class="subst">&#123;missing&#125;</span> 未填充。尝试调整点集合或 L。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有位置填充成功。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 flag 字符串</span></span><br><span class="line">flag_str = <span class="string">&#x27;&#x27;</span>.join(flag_array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;恢复的 flag: <span class="subst">&#123;flag_str&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#CCTF&#123;7h3_!nTeRn4t10naL_Cr!Min41_pOlIc3_0r9An!Zati0n!&#125;</span></span><br><span class="line"><span class="comment">#本题由ChatGPT和Deepseek提供思路，Deepseek提供代码</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Mechanic"><a href="#3-Mechanic" class="headerlink" title="3.Mechanic"></a>3.Mechanic</h3><p>代码很短，但是遇见了不认识的库，多半是在调用库函数加密了，上网找找如何解密。<br>搜索KryptonKEM找到了<a target="_blank" rel="noopener" href="https://github-wiki-see.page/m/aabmets/quantcrypt/wiki/Code-Examples，看到“KryptonKEM">https://github-wiki-see.page/m/aabmets/quantcrypt/wiki/Code-Examples，看到“KryptonKEM</a> for Asymmetric File Encryption”一节，找到了相关的示例代码。<br>加密的流程是，读取flag.png，生成40位随机数，根据该随机数的比特，决定是对明文/上一轮密文进行一次加密，并将skey(secret_key)写入文件中，还是伪造一组skey写入文件中。<br>因此，一共生成了40次密钥，其中有部分是真的，也有一些是假的。根据最后的文件名flag_22.enc，一共进行了23轮加密。同时我们可以知道，先加密的密钥一定在后加密的密钥之前。所以，我们可以从最后一个密钥开始，不断向前试探，得到最初的文件。<br>如果遇到假私钥，解密会报错，根据能否解密判断是否为真的私钥。为了防止解密中间文件被占用而无法写入，每一个文件都使用不同的文件名。运行一遍程序，就可以得到最初的flag.png<br>以及，kem.param_sizes.sk_size = 3168（自己偷偷装这个库，在python跑一遍就知道了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Crypto CTF https://cr.yp.toc.tf/ mechanic题解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> quantcrypt.kem <span class="keyword">import</span> MLKEM_1024</span><br><span class="line"><span class="keyword">from</span> quantcrypt.cipher <span class="keyword">import</span> KryptonKEM</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">kem = MLKEM_1024()</span><br><span class="line">kry = KryptonKEM(MLKEM_1024)</span><br><span class="line">SK_SIZE = <span class="number">3168</span></span><br><span class="line">TOTAL_LAYERS = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. 读取并切分 output.raw ---</span></span><br><span class="line">raw = Path(<span class="string">&#x27;output.raw&#x27;</span>).read_bytes()</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(raw) % SK_SIZE == <span class="number">0</span>, <span class="string">&quot;output.raw 长度必须是 SK_SIZE 的整数倍&quot;</span></span><br><span class="line">chunks = [ raw[i:i+SK_SIZE]</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(raw), SK_SIZE) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 准备初始密文路径 ---</span></span><br><span class="line">current_ct = Path(<span class="string">&#x27;flag_22.enc&#x27;</span>)</span><br><span class="line">found_sks = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从后往前遍历每一段私钥</span></span><br><span class="line"><span class="keyword">for</span> idx, sk <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(chunks)):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(found_sks) &gt;= TOTAL_LAYERS:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成唯一的临时输出文件名</span></span><br><span class="line">    tmp_path = Path(<span class="string">f&#x27;tmp_<span class="subst">&#123;<span class="built_in">len</span>(found_sks)&#125;</span>.out&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 解密到唯一文件</span></span><br><span class="line">        kry.decrypt_to_file(sk, current_ct, tmp_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解密成功，记录私钥，并更新 current_ct</span></span><br><span class="line">        found_sks.append(sk)</span><br><span class="line">        current_ct = tmp_path</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;✔ 用 chunks[<span class="subst">&#123;<span class="built_in">len</span>(chunks)-<span class="number">1</span>-idx&#125;</span>] 解出了第 <span class="subst">&#123;<span class="built_in">len</span>(found_sks)&#125;</span> 层 → <span class="subst">&#123;tmp_path.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: &quot;</span>,e)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(found_sks) == TOTAL_LAYERS, <span class="string">&quot;没找到所有私钥段！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终把 current_ct 重命名为 flag.png</span></span><br><span class="line">current_ct.rename(<span class="string">&#x27;flag.png&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;🎉 已成功还原出 flag.png&quot;</span>)</span><br><span class="line"><span class="comment">#CCTF&#123;k3y_3NcAp5uL4t!0n_M3cH4n1Sms!&#125;</span></span><br><span class="line"><span class="comment">#本题由ChatGPT提供思路和代码，略做修正</span></span><br></pre></td></tr></table></figure>
<h3 id="4-Mancity"><a href="#4-Mancity" class="headerlink" title="4.Mancity"></a>4.Mancity</h3><p>气急败坏的典型示例——不过还是先分析一下代码吧<br><code>keygen()</code>生成了两个质数，这两个质数都由同一个256bit的质数<code>p</code>变化而来，质数<code>r</code>在<code>p</code>的每一个bit后都增加一个<code>&#39;1&#39;</code>，质数<code>q</code>在<code>p</code>后面增加256个<code>&#39;1&#39;</code>，这样<code>q</code>和<code>r</code>都是512位质数，且其中一半的位我们已经知道了<br>假设<code>bin(p)</code>=10010…01，则<code>r</code> = 1<u>1</u>0<u>1</u>0<u>1</u>1<u>1</u>0<u>1</u>…0<u>1</u>1<u>1</u>，<code>q</code> = 10010…01<u>1111…11</u>，则<code>q</code>的低256位已知。我们将<code>q</code>和<code>r</code>划分为high和low，其中高256位为high，低256位为low，则$q_{low} = 2^{256}-1$。对$n = q*r$两边同时模$2^{256}$，则可知$n$的低256位完全由$q_{low}$和$r_{low}$决定，于是可以求$q_{low}$的逆元，乘上$n$的低256位，再模$2^{256}$，得到$r_{low}$。<br>$r_{low}$的二进制形式里，有一半是<code>&#39;1</code>‘，另一半是<code>p</code>的低128位。由此我们得到了<code>p</code>的低128位，也就是<code>q</code>的256-383位，于是可以重复上述过程，每次只需要调整模数，就可以不断向p的高位推进。<br>理论上这个方法可以推进到只剩最后1位未知，实际上运行到240位的时候就报错了，不过剩下16位并不算多，暴力破解一轮即可。得到<code>p</code>后推出<code>q</code>和<code>r</code>，进而还原消息<code>m</code>。</p>
<p>事后发现，如果$r_{low}$解出来的最高位是0，那么填充1的位置不会被正确检测到，因而不能得到正确的<code>p</code>。我增加了对于$r_{low}$比特长度的检测，如果是奇数，就补上最前面的<code>&#39;0&#39;</code>，这样就可以继续解码了。枉我气急败坏，甚至写了5个同样的函数去做同一件事……还是不够老练<br>只需要使用最后的<code>recover()</code>函数，循环代入每一轮的<code>p</code>，加上最后256个<code>&#39;1&#39;</code>作为$q_{low}$，即可解出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Crypto CTF https://cr.yp.toc.tf/ Mancity题解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">p_man:<span class="built_in">str</span></span>):</span><br><span class="line">    orig_bits = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(p_man), <span class="number">2</span>):</span><br><span class="line">        two_bits = p_man[i:i + <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> two_bits == <span class="string">&#x27;01&#x27;</span>:</span><br><span class="line">            orig_bits += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> two_bits == <span class="string">&#x27;11&#x27;</span>:</span><br><span class="line">            orig_bits += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Invalid bit pair: <span class="subst">&#123;two_bits&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> orig_bits</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_256</span>(<span class="params">n:<span class="built_in">int</span></span>):</span><br><span class="line">    q = <span class="number">2</span>**<span class="number">256</span>-<span class="number">1</span></span><br><span class="line">    modulus = <span class="number">2</span> ** (<span class="number">32</span> + <span class="number">64</span> + <span class="number">128</span> + <span class="number">256</span>)</span><br><span class="line">    inv = <span class="built_in">pow</span>(q, -<span class="number">1</span>, modulus)</span><br><span class="line">    p = <span class="built_in">bin</span>((n % modulus) * inv % modulus)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) % <span class="number">2</span>:</span><br><span class="line">        p = <span class="string">&#x27;0&#x27;</span> + p</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(p[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_128</span>(<span class="params">n:<span class="built_in">int</span></span>):</span><br><span class="line">    q = <span class="built_in">int</span>(<span class="string">&#x27;11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;</span>+<span class="string">&#x27;1&#x27;</span>*<span class="number">256</span>,<span class="number">2</span>)</span><br><span class="line">    modulus = <span class="number">2</span> ** (<span class="number">32</span> + <span class="number">64</span> + <span class="number">128</span> + <span class="number">256</span>)</span><br><span class="line">    inv = <span class="built_in">pow</span>(q, -<span class="number">1</span>, modulus)</span><br><span class="line">    p = <span class="built_in">bin</span>((n % modulus) * inv % modulus)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) % <span class="number">2</span>:</span><br><span class="line">        p = <span class="string">&#x27;0&#x27;</span> + p</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(p[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_64</span>(<span class="params">n:<span class="built_in">int</span></span>):</span><br><span class="line">    q = <span class="built_in">int</span>(<span class="string">&#x27;111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;</span>+<span class="string">&#x27;1&#x27;</span>*<span class="number">256</span>,<span class="number">2</span>)</span><br><span class="line">    modulus = <span class="number">2</span> ** (<span class="number">32</span> + <span class="number">64</span> + <span class="number">128</span> + <span class="number">256</span>)</span><br><span class="line">    inv = <span class="built_in">pow</span>(q, -<span class="number">1</span>, modulus)</span><br><span class="line">    p = <span class="built_in">bin</span>((n % modulus) * inv % modulus)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) % <span class="number">2</span>:</span><br><span class="line">        p = <span class="string">&#x27;0&#x27;</span> + p</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(p[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_32</span>(<span class="params">n:<span class="built_in">int</span></span>):</span><br><span class="line">    q = <span class="built_in">int</span>(<span class="string">&#x27;11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;</span>+<span class="string">&#x27;1&#x27;</span>*<span class="number">256</span>,<span class="number">2</span>)</span><br><span class="line">    modulus = <span class="number">2</span> ** (<span class="number">32</span> + <span class="number">64</span> + <span class="number">128</span> + <span class="number">256</span>)</span><br><span class="line">    inv = <span class="built_in">pow</span>(q, -<span class="number">1</span>, modulus)</span><br><span class="line">    p = <span class="built_in">bin</span>((n % modulus) * inv % modulus)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) % <span class="number">2</span>:</span><br><span class="line">        p = <span class="string">&#x27;0&#x27;</span> + p</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(p[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_16</span>(<span class="params">n:<span class="built_in">int</span></span>):</span><br><span class="line">    q = <span class="built_in">int</span>(<span class="string">&#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;</span>+<span class="string">&#x27;1&#x27;</span>*<span class="number">256</span>,<span class="number">2</span>)</span><br><span class="line">    modulus = <span class="number">2</span> ** (<span class="number">32</span> + <span class="number">64</span> + <span class="number">128</span> + <span class="number">256</span>)</span><br><span class="line">    inv = <span class="built_in">pow</span>(q, -<span class="number">1</span>, modulus)</span><br><span class="line">    p = <span class="built_in">bin</span>((n % modulus) * inv % modulus)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) % <span class="number">2</span>:</span><br><span class="line">        p = <span class="string">&#x27;0&#x27;</span> + p</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(p[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover</span>(<span class="params">n:<span class="built_in">int</span>,q_bit:<span class="built_in">str</span></span>):</span><br><span class="line">    q = <span class="built_in">int</span>(q_bit+<span class="string">&#x27;1&#x27;</span>*<span class="number">256</span>, <span class="number">2</span>)</span><br><span class="line">    modulus = <span class="number">2</span> ** (<span class="built_in">len</span>(q_bit) + <span class="number">256</span>)</span><br><span class="line">    inv = <span class="built_in">pow</span>(q, -<span class="number">1</span>, modulus)</span><br><span class="line">    p = <span class="built_in">bin</span>((n % modulus) * inv % modulus)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) % <span class="number">2</span>:</span><br><span class="line">        p = <span class="string">&#x27;0&#x27;</span> + p</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(p[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定参数</span></span><br><span class="line">n = <span class="number">147170819334030469053514652921356515888015711942553338463409772437981228515273287953989706666936875524451626901247038180594875568558137526484665015890594045767912340169965961750130156341999306808017498374501001042628249176543370525803456692022546235595791111819909503496986338431136130272043196908119165239297</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复因子</span></span><br><span class="line"><span class="comment">#p = recover_256(n)</span></span><br><span class="line"><span class="comment">#print(decode(p))</span></span><br><span class="line"><span class="comment">#第一轮的p:11011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111</span></span><br><span class="line"><span class="comment">#这是最低的128位</span></span><br><span class="line"><span class="comment">#p2 = recover_128(n)</span></span><br><span class="line"><span class="comment">#print(decode(p2))</span></span><br><span class="line"><span class="comment">#第二轮的p:111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111</span></span><br><span class="line"><span class="comment">#这是128+64=192位</span></span><br><span class="line"><span class="comment">#p3 = recover_64(n)</span></span><br><span class="line"><span class="comment">#print(decode(p3))</span></span><br><span class="line"><span class="comment">#第三轮的p：11110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111</span></span><br><span class="line"><span class="comment">#128+64+32=224位</span></span><br><span class="line"><span class="comment">#p4 = recover_32(n)</span></span><br><span class="line"><span class="comment">#print(decode(p4))</span></span><br><span class="line"><span class="comment">#110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111</span></span><br><span class="line"><span class="comment">#...+16=240位</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>,<span class="number">2</span>**<span class="number">18</span>):</span><br><span class="line">    s = <span class="built_in">bin</span>(i)[<span class="number">2</span>:] + <span class="string">&#x27;110101000111000011110111000111010010000101100001111101111110100010100000100010100110101111000001100000011010011011011101001110011100110101111001000101001101011110110111001100100001011111001100001100001010001110110001100001000100110111111111&#x27;</span> + <span class="string">&#x27;1&#x27;</span>*<span class="number">256</span></span><br><span class="line">    q = <span class="built_in">int</span>(s, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (n%q):</span><br><span class="line">        <span class="built_in">print</span>(q)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#b&#x27;CCTF&#123;M4nch3sReR_c0D!ng_wI7H_RSA&#125;&#x27;</span></span><br><span class="line"><span class="comment">#本题由自己提供思路和代码</span></span><br></pre></td></tr></table></figure>
<h3 id="5-Vainrat"><a href="#5-Vainrat" class="headerlink" title="5.Vainrat"></a>5.Vainrat</h3><p>这题……我都想原封不动放到我们学校的校赛或者类似的比赛上了，如果我有机会的话。<br>太阴了，阴得没边。<br>服务器创建精度为440位的实数域，每次交互时，输入c获取最新的<code>y</code>值，输入q退出。但是，只有尝试的次数足够多，才能抓到老鼠，得到位置，至少需要20次尝试以后，才能稳定获得<code>y</code>。<br>我们的目标是得到<code>x0</code>，也就是<code>flag</code>转为整数后前面加小数点。由于每次求平均数和开方都会有精度损失，最后可能不能一次解出完整的<code>flag</code>，需要修正。<br>因此我们需要从可以得到的<code>yi</code>中，获得上一步的信息，直到最终的<code>x0</code>。<br>研究一下<code>rat()</code>函数：第一行将<code>x</code>和<code>y</code>求平均数，第二行将<strong>上一步的<code>x</code></strong>和<code>y</code>求几何平均数，最后返回新的<code>x</code>和新的<code>y</code>。如果直接把代码丢给AI，AI们很容易误以为这段代码是求<code>x</code>和<code>y</code>的算数平均数(AM)和几何平均数(GM)，并将AM赋给<code>x</code>，GM赋给<code>y</code>。<br>因为被AI阴了导致没做出来，其实不难的。以及，多次试验会发现，<code>y</code>会越来越小。如果当成AMGM，那每个<code>y</code>都应该小于对应的<code>x</code>，这样<code>y</code>应该越来越大。<br>我先得到两组连续的<code>y</code>。这里运气不错得到了$y_{19}$和$y_{20}$，如果没得到$y_{19}$，拿$y_{21}$也一样。我们有公式$x_i = \frac{(x_{i-1} + y_{i-1})}{2}$，$y_i = \sqrt{x_i y_{i-1}}$。<br>因此，根据连续的$y_i$，$y_{i-1}$，可以得到$x_i = \frac{y_i^2}{y_{i-1}}$。这样我们就有了一组$x_i$和$y_i$。<br>有了$x_i$和$y_i$，就有$y_{i-1} = \frac{y_i^2}{x_i}$，$x_{i-1} = 2x_i - y_{i-1} = 2x_i - \frac{y_i^2}{x_i}$，写出函数。<br>因为懒得打理变量所以即使<code>x</code>回到$x_0$了变量名还是<code>x19</code>（）总之这样就能得到<code>x0</code>了。但是我们不知道<code>flag</code>有多少位，所以需要一位一位尝试，转成比特后全都是可打印字符的/以CCTF开头的就是可能的解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Crypto CTF https://cr.yp.toc.tf/ vainrat题解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def rat(x, y):</span></span><br><span class="line"><span class="string">	x = R(x + y) * R(0.5)</span></span><br><span class="line"><span class="string">	y = R((x * y) ** 0.5) #这个x是上一步的x!也就是算数平均数，而不是参数x</span></span><br><span class="line"><span class="string">	return x, y</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">getcontext().prec = <span class="number">460</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_previous</span>(<span class="params">x:Decimal,y:Decimal</span>)-&gt;(Decimal, Decimal):</span><br><span class="line">    <span class="keyword">return</span> (Decimal(<span class="number">2</span>)*x - (y**<span class="number">2</span>/x),y**<span class="number">2</span>/x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_bytes_printable</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断bytes对象是否可打印。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        data: bytes对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        如果bytes对象可打印，返回True，否则返回False。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">32</span> &lt;= byte &lt;= <span class="number">126</span>):  <span class="comment"># 检查是否在ASCII可打印字符范围</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y20 = Decimal(<span class="string">&#x27;0.850721739388853613891153549431010808552676731821999538996176033215422247824841783375972792896987047341958120004524577777036176502090&#x27;</span>)</span><br><span class="line">y19 = Decimal(<span class="string">&#x27;0.850721739389079303159246072119468136821544049380443888847082554769733382902933214834218375079868150945588972107307455168793172804985&#x27;</span>)</span><br><span class="line">y0 = Decimal(<span class="string">&#x27;0.939435784300590373652615235586222521209371224933347916892430414723880727978737194445756901098227178356345123621981413057062575844130&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x19 = Decimal(<span class="number">2</span>)*y20**Decimal(<span class="number">2</span>)/y19 - y19</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    x19,y19 = return_previous(x19,y19)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x = &quot;</span>, x19, <span class="string">&quot;y = &quot;</span>, y19)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">abs</span>(y0 - y19) &lt;Decimal(<span class="string">&quot;0.0000000000000000000000000000000000000000000000000000001&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">461</span>):</span><br><span class="line">    res = <span class="built_in">int</span>(x19*(<span class="number">10</span>**i))</span><br><span class="line">    <span class="keyword">if</span>(is_bytes_printable(long_to_bytes(res))): <span class="built_in">print</span>(long_to_bytes(res))</span><br><span class="line"><span class="comment">#CCTF&#123;h3Ur1s7!c5_anD_iNv4rIanTs_iN_CryptoCTF_2025!&#125;</span></span><br><span class="line"><span class="comment">#本题由ChatGPT和Deepseek提供错误思路，自行调试得到思路和代码</span></span><br></pre></td></tr></table></figure>
<h3 id="6-Matemith"><a href="#6-Matemith" class="headerlink" title="6.Matemith"></a>6.Matemith</h3><p><code>flag</code>分成了长为14的段，但是不知道有多少段，由于后面使用了<code>M[0]</code>到<code>M[5]</code>，我们就假设它有6段吧。<br><code>f</code>到<code>k</code>共6个函数，次数都是2~3次，变量也很多，所有的系数都是小于某个313位质数<code>p</code>的随机数。<br>然后，将每个函数转换到有理数域<code>R</code>上，代入<code>u</code>到<code>z</code>为<code>M[0]</code>到<code>M[5]</code>，计算出结果存入<code>CNST</code>。<br>例：<code>f(M[0], M[1], M[2], M[3], M[4], M[5]) = COEFS[0] * M[0] * M[1] + COEFS[1] * M[0] + COEFS[2] * M[1]</code><br>之后对于每一个函数都加上一个常数项，常数项是<code>p</code>减去上面的计算结果，再模<code>p</code>，也就是说，在模<code>p</code>的意义下，每个函数都满足<code>function(M[0], M[1], M[2], M[3], M[4], M[5])-CNST[function] ≡ 0 (mod p)</code><br>因此，我们需要求出满足六个同余方程的解，并选出长度均为14字节的整数结果。由于方程较多，变量较多，次数也较高，可以分批求解。<br>观察发现，函数<code>f</code>, <code>h</code>, <code>j</code>只有<code>u</code>,<code>v</code>,<code>w</code>三个变量，可以解出它们。利用Sagemath的求解器进行求解，有一个明显短的结果，再用<code>u</code>,<code>v</code>,<code>w</code>代入另外三个方程，这样就只剩三个变量，同样可以解出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Crypto CTF https://cr.yp.toc.tf/ matemith题解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模数 p</span></span><br><span class="line">p = <span class="number">9892984422801315119260311427714389408772405421306235794826917610128461644036928139298330716261</span></span><br><span class="line">F = GF(p)  <span class="comment"># 创建有限域</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将系数转换为有限域元素</span></span><br><span class="line">a1 = F(<span class="number">8593371583346286129538282168765198524220954884352992069219549555526097253129502925759872761483</span>)</span><br><span class="line">b1 = F(<span class="number">8192555264287905175212103898575474256555217842060435386769432116145712989123062847161390929397</span>)</span><br><span class="line">c1 = F(<span class="number">9598573789403814092125115160545174167539204328557118715540593719644188998531033259685435430387</span>)</span><br><span class="line">d1 = F(<span class="number">5738603225260621554442220996093767502015758942320213371600986432070445300427944977409453429117</span>)</span><br><span class="line"></span><br><span class="line">a2 = F(<span class="number">6107224904478508858527197508483774405356161856691777460732363192128980355274418091837270668258</span>)</span><br><span class="line">b2 = F(<span class="number">3584245173493717638976874408629921683995390608944250077841702023698807664457252845973088744491</span>)</span><br><span class="line">c2 = F(<span class="number">5646173287331462026544218972062953582608380797148923127395811758145598594972832047259631339566</span>)</span><br><span class="line">d2 = F(<span class="number">1994681139685786114971936867358158466232859433926848067961874687630342141141862187589124089741</span>)</span><br><span class="line"></span><br><span class="line">a3 = F(<span class="number">1912186465211454827473018892315659311053527670028135595953520151335825509122313783795561869379</span>)</span><br><span class="line">b3 = F(<span class="number">6246883466276200389231653597272295993565421216541002743075041326054203024921176043191679609212</span>)</span><br><span class="line">c3 = F(<span class="number">4002308425802254921531592700910138281674785127934610897914017993007060136199147207365547047048</span>)</span><br><span class="line">d3 = F(<span class="number">973159800079995512996976852328990077106942094656694887771601292254542762394381629810393447820</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明多项式环和变量</span></span><br><span class="line">R.&lt;u,v,w&gt; = PolynomialRing(F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义方程</span></span><br><span class="line">f = a1*u*v + b1*u + c1*v + d1</span><br><span class="line">h = a2*u*w + b2*u + c2*w + d2</span><br><span class="line">j = a3*v*w + b3*v + c3*w + d3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建理想</span></span><br><span class="line">I = R.ideal([f, h, j])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算解集</span></span><br><span class="line">solutions = I.variety()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">if</span> solutions:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;找到 <span class="subst">&#123;<span class="built_in">len</span>(solutions)&#125;</span> 个解:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, sol <span class="keyword">in</span> <span class="built_in">enumerate</span>(solutions, <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 验证解</span></span><br><span class="line">        f_val = f.subs(sol)</span><br><span class="line">        h_val = h.subs(sol)</span><br><span class="line">        j_val = j.subs(sol)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n验证: f=<span class="subst">&#123;f_val&#125;</span>, h=<span class="subst">&#123;h_val&#125;</span>, j=<span class="subst">&#123;j_val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;解 <span class="subst">&#123;i&#125;</span>:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;u = <span class="subst">&#123;sol[u]&#125;</span>, <span class="subst">&#123;long_to_bytes(<span class="built_in">int</span>(sol[u]))&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;v = <span class="subst">&#123;sol[v]&#125;</span>,  <span class="subst">&#123;long_to_bytes(<span class="built_in">int</span>(sol[v]))&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;w = <span class="subst">&#123;sol[w]&#125;</span>,  <span class="subst">&#123;long_to_bytes(<span class="built_in">int</span>(sol[w]))&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未找到解&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知的 u, v, w 值</span></span><br><span class="line">u = F(<span class="number">1078804227986401794161149736863793</span>)</span><br><span class="line">v = F(<span class="number">2033644392583863279506423899386719</span>)</span><br><span class="line">w = F(<span class="number">1631639702310041336611888741434165</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将系数转换为有限域元素</span></span><br><span class="line"><span class="comment"># g 的系数</span></span><br><span class="line">a1 = F(<span class="number">7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641</span>)</span><br><span class="line">a2 = F(<span class="number">6282097687310252658473848438985225466620614743750918909885172321224925965646628839166491648752</span>)</span><br><span class="line">a3 = F(<span class="number">7737077144206080155196706693824644356475708615710271404071364943161652008584970269394416250641</span>)</span><br><span class="line">a4 = F(<span class="number">3354788147890488743832873565215769634619909759459203496980671578348799162553954862104978291860</span>)</span><br><span class="line">a5 = F(<span class="number">2560270290674636359252235177920929027441112715609783111306743340637878970846852799006820932563</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># i 的系数</span></span><br><span class="line">b1 = F(<span class="number">7622670835797214156123791992548663880284352234566921286637648219243086701251627093499322050472</span>)</span><br><span class="line">b2 = F(<span class="number">6026769215097777844835562389865313764490318485655789123763637718591748620654875700763740623760</span>)</span><br><span class="line">b3 = F(<span class="number">8145050175261359549200629067766090532616263522561328878195831921153188650784907223634130346224</span>)</span><br><span class="line">b4 = F(<span class="number">3622105614070476540808786980829452605696331317022729645355376801209444137548670550164418237117</span>)</span><br><span class="line">b5 = F(<span class="number">4800360746061605999597274870855047707130861888252519642520437605796496240599924899885487900040</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># k 的系数</span></span><br><span class="line">c1 = F(<span class="number">1423338294606985951732736428034353751447528399559929388138157330118213387990891693204997290038</span>)</span><br><span class="line">c2 = F(<span class="number">784018806462384388182217012266169299116410899849461442885543245867941419322406775218178098109</span>)</span><br><span class="line">c3 = F(<span class="number">7684681843989505989596042520590550892565982707534588920361260899638313817214040416765327284778</span>)</span><br><span class="line">c4 = F(<span class="number">4982848574842913858489870338816729222210785430242027484672099513487039514577513464674726403409</span>)</span><br><span class="line">c5 = F(<span class="number">7781690757622738625626304200561818137843970209349935834539461705684625161407233281360563620790</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多项式环</span></span><br><span class="line">R.&lt;x, y, z&gt; = PolynomialRing(F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代入已知的 u, v, w 后，g, i, k 成为关于 x, y, z 的方程</span></span><br><span class="line">g = a1 * u * x * y + a2 * v + a3 * x + a4 * y + a5</span><br><span class="line">i = b1 * v * y * z + b2 * w + b3 * y + b4 * z + b5</span><br><span class="line">k = c1 * w * x * z + c2 * u + c3 * x + c4 * z + c5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建理想</span></span><br><span class="line">I = R.ideal([g, i, k])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解方程组</span></span><br><span class="line">solutions = I.variety()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">if</span> solutions:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;找到 <span class="subst">&#123;<span class="built_in">len</span>(solutions)&#125;</span> 个解:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> idx, sol <span class="keyword">in</span> <span class="built_in">enumerate</span>(solutions):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n解 <span class="subst">&#123;idx + <span class="number">1</span>&#125;</span>:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;x = <span class="subst">&#123;sol[x]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;y = <span class="subst">&#123;sol[y]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;z = <span class="subst">&#123;sol[z]&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 验证解</span></span><br><span class="line">        g_val = g.subs(sol)</span><br><span class="line">        i_val = i.subs(sol)</span><br><span class="line">        k_val = k.subs(sol)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;验证: g=<span class="subst">&#123;g_val&#125;</span>, i=<span class="subst">&#123;i_val&#125;</span>, k=<span class="subst">&#123;k_val&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未找到解&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#CCTF&#123;50lv!n6_7H3_H1dD3n__num8Ers_Pr08l3m_f0r_C51dH_4nd_C5uRf_v14_4uT0m473d_C0pp3r5m17h!!?&#125;</span></span><br><span class="line"><span class="comment">#本题由Deepseek提供代码</span></span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>要学的东西好多呢……虽然靠AI能辅助一部分分析和代码工作，不过更多的还是得靠自己&gt;_&lt;</p>
<p>一年来都在浅水区闲逛，格相关的东西几乎都不了解，虽然也经常参考别的师傅的题解吧，不过大多都看不太懂，于是我就希望写细致一点，来访的朋友能看得容易些。正好也尝试一下Hexo的公式，为了正常显示它们也是费了一番心思hhh</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xelinquency.github.io/">Illunight</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xelinquency.github.io/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/">https://xelinquency.github.io/2025/07/15/2025%20CryptoCTF%E9%A2%98%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://XELINQUENCY.github.io" target="_blank">Illunight的收藏品</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Writeup/">Writeup</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/CryptoCTF/">CryptoCTF</a></div><div class="post-share"><div class="social-share" data-image="/img/404.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="第一篇文章"><img class="cover" src="/img/404.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第一篇文章</div></div><div class="info-2"><div class="info-item-1">Hello World!</div></div></div></a><a class="pagination-related  no-desc" href="/2025/08/05/2025%20idekCTF%E9%A2%98%E8%A7%A3/" title="2025 idekCTF题解"><img class="cover" src="/img/404.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">2025 idekCTF题解</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/10/09/2025%20SUSCTF%E9%A2%98%E8%A7%A3/" title="2025 SUSCTF题解"><img class="cover" src="/img/404.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-09</div><div class="info-item-2">2025 SUSCTF题解</div></div></div></a><a class="pagination-related no-desc" href="/2025/08/05/2025%20idekCTF%E9%A2%98%E8%A7%A3/" title="2025 idekCTF题解"><img class="cover" src="/img/404.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-05</div><div class="info-item-2">2025 idekCTF题解</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Illunight</div><div class="author-info-description">CTF, Furry and others</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn"><i></i><span>点开看看这是个啥</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/XELINQUENCY" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=3778180207" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #302425;"></i></a><a class="social-icon" href="mailto:1635570231@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">子雨的碎碎念博客！启用于2025年7月</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Vinad"><span class="toc-number">2.1.</span> <span class="toc-text">1.Vinad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Interpol"><span class="toc-number">2.2.</span> <span class="toc-text">2.Interpol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Mechanic"><span class="toc-number">2.3.</span> <span class="toc-text">3.Mechanic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Mancity"><span class="toc-number">2.4.</span> <span class="toc-text">4.Mancity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Vainrat"><span class="toc-number">2.5.</span> <span class="toc-text">5.Vainrat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Matemith"><span class="toc-number">2.6.</span> <span class="toc-text">6.Matemith</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">3.</span> <span class="toc-text">后记</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Illunight</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div><div class="footer_custom_text">幻夜子雨想要留下flag{Th4nk5_f0R_V1siTing!}</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="在知识的荒原里找到你需要的" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>